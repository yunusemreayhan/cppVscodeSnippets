{
    "cpp_11__auto_and_decltype": {
        "prefix": "cpp_11__auto_and_decltype",
        "body": [
            "// C++11: auto and decltype",
            "auto x = 42;                    // int",
            "auto y = 3.14;                  // double",
            "auto str = std::string(\"hello\"); // std::string",
            "",
            "// decltype for type deduction",
            "int a = 5;",
            "decltype(a) b = 10;            // int",
            "decltype((a)) c = a;           // int& (note double parentheses)",
            "decltype(a + b) d = a + b;     // int",
            "",
            "// Trailing return type with decltype",
            "template<typename T, typename U>",
            "auto add(T t, U u) -> decltype(t + u) {",
            "    return t + u;",
            "}",
            "$0"
        ],
        "description": "C++11 auto and decltype for type deduction"
    },
    "cpp_11__range_for": {
        "prefix": "cpp_11__range_for",
        "body": [
            "// C++11: Range-based for loop",
            "std::vector<int> vec = {1, 2, 3, 4, 5};",
            "",
            "// By value",
            "for (int x : vec) {",
            "    std::cout << x << \" \";",
            "}",
            "",
            "// By reference",
            "for (int& x : vec) {",
            "    x *= 2;",
            "}",
            "",
            "// By const reference (preferred for read-only)",
            "for (const auto& x : vec) {",
            "    std::cout << x << \" \";",
            "}",
            "$0"
        ],
        "description": "C++11 range-based for loop"
    },
    "cpp_11__lambda_expressions": {
        "prefix": "cpp_11__lambda_expressions",
        "body": [
            "// C++11: Lambda expressions",
            "",
            "// Basic lambda",
            "auto simple = []() { std::cout << \"Hello Lambda!\\n\"; };",
            "simple();",
            "",
            "// Lambda with parameters and return type",
            "auto add = [](int a, int b) -> int { return a + b; };",
            "std::cout << add(5, 3) << std::endl;",
            "",
            "// Lambda with capture",
            "int x = 10, y = 20;",
            "auto capture_by_value = [x]() { return x * 2; };",
            "auto capture_by_ref = [&x]() { x *= 2; return x; };",
            "auto capture_all_by_value = [=]() { return x + y; };",
            "auto capture_all_by_ref = [&]() { x += 5; y += 5; };",
            "auto capture_mixed = [&x, y]() { x += y; }; // x by ref, y by value",
            "",
            "// Mutable lambda",
            "auto mutable_lambda = [x]() mutable { return ++x; };",
            "",
            "// Lambda with std::function",
            "std::function<int(int, int)> func = [](int a, int b) { return a * b; };",
            "$0"
        ],
        "description": "C++11 lambda expressions"
    },
    "cpp_11__smart_pointers": {
        "prefix": "cpp_11__smart_pointers",
        "body": [
            "// C++11: Smart pointers",
            "#include <memory>",
            "",
            "// unique_ptr - exclusive ownership",
            "std::unique_ptr<int> uptr1(new int(42));",
            "std::unique_ptr<int> uptr2 = std::make_unique<int>(42); // C++14",
            "// uptr2 = uptr1; // Error! Cannot copy",
            "std::unique_ptr<int> uptr3 = std::move(uptr1); // OK, move ownership",
            "",
            "// unique_ptr with custom deleter",
            "auto deleter = [](int* p) { ",
            "    std::cout << \"Custom deleter\\n\"; ",
            "    delete p; ",
            "};",
            "std::unique_ptr<int, decltype(deleter)> uptr4(new int(42), deleter);",
            "",
            "// shared_ptr - shared ownership",
            "std::shared_ptr<int> sptr1(new int(42));",
            "std::shared_ptr<int> sptr2 = std::make_shared<int>(42); // Preferred",
            "std::shared_ptr<int> sptr3 = sptr2; // OK, shared ownership",
            "std::cout << \"Use count: \" << sptr2.use_count() << std::endl;",
            "",
            "// weak_ptr - weak reference",
            "std::weak_ptr<int> wptr = sptr2;",
            "if (auto sptr = wptr.lock()) { // Convert to shared_ptr if still exists",
            "    std::cout << *sptr << std::endl;",
            "}",
            "",
            "// Enable shared_from_this",
            "class Widget : public std::enable_shared_from_this<Widget> {",
            "public:",
            "    std::shared_ptr<Widget> getPtr() {",
            "        return shared_from_this();",
            "    }",
            "};",
            "$0"
        ],
        "description": "C++11 smart pointers (unique_ptr, shared_ptr, weak_ptr)"
    },
    "cpp_11__move_semantics": {
        "prefix": "cpp_11__move_semantics",
        "body": [
            "// C++11: Move semantics and rvalue references",
            "class MyClass {",
            "private:",
            "    int* data;",
            "    size_t size;",
            "",
            "public:",
            "    // Constructor",
            "    MyClass(size_t s) : size(s), data(new int[s]) {",
            "        std::cout << \"Constructor\\n\";",
            "    }",
            "    ",
            "    // Destructor",
            "    ~MyClass() { ",
            "        delete[] data; ",
            "    }",
            "    ",
            "    // Copy constructor",
            "    MyClass(const MyClass& other) : size(other.size), data(new int[size]) {",
            "        std::cout << \"Copy constructor\\n\";",
            "        std::copy(other.data, other.data + size, data);",
            "    }",
            "    ",
            "    // Move constructor",
            "    MyClass(MyClass&& other) noexcept : data(other.data), size(other.size) {",
            "        std::cout << \"Move constructor\\n\";",
            "        other.data = nullptr;",
            "        other.size = 0;",
            "    }",
            "    ",
            "    // Copy assignment",
            "    MyClass& operator=(const MyClass& other) {",
            "        std::cout << \"Copy assignment\\n\";",
            "        if (this != &other) {",
            "            delete[] data;",
            "            size = other.size;",
            "            data = new int[size];",
            "            std::copy(other.data, other.data + size, data);",
            "        }",
            "        return *this;",
            "    }",
            "    ",
            "    // Move assignment",
            "    MyClass& operator=(MyClass&& other) noexcept {",
            "        std::cout << \"Move assignment\\n\";",
            "        if (this != &other) {",
            "            delete[] data;",
            "            data = other.data;",
            "            size = other.size;",
            "            other.data = nullptr;",
            "            other.size = 0;",
            "        }",
            "        return *this;",
            "    }",
            "};",
            "",
            "// Usage",
            "MyClass obj1(100);",
            "MyClass obj2 = std::move(obj1); // Move constructor",
            "MyClass obj3(200);",
            "obj3 = std::move(obj2); // Move assignment",
            "$0"
        ],
        "description": "C++11 move semantics with move constructor and assignment"
    },
    "cpp_11__perfect_forwarding": {
        "prefix": "cpp_11__perfect_forwarding",
        "body": [
            "// C++11: Perfect forwarding with universal references",
            "#include <utility>",
            "#include <iostream>",
            "",
            "// Function to be called",
            "void process(int& x) { std::cout << \"lvalue: \" << x << std::endl; }",
            "void process(int&& x) { std::cout << \"rvalue: \" << x << std::endl; }",
            "",
            "// Perfect forwarding function",
            "template<typename T>",
            "void forward_to_process(T&& arg) {",
            "    process(std::forward<T>(arg));",
            "}",
            "",
            "// Variadic perfect forwarding",
            "template<typename... Args>",
            "void emplace_wrapper(std::vector<MyClass>& vec, Args&&... args) {",
            "    vec.emplace_back(std::forward<Args>(args)...);",
            "}",
            "",
            "// Usage",
            "int x = 5;",
            "forward_to_process(x);    // calls process(int&)",
            "forward_to_process(10);   // calls process(int&&)",
            "forward_to_process(std::move(x)); // calls process(int&&)",
            "$0"
        ],
        "description": "C++11 perfect forwarding with universal references"
    },
    "cpp_11__constexpr": {
        "prefix": "cpp_11__constexpr",
        "body": [
            "// C++11: constexpr for compile-time computation",
            "",
            "// constexpr function (C++11 limited to single return)",
            "constexpr int factorial(int n) {",
            "    return n <= 1 ? 1 : n * factorial(n - 1);",
            "}",
            "",
            "// constexpr variable",
            "constexpr int fact5 = factorial(5); // Computed at compile time",
            "",
            "// constexpr constructor and member functions",
            "class Point {",
            "    int x, y;",
            "public:",
            "    constexpr Point(int x, int y) : x(x), y(y) {}",
            "    constexpr int getX() const { return x; }",
            "    constexpr int getY() const { return y; }",
            "    constexpr Point translate(int dx, int dy) const {",
            "        return Point(x + dx, y + dy);",
            "    }",
            "};",
            "",
            "constexpr Point p1(10, 20);",
            "constexpr Point p2 = p1.translate(5, 5);",
            "constexpr int px = p2.getX(); // 15 at compile-time",
            "",
            "// Use in template parameter",
            "template<int N>",
            "struct Array {",
            "    int data[N];",
            "};",
            "Array<factorial(5)> arr; // Array<120>",
            "$0"
        ],
        "description": "C++11 constexpr for compile-time computation"
    },
    "cpp_11__nullptr": {
        "prefix": "cpp_11__nullptr",
        "body": [
            "// C++11: nullptr - type-safe null pointer",
            "",
            "// Old way (C++98/03)",
            "int* p1 = NULL;  // NULL is typically defined as 0",
            "int* p2 = 0;     // Can be ambiguous",
            "",
            "// New way (C++11)",
            "int* p3 = nullptr;  // Type-safe, unambiguous",
            "",
            "// Function overloading example",
            "void f(int) { std::cout << \"f(int)\\n\"; }",
            "void f(int*) { std::cout << \"f(int*)\\n\"; }",
            "void f(std::nullptr_t) { std::cout << \"f(nullptr)\\n\"; }",
            "",
            "f(0);       // Calls f(int) - ambiguous!",
            "f(nullptr); // Calls f(std::nullptr_t) or f(int*) - clear intent",
            "",
            "// Template with nullptr",
            "template<typename T>",
            "void reset(T*& ptr) {",
            "    delete ptr;",
            "    ptr = nullptr;",
            "}",
            "$0"
        ],
        "description": "C++11 nullptr for type-safe null pointers"
    },
    "cpp_11__default_delete_functions": {
        "prefix": "cpp_11__default_delete_functions",
        "body": [
            "// C++11: Default and deleted functions",
            "",
            "class Widget {",
            "public:",
            "    // Explicitly defaulted functions",
            "    Widget() = default;                          // Default constructor",
            "    Widget(const Widget&) = default;             // Copy constructor",
            "    Widget& operator=(const Widget&) = default;  // Copy assignment",
            "    Widget(Widget&&) = default;                  // Move constructor",
            "    Widget& operator=(Widget&&) = default;       // Move assignment",
            "    ~Widget() = default;                         // Destructor",
            "",
            "    // Custom constructor",
            "    Widget(int value) : value_(value) {}",
            "",
            "private:",
            "    int value_ = 0;",
            "};",
            "",
            "class NonCopyable {",
            "public:",
            "    NonCopyable() = default;",
            "    ",
            "    // Delete copy operations",
            "    NonCopyable(const NonCopyable&) = delete;",
            "    NonCopyable& operator=(const NonCopyable&) = delete;",
            "    ",
            "    // Allow move operations",
            "    NonCopyable(NonCopyable&&) = default;",
            "    NonCopyable& operator=(NonCopyable&&) = default;",
            "};",
            "",
            "// Delete specific function overloads",
            "void processValue(int x) { /* ... */ }",
            "void processValue(double) = delete; // Prevent implicit conversion",
            "$0"
        ],
        "description": "C++11 explicitly defaulted and deleted functions"
    },
    "cpp_11__override_final": {
        "prefix": "cpp_11__override_final",
        "body": [
            "// C++11: override and final keywords",
            "",
            "class Base {",
            "public:",
            "    virtual void foo() { std::cout << \"Base::foo\\n\"; }",
            "    virtual void bar() { std::cout << \"Base::bar\\n\"; }",
            "    virtual void baz() final { std::cout << \"Base::baz (final)\\n\"; }",
            "};",
            "",
            "class Derived : public Base {",
            "public:",
            "    // override ensures we're actually overriding",
            "    void foo() override { std::cout << \"Derived::foo\\n\"; }",
            "    ",
            "    // void fooo() override; // Error! No base function to override",
            "    // void baz() override;  // Error! Cannot override final",
            "};",
            "",
            "// final class cannot be inherited",
            "class FinalClass final {",
            "    // ...",
            "};",
            "",
            "// class CannotDerive : public FinalClass {}; // Error!",
            "$0"
        ],
        "description": "C++11 override and final keywords for virtual functions"
    },
    "cpp_11__delegating_constructors": {
        "prefix": "cpp_11__delegating_constructors",
        "body": [
            "// C++11: Delegating constructors",
            "",
            "class Rectangle {",
            "private:",
            "    double width, height;",
            "    std::string name;",
            "",
            "public:",
            "    // Main constructor",
            "    Rectangle(double w, double h, const std::string& n)",
            "        : width(w), height(h), name(n) {",
            "        std::cout << \"Main constructor\\n\";",
            "    }",
            "    ",
            "    // Delegating constructors",
            "    Rectangle(double w, double h) : Rectangle(w, h, \"unnamed\") {",
            "        std::cout << \"Delegating constructor 1\\n\";",
            "    }",
            "    ",
            "    Rectangle(double size) : Rectangle(size, size) {",
            "        std::cout << \"Delegating constructor 2 (square)\\n\";",
            "    }",
            "    ",
            "    Rectangle() : Rectangle(1.0) {",
            "        std::cout << \"Default constructor\\n\";",
            "    }",
            "};",
            "",
            "// Usage",
            "Rectangle r1(3.0, 4.0, \"rect1\");",
            "Rectangle r2(3.0, 4.0);  // delegates to main constructor",
            "Rectangle r3(5.0);       // creates a square",
            "Rectangle r4;            // default 1x1 square",
            "$0"
        ],
        "description": "C++11 delegating constructors"
    },
    "cpp_11__inheriting_constructors": {
        "prefix": "cpp_11__inheriting_constructors",
        "body": [
            "// C++11: Inheriting constructors",
            "",
            "class Base {",
            "public:",
            "    Base(int x) { std::cout << \"Base(int): \" << x << std::endl; }",
            "    Base(double x, double y) { ",
            "        std::cout << \"Base(double, double): \" << x << \", \" << y << std::endl; ",
            "    }",
            "    Base(const std::string& s) { ",
            "        std::cout << \"Base(string): \" << s << std::endl; ",
            "    }",
            "};",
            "",
            "class Derived : public Base {",
            "public:",
            "    // Inherit all constructors from Base",
            "    using Base::Base;",
            "    ",
            "    // Can still add own constructors",
            "    Derived(int x, int y) : Base(x) {",
            "        std::cout << \"Derived(int, int): \" << y << std::endl;",
            "    }",
            "};",
            "",
            "// Usage",
            "Derived d1(42);              // calls Base(int)",
            "Derived d2(3.14, 2.71);      // calls Base(double, double)",
            "Derived d3(\"hello\");         // calls Base(string)",
            "Derived d4(10, 20);          // calls Derived(int, int)",
            "$0"
        ],
        "description": "C++11 inheriting constructors with using declaration"
    },
    "cpp_11__alias_templates": {
        "prefix": "cpp_11__alias_templates",
        "body": [
            "// C++11: Alias templates (template using)",
            "",
            "// Type alias (like typedef but clearer)",
            "using IntPtr = int*;",
            "using FuncPtr = void(*)(int, double);",
            "using IntVector = std::vector<int>;",
            "",
            "// Template alias",
            "template<typename T>",
            "using Vec = std::vector<T>;",
            "",
            "template<typename T>",
            "using Matrix = std::vector<std::vector<T>>;",
            "",
            "template<typename Key>",
            "using StringMap = std::unordered_map<Key, std::string>;",
            "",
            "// Partial template specialization alias",
            "template<typename T, typename Allocator = std::allocator<T>>",
            "using List = std::list<T, Allocator>;",
            "",
            "// Usage",
            "Vec<int> v = {1, 2, 3, 4, 5};",
            "Matrix<double> m = {{1.0, 2.0}, {3.0, 4.0}};",
            "StringMap<int> id_to_name = {{1, \"Alice\"}, {2, \"Bob\"}};",
            "List<std::string> names = {\"Alice\", \"Bob\", \"Charlie\"};",
            "$0"
        ],
        "description": "C++11 alias templates using 'using' keyword"
    },
    "cpp_11__raw_string_literals": {
        "prefix": "cpp_11__raw_string_literals",
        "body": [
            "// C++11: Raw string literals",
            "",
            "// Regular string with escape sequences",
            "const char* regular = \"Line 1\\nLine 2\\n\\tTabbed\\n\\\"Quoted\\\"\\\\Backslash\";",
            "",
            "// Raw string literal - no escape sequences",
            "const char* raw = R\"(Line 1",
            "Line 2",
            "\tTabbed",
            "\"Quoted\"",
            "\\Backslash)\";",
            "",
            "// Raw string with custom delimiter",
            "const char* raw_delim = R\"delimiter(",
            "This string can contain )",
            "characters without ending",
            ")delimiter\";",
            "",
            "// Useful for regex patterns",
            "std::regex pattern(R\"(\\d{3}-\\d{3}-\\d{4})\"); // Phone number pattern",
            "",
            "// Useful for JSON",
            "const char* json = R\"({",
            "    \"name\": \"John Doe\",",
            "    \"age\": 30,",
            "    \"email\": \"john@example.com\"",
            "})\";",
            "",
            "// Useful for SQL",
            "const char* sql = R\"(",
            "SELECT * FROM users",
            "WHERE age > 18",
            "ORDER BY name ASC",
            ")\";",
            "$0"
        ],
        "description": "C++11 raw string literals for multi-line and special character strings"
    },
    "cpp_11__user_defined_literals": {
        "prefix": "cpp_11__user_defined_literals",
        "body": [
            "// C++11: User-defined literals",
            "#include <chrono>",
            "",
            "// User-defined literal for kilometers",
            "constexpr long double operator\"\"_km(long double km) {",
            "    return km * 1000.0; // Convert to meters",
            "}",
            "",
            "// User-defined literal for degrees to radians",
            "constexpr long double operator\"\"_deg(long double deg) {",
            "    return deg * 3.14159265358979323846 / 180.0;",
            "}",
            "",
            "// User-defined literal for binary",
            "constexpr unsigned long long operator\"\"_bin(const char* str, size_t len) {",
            "    unsigned long long result = 0;",
            "    for (size_t i = 0; i < len; ++i) {",
            "        result = result * 2 + (str[i] - '0');",
            "    }",
            "    return result;",
            "}",
            "",
            "// C++14 standard literals",
            "using namespace std::chrono_literals;",
            "",
            "// Usage",
            "auto distance = 5.5_km;              // 5500.0 meters",
            "auto angle = 45.0_deg;               // 0.785398 radians",
            "auto binary = 101010_bin;            // 42",
            "auto duration = 100ms;               // 100 milliseconds (C++14)",
            "$0"
        ],
        "description": "C++11 user-defined literals for custom types"
    },
    "cpp_11__thread_support": {
        "prefix": "cpp_11__thread_support",
        "body": [
            "// C++11: Thread support library",
            "#include <thread>",
            "#include <mutex>",
            "#include <condition_variable>",
            "#include <atomic>",
            "#include <future>",
            "",
            "// Basic thread usage",
            "void worker(int id) {",
            "    std::cout << \"Worker \" << id << \" on thread \" ",
            "              << std::this_thread::get_id() << std::endl;",
            "    std::this_thread::sleep_for(std::chrono::seconds(1));",
            "}",
            "",
            "// Mutex for synchronization",
            "std::mutex mtx;",
            "int shared_counter = 0;",
            "",
            "void increment_counter(int n) {",
            "    for (int i = 0; i < n; ++i) {",
            "        std::lock_guard<std::mutex> lock(mtx);",
            "        ++shared_counter;",
            "    }",
            "}",
            "",
            "// Atomic operations",
            "std::atomic<int> atomic_counter{0};",
            "",
            "// Future and promise",
            "void compute_async(std::promise<int> prom) {",
            "    prom.set_value(42);",
            "}",
            "",
            "// Usage",
            "std::thread t1(worker, 1);",
            "std::thread t2(worker, 2);",
            "",
            "// Using async",
            "auto future = std::async(std::launch::async, []() { return 42; });",
            "int result = future.get();",
            "",
            "t1.join();",
            "t2.join();",
            "$0"
        ],
        "description": "C++11 thread support with mutex, atomic, and future"
    },
    "cpp_11__chrono": {
        "prefix": "cpp_11__chrono",
        "body": [
            "// C++11: Chrono library for time utilities",
            "#include <chrono>",
            "#include <iostream>",
            "",
            "// Time points and durations",
            "auto start = std::chrono::steady_clock::now();",
            "",
            "// Different duration types",
            "std::chrono::seconds sec(1);",
            "std::chrono::milliseconds ms(1000);",
            "std::chrono::microseconds us(1000000);",
            "std::chrono::nanoseconds ns(1000000000);",
            "",
            "// Duration arithmetic",
            "auto total = sec + ms; // 2000ms",
            "",
            "// Custom duration",
            "using FPS = std::chrono::duration<double, std::ratio<1, 60>>;",
            "FPS frames(1); // 1/60th of a second",
            "",
            "// Measure execution time",
            "auto begin = std::chrono::high_resolution_clock::now();",
            "// ... code to measure ...",
            "auto end = std::chrono::high_resolution_clock::now();",
            "",
            "auto elapsed = std::chrono::duration_cast<std::chrono::microseconds>(end - begin);",
            "std::cout << \"Time: \" << elapsed.count() << \" microseconds\\n\";",
            "",
            "// System clock for wall time",
            "auto now = std::chrono::system_clock::now();",
            "std::time_t now_c = std::chrono::system_clock::to_time_t(now);",
            "std::cout << \"Current time: \" << std::ctime(&now_c);",
            "$0"
        ],
        "description": "C++11 chrono library for time measurement and manipulation"
    },
    "cpp_11__random": {
        "prefix": "cpp_11__random",
        "body": [
            "// C++11: Random number generation",
            "#include <random>",
            "",
            "// Random device for seed",
            "std::random_device rd;",
            "",
            "// Mersenne Twister generator",
            "std::mt19937 gen(rd());",
            "// Or with fixed seed for reproducibility",
            "// std::mt19937 gen(12345);",
            "",
            "// Distributions",
            "std::uniform_int_distribution<> dis_int(1, 100);",
            "std::uniform_real_distribution<> dis_real(0.0, 1.0);",
            "std::normal_distribution<> dis_normal(0.0, 1.0);",
            "std::bernoulli_distribution dis_bool(0.7); // 70% true",
            "",
            "// Generate random numbers",
            "int random_int = dis_int(gen);",
            "double random_real = dis_real(gen);",
            "double random_normal = dis_normal(gen);",
            "bool random_bool = dis_bool(gen);",
            "",
            "// Shuffle container",
            "std::vector<int> v = {1, 2, 3, 4, 5};",
            "std::shuffle(v.begin(), v.end(), gen);",
            "",
            "// Random element from container",
            "std::uniform_int_distribution<size_t> dis_index(0, v.size() - 1);",
            "int random_element = v[dis_index(gen)];",
            "$0"
        ],
        "description": "C++11 random number generation with distributions"
    },
    "cpp_11__type_traits": {
        "prefix": "cpp_11__type_traits",
        "body": [
            "// C++11: Type traits for compile-time type information",
            "#include <type_traits>",
            "",
            "// Primary type categories",
            "static_assert(std::is_integral<int>::value, \"int is integral\");",
            "static_assert(std::is_floating_point<double>::value, \"double is floating point\");",
            "static_assert(std::is_pointer<int*>::value, \"int* is pointer\");",
            "static_assert(std::is_array<int[10]>::value, \"int[10] is array\");",
            "",
            "// Type properties",
            "static_assert(std::is_const<const int>::value, \"const int is const\");",
            "static_assert(std::is_volatile<volatile int>::value, \"volatile int is volatile\");",
            "static_assert(std::is_signed<int>::value, \"int is signed\");",
            "",
            "// Type relationships",
            "static_assert(std::is_same<int, int>::value, \"same types\");",
            "static_assert(std::is_base_of<Base, Derived>::value, \"inheritance check\");",
            "static_assert(std::is_convertible<int, double>::value, \"int converts to double\");",
            "",
            "// Type modifications",
            "using NonConstType = typename std::remove_const<const int>::type; // int",
            "using NonRefType = typename std::remove_reference<int&>::type;    // int",
            "using AddPointer = typename std::add_pointer<int>::type;          // int*",
            "",
            "// Enable_if for SFINAE",
            "template<typename T>",
            "typename std::enable_if<std::is_integral<T>::value, T>::type",
            "increment(T value) {",
            "    return value + 1;",
            "}",
            "$0"
        ],
        "description": "C++11 type traits for compile-time type introspection"
    },
    "cpp_11__function_bind": {
        "prefix": "cpp_11__function_bind",
        "body": [
            "// C++11: std::function and std::bind",
            "#include <functional>",
            "",
            "// std::function - type-erased function wrapper",
            "std::function<int(int, int)> operation;",
            "",
            "// Can hold free functions",
            "int add(int a, int b) { return a + b; }",
            "operation = add;",
            "",
            "// Can hold lambdas",
            "operation = [](int a, int b) { return a * b; };",
            "",
            "// Can hold member functions",
            "struct Calculator {",
            "    int multiply(int a, int b) { return a * b; }",
            "};",
            "Calculator calc;",
            "operation = std::bind(&Calculator::multiply, &calc, ",
            "                      std::placeholders::_1, std::placeholders::_2);",
            "",
            "// std::bind - partial function application",
            "auto add5 = std::bind(add, 5, std::placeholders::_1);",
            "int result = add5(3); // 8",
            "",
            "// Bind with reordered arguments",
            "auto subtract = [](int a, int b) { return a - b; };",
            "auto reverse_subtract = std::bind(subtract, ",
            "                                   std::placeholders::_2, ",
            "                                   std::placeholders::_1);",
            "",
            "// Using std::ref for reference binding",
            "int x = 10;",
            "auto increment = std::bind([](int& n) { ++n; }, std::ref(x));",
            "increment(); // x is now 11",
            "$0"
        ],
        "description": "C++11 std::function and std::bind for functional programming"
    },
    "cpp_11__regex": {
        "prefix": "cpp_11__regex",
        "body": [
            "// C++11: Regular expressions",
            "#include <regex>",
            "#include <string>",
            "",
            "// Basic regex matching",
            "std::string text = \"The year is 2024\";",
            "std::regex year_regex(R\"(\\d{4})\");",
            "",
            "if (std::regex_search(text, year_regex)) {",
            "    std::cout << \"Found a year!\\n\";",
            "}",
            "",
            "// Capture groups",
            "std::string email = \"user@example.com\";",
            "std::regex email_regex(R\"(([\\w.]+)@([\\w.]+))\");",
            "std::smatch matches;",
            "",
            "if (std::regex_match(email, matches, email_regex)) {",
            "    std::cout << \"Full match: \" << matches[0] << std::endl;",
            "    std::cout << \"Username: \" << matches[1] << std::endl;",
            "    std::cout << \"Domain: \" << matches[2] << std::endl;",
            "}",
            "",
            "// Find all matches",
            "std::string data = \"123-456-7890, 987-654-3210\";",
            "std::regex phone_regex(R\"(\\d{3}-\\d{3}-\\d{4})\");",
            "std::sregex_iterator it(data.begin(), data.end(), phone_regex);",
            "std::sregex_iterator end;",
            "",
            "while (it != end) {",
            "    std::cout << \"Phone: \" << it->str() << std::endl;",
            "    ++it;",
            "}",
            "",
            "// Replace text",
            "std::string result = std::regex_replace(data, phone_regex, \"XXX-XXX-XXXX\");",
            "$0"
        ],
        "description": "C++11 regular expressions for pattern matching"
    },
    "cpp_11__tuple": {
        "prefix": "cpp_11__tuple",
        "body": [
            "// C++11: std::tuple for heterogeneous collections",
            "#include <tuple>",
            "#include <string>",
            "",
            "// Creating tuples",
            "std::tuple<int, double, std::string> t1(42, 3.14, \"hello\");",
            "auto t2 = std::make_tuple(10, 20.5, \"world\");",
            "",
            "// Accessing elements",
            "int first = std::get<0>(t1);",
            "double second = std::get<1>(t1);",
            "std::string third = std::get<2>(t1);",
            "",
            "// Modifying elements",
            "std::get<0>(t1) = 100;",
            "",
            "// Tuple size",
            "constexpr size_t size = std::tuple_size<decltype(t1)>::value; // 3",
            "",
            "// Tuple element type",
            "using FirstType = std::tuple_element<0, decltype(t1)>::type; // int",
            "",
            "// Unpacking with tie",
            "int a;",
            "double b;",
            "std::string c;",
            "std::tie(a, b, c) = t1;",
            "",
            "// Ignore specific elements",
            "std::tie(a, std::ignore, c) = t1;",
            "",
            "// Return multiple values",
            "std::tuple<bool, int, std::string> process() {",
            "    return std::make_tuple(true, 42, \"success\");",
            "}",
            "",
            "// Tuple comparison",
            "auto t3 = std::make_tuple(1, 2.0);",
            "auto t4 = std::make_tuple(1, 3.0);",
            "bool is_less = t3 < t4; // true",
            "$0"
        ],
        "description": "C++11 std::tuple for storing heterogeneous values"
    },
    "cpp_11__array": {
        "prefix": "cpp_11__array",
        "body": [
            "// C++11: std::array - fixed-size array container",
            "#include <array>",
            "#include <algorithm>",
            "",
            "// Declaration and initialization",
            "std::array<int, 5> arr1 = {1, 2, 3, 4, 5};",
            "std::array<int, 5> arr2 = {{1, 2, 3, 4, 5}}; // double braces also work",
            "std::array<int, 5> arr3{};                    // zero-initialized",
            "",
            "// Size is part of the type",
            "constexpr size_t size = arr1.size(); // 5",
            "static_assert(size == 5, \"Size is compile-time constant\");",
            "",
            "// Element access",
            "int first = arr1[0];",
            "int second = arr1.at(1);  // bounds-checked",
            "int& front = arr1.front();",
            "int& back = arr1.back();",
            "",
            "// Iterators",
            "for (auto it = arr1.begin(); it != arr1.end(); ++it) {",
            "    std::cout << *it << \" \";",
            "}",
            "",
            "// Range-based for loop",
            "for (const auto& elem : arr1) {",
            "    std::cout << elem << \" \";",
            "}",
            "",
            "// STL algorithms work",
            "std::sort(arr1.begin(), arr1.end());",
            "std::reverse(arr1.begin(), arr1.end());",
            "",
            "// Fill and swap",
            "arr2.fill(10);",
            "arr1.swap(arr2);",
            "",
            "// Get underlying array",
            "int* data = arr1.data();",
            "$0"
        ],
        "description": "C++11 std::array fixed-size container"
    },
    "cpp_11__forward_list": {
        "prefix": "cpp_11__forward_list",
        "body": [
            "// C++11: std::forward_list - singly linked list",
            "#include <forward_list>",
            "",
            "// Declaration and initialization",
            "std::forward_list<int> flist1;",
            "std::forward_list<int> flist2 = {1, 2, 3, 4, 5};",
            "std::forward_list<int> flist3(5, 10); // 5 elements with value 10",
            "",
            "// Insert at front (no push_back!)",
            "flist1.push_front(42);",
            "flist1.emplace_front(43);",
            "",
            "// Insert after position",
            "auto it = flist2.begin();",
            "flist2.insert_after(it, 99);        // insert 99 after first element",
            "flist2.insert_after(it, 3, 88);     // insert three 88s",
            "flist2.insert_after(it, {10, 20});  // insert list",
            "",
            "// Erase operations",
            "flist2.pop_front();",
            "flist2.erase_after(flist2.begin()); // erase second element",
            "flist2.erase_after(flist2.begin(), flist2.end()); // erase range",
            "",
            "// Special operations",
            "flist2.remove(3);                    // remove all 3s",
            "flist2.remove_if([](int n) { return n > 10; });",
            "",
            "// Sorting and unique",
            "flist2.sort();",
            "flist2.sort(std::greater<int>());",
            "flist2.unique();                     // remove consecutive duplicates",
            "",
            "// Splicing",
            "std::forward_list<int> other = {100, 200, 300};",
            "flist2.splice_after(flist2.begin(), other);",
            "",
            "// No size() method - use distance if needed",
            "auto size = std::distance(flist2.begin(), flist2.end());",
            "$0"
        ],
        "description": "C++11 std::forward_list singly-linked list container"
    },
    "cpp_11__unordered_containers": {
        "prefix": "cpp_11__unordered_containers",
        "body": [
            "// C++11: Unordered associative containers (hash tables)",
            "#include <unordered_map>",
            "#include <unordered_set>",
            "",
            "// unordered_map - hash table of key-value pairs",
            "std::unordered_map<std::string, int> umap;",
            "umap[\"apple\"] = 5;",
            "umap[\"banana\"] = 3;",
            "umap.insert({\"orange\", 7});",
            "umap.emplace(\"grape\", 2);",
            "",
            "// Access and search",
            "if (umap.find(\"apple\") != umap.end()) {",
            "    std::cout << \"Found apple: \" << umap[\"apple\"] << std::endl;",
            "}",
            "",
            "// unordered_set - hash table of unique values",
            "std::unordered_set<int> uset = {1, 2, 3, 4, 5};",
            "uset.insert(6);",
            "uset.erase(3);",
            "",
            "// unordered_multimap - allows duplicate keys",
            "std::unordered_multimap<std::string, int> ummap;",
            "ummap.insert({\"key\", 1});",
            "ummap.insert({\"key\", 2}); // same key, different value",
            "",
            "// unordered_multiset - allows duplicate values",
            "std::unordered_multiset<int> umset = {1, 2, 2, 3, 3, 3};",
            "",
            "// Hash function info",
            "auto bucket_count = umap.bucket_count();",
            "auto load_factor = umap.load_factor();",
            "umap.reserve(100); // reserve buckets for 100 elements",
            "",
            "// Custom hash function",
            "struct Point { int x, y; };",
            "struct PointHash {",
            "    size_t operator()(const Point& p) const {",
            "        return std::hash<int>()(p.x) ^ (std::hash<int>()(p.y) << 1);",
            "    }",
            "};",
            "std::unordered_set<Point, PointHash> point_set;",
            "$0"
        ],
        "description": "C++11 unordered associative containers (hash-based)"
    },
    "cpp_11__emplace": {
        "prefix": "cpp_11__emplace",
        "body": [
            "// C++11: Emplace operations for in-place construction",
            "#include <vector>",
            "#include <map>",
            "#include <string>",
            "",
            "struct Person {",
            "    std::string name;",
            "    int age;",
            "    Person(const std::string& n, int a) : name(n), age(a) {",
            "        std::cout << \"Person constructed\\n\";",
            "    }",
            "    Person(const Person& other) : name(other.name), age(other.age) {",
            "        std::cout << \"Person copied\\n\";",
            "    }",
            "    Person(Person&& other) : name(std::move(other.name)), age(other.age) {",
            "        std::cout << \"Person moved\\n\";",
            "    }",
            "};",
            "",
            "// Vector emplace",
            "std::vector<Person> people;",
            "people.push_back(Person(\"Alice\", 30));  // construct + move",
            "people.emplace_back(\"Bob\", 25);         // construct in-place",
            "",
            "// Map emplace",
            "std::map<int, Person> id_to_person;",
            "id_to_person.insert(std::make_pair(1, Person(\"Charlie\", 35))); // construct + move",
            "id_to_person.emplace(2, Person(\"David\", 28));                  // construct + move",
            "id_to_person.emplace(std::piecewise_construct,",
            "                     std::forward_as_tuple(3),",
            "                     std::forward_as_tuple(\"Eve\", 22));        // truly in-place",
            "",
            "// Emplace with hint",
            "auto hint = id_to_person.begin();",
            "id_to_person.emplace_hint(hint, 4, Person(\"Frank\", 40));",
            "",
            "// Try emplace (C++17 but showing the pattern)",
            "// auto [it, inserted] = map.try_emplace(key, args...);",
            "$0"
        ],
        "description": "C++11 emplace operations for efficient in-place construction"
    },
    "cpp_11__static_assert": {
        "prefix": "cpp_11__static_assert",
        "body": [
            "// C++11: static_assert for compile-time assertions",
            "",
            "// Basic static_assert",
            "static_assert(sizeof(int) >= 4, \"int must be at least 32 bits\");",
            "static_assert(sizeof(void*) == 8, \"This code requires 64-bit pointers\");",
            "",
            "// With type traits",
            "template<typename T>",
            "class Container {",
            "    static_assert(std::is_default_constructible<T>::value,",
            "                  \"T must be default constructible\");",
            "    static_assert(!std::is_pointer<T>::value,",
            "                  \"Container cannot store raw pointers\");",
            "    // ...",
            "};",
            "",
            "// Template constraints",
            "template<int N>",
            "class FixedArray {",
            "    static_assert(N > 0, \"Array size must be positive\");",
            "    static_assert(N <= 1000000, \"Array size too large\");",
            "    int data[N];",
            "};",
            "",
            "// Checking template parameters",
            "template<typename T, typename U>",
            "void safe_copy(T& dest, const U& src) {",
            "    static_assert(sizeof(T) >= sizeof(U),",
            "                  \"Destination must be large enough\");",
            "    static_assert(std::is_trivially_copyable<T>::value &&",
            "                  std::is_trivially_copyable<U>::value,",
            "                  \"Types must be trivially copyable\");",
            "    std::memcpy(&dest, &src, sizeof(U));",
            "}",
            "",
            "// C++17 allows static_assert without message",
            "// static_assert(condition);",
            "$0"
        ],
        "description": "C++11 static_assert for compile-time assertions"
    },
    "cpp_11__alignas_alignof": {
        "prefix": "cpp_11__alignas_alignof",
        "body": [
            "// C++11: alignas and alignof for memory alignment",
            "#include <iostream>",
            "#include <memory>",
            "",
            "// alignof operator",
            "std::cout << \"Alignment of char: \" << alignof(char) << std::endl;",
            "std::cout << \"Alignment of int: \" << alignof(int) << std::endl;",
            "std::cout << \"Alignment of double: \" << alignof(double) << std::endl;",
            "",
            "// alignas specifier",
            "struct alignas(16) Vec4 {",
            "    float x, y, z, w;",
            "};",
            "",
            "// Align to cache line",
            "struct alignas(64) CacheLineAligned {",
            "    int data;",
            "    // Padding will be added to reach 64 bytes",
            "};",
            "",
            "// Align variable",
            "alignas(32) char buffer[1024];",
            "",
            "// Over-aligned allocation (C++17)",
            "// auto* aligned_mem = new(std::align_val_t{64}) char[1024];",
            "",
            "// Check alignment",
            "std::cout << \"Vec4 alignment: \" << alignof(Vec4) << std::endl;",
            "std::cout << \"Vec4 size: \" << sizeof(Vec4) << std::endl;",
            "",
            "// Alignment in templates",
            "template<typename T, size_t Alignment>",
            "class AlignedStorage {",
            "    alignas(Alignment) char data[sizeof(T)];",
            "public:",
            "    T* get() { return reinterpret_cast<T*>(data); }",
            "};",
            "$0"
        ],
        "description": "C++11 alignas and alignof for controlling memory alignment"
    },
    "cpp_11__noexcept": {
        "prefix": "cpp_11__noexcept",
        "body": [
            "// C++11: noexcept specifier and operator",
            "#include <utility>",
            "",
            "// noexcept specifier",
            "void safe_function() noexcept {",
            "    // This function promises not to throw",
            "}",
            "",
            "// Conditional noexcept",
            "template<typename T>",
            "void swap_wrapper(T& a, T& b) noexcept(noexcept(std::swap(a, b))) {",
            "    std::swap(a, b);",
            "}",
            "",
            "// noexcept operator",
            "void may_throw() { throw 42; }",
            "void no_throw() noexcept { }",
            "",
            "static_assert(!noexcept(may_throw()), \"may_throw can throw\");",
            "static_assert(noexcept(no_throw()), \"no_throw cannot throw\");",
            "",
            "// Move operations with noexcept",
            "class Widget {",
            "    std::vector<int> data;",
            "public:",
            "    // Move constructor",
            "    Widget(Widget&& other) noexcept",
            "        : data(std::move(other.data)) {}",
            "    ",
            "    // Move assignment",
            "    Widget& operator=(Widget&& other) noexcept {",
            "        data = std::move(other.data);",
            "        return *this;",
            "    }",
            "};",
            "",
            "// Destructor is implicitly noexcept",
            "class MyClass {",
            "    ~MyClass() { } // implicitly noexcept",
            "    // ~MyClass() noexcept(false) { } // can throw",
            "};",
            "$0"
        ],
        "description": "C++11 noexcept for exception specifications"
    },
    "cpp_11__explicit_conversion": {
        "prefix": "cpp_11__explicit_conversion",
        "body": [
            "// C++11: Explicit conversion operators",
            "",
            "class Rational {",
            "    int num, den;",
            "public:",
            "    Rational(int n, int d) : num(n), den(d) {}",
            "    ",
            "    // Explicit conversion to double",
            "    explicit operator double() const {",
            "        return static_cast<double>(num) / den;",
            "    }",
            "    ",
            "    // Explicit conversion to bool (special case)",
            "    explicit operator bool() const {",
            "        return num != 0;",
            "    }",
            "};",
            "",
            "// Smart pointer example",
            "template<typename T>",
            "class SmartPtr {",
            "    T* ptr;",
            "public:",
            "    explicit SmartPtr(T* p) : ptr(p) {}",
            "    ",
            "    // Explicit bool conversion for if statements",
            "    explicit operator bool() const {",
            "        return ptr != nullptr;",
            "    }",
            "    ",
            "    T* get() const { return ptr; }",
            "};",
            "",
            "// Usage",
            "Rational r(3, 4);",
            "// double d = r;              // Error! Needs explicit cast",
            "double d = static_cast<double>(r); // OK",
            "double d2 = double(r);             // OK",
            "",
            "if (r) {  // OK - explicit bool conversion allowed in conditions",
            "    std::cout << \"r is non-zero\\n\";",
            "}",
            "",
            "SmartPtr<int> sp(new int(42));",
            "if (sp) {  // OK - explicit bool conversion",
            "    std::cout << \"sp is valid\\n\";",
            "}",
            "$0"
        ],
        "description": "C++11 explicit conversion operators"
    },
    "cpp_11__sizeof_member": {
        "prefix": "cpp_11__sizeof_member",
        "body": [
            "// C++11: sizeof on class members without object",
            "",
            "struct Data {",
            "    char c;",
            "    int i;",
            "    double d;",
            "    int arr[10];",
            "    std::string str;",
            "};",
            "",
            "// C++98/03 way - needed an object",
            "// Data* dummy = nullptr;",
            "// size_t old_size = sizeof(dummy->i);",
            "",
            "// C++11 way - no object needed",
            "size_t char_size = sizeof(Data::c);      // 1",
            "size_t int_size = sizeof(Data::i);       // 4",
            "size_t double_size = sizeof(Data::d);    // 8",
            "size_t array_size = sizeof(Data::arr);   // 40",
            "size_t string_size = sizeof(Data::str);  // implementation defined",
            "",
            "// Works in templates",
            "template<typename T>",
            "void print_member_sizes() {",
            "    std::cout << \"Size of T::value: \" << sizeof(T::value) << std::endl;",
            "    std::cout << \"Size of T::data: \" << sizeof(T::data) << std::endl;",
            "}",
            "",
            "// Useful for alignment calculations",
            "template<typename T>",
            "struct AlignedStorage {",
            "    static constexpr size_t member_size = sizeof(T::data);",
            "    static constexpr size_t alignment = alignof(T::data);",
            "    alignas(alignment) char storage[member_size];",
            "};",
            "$0"
        ],
        "description": "C++11 sizeof on class members without creating objects"
    },
    "cpp_11__enum_class": {
        "prefix": "cpp_11__enum_class",
        "body": [
            "// C++11: Strongly typed enums (enum class)",
            "",
            "// Old-style enum (C++98/03)",
            "enum Color { RED, GREEN, BLUE };",
            "enum Status { OK, ERROR, PENDING };  // ERROR conflicts!",
            "",
            "// C++11 enum class - strongly typed",
            "enum class NewColor { Red, Green, Blue };",
            "enum class NewStatus { Ok, Error, Pending };  // No conflict!",
            "",
            "// Specify underlying type",
            "enum class ErrorCode : uint8_t {",
            "    None = 0,",
            "    FileNotFound = 1,",
            "    AccessDenied = 2,",
            "    Unknown = 255",
            "};",
            "",
            "// Forward declaration (requires underlying type)",
            "enum class Priority : int;",
            "// ... later ...",
            "enum class Priority : int { Low, Medium, High };",
            "",
            "// Usage",
            "NewColor color = NewColor::Red;",
            "// int val = color;                    // Error! No implicit conversion",
            "int val = static_cast<int>(color);    // OK",
            "",
            "// Comparison",
            "if (color == NewColor::Red) {         // OK",
            "    // ...",
            "}",
            "// if (color == 0) { }                // Error! Type safe",
            "",
            "// Switch statement",
            "switch (color) {",
            "    case NewColor::Red:",
            "        break;",
            "    case NewColor::Green:",
            "        break;",
            "    case NewColor::Blue:",
            "        break;",
            "}",
            "$0"
        ],
        "description": "C++11 strongly typed enums (enum class)"
    },
    "cpp_algorithm__all_of_any_of_none_of": {
        "prefix": "cpp_algorithm__all_of_any_of_none_of",
        "body": [
            "// std::all_of, std::any_of, std::none_of - Check if predicate is true for all/any/none elements",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/all_any_none_of",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> vec = {2, 4, 6, 8, 10};",
            "",
            "// all_of: Returns true if pred returns true for all elements in range [first, last)",
            "bool all_even = std::all_of(vec.begin(), vec.end(), [](int i){ return i % 2 == 0; });",
            "std::cout << \"All even: \" << all_even << std::endl; // true",
            "",
            "// any_of: Returns true if pred returns true for at least one element",
            "bool has_greater_than_5 = std::any_of(vec.begin(), vec.end(), [](int i){ return i > 5; });",
            "std::cout << \"Has element > 5: \" << has_greater_than_5 << std::endl; // true",
            "",
            "// none_of: Returns true if pred returns false for all elements",
            "bool no_negatives = std::none_of(vec.begin(), vec.end(), [](int i){ return i < 0; });",
            "std::cout << \"No negatives: \" << no_negatives << std::endl; // true",
            "$0"
        ],
        "description": "Check if a predicate is true for all, any, or none of the elements in a range. all_of returns true if the predicate returns true for all elements or if the range is empty. any_of returns true if the predicate returns true for at least one element. none_of returns true if the predicate returns false for all elements or if the range is empty. Time complexity: O(n) where n is the distance between first and last. Link: https://en.cppreference.com/w/cpp/algorithm/all_any_none_of"
    },
    "cpp_algorithm__for_each": {
        "prefix": "cpp_algorithm__for_each",
        "body": [
            "// std::for_each - Apply function to each element in range",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/for_each",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> vec = {1, 2, 3, 4, 5};",
            "",
            "// Apply function to each element",
            "std::for_each(vec.begin(), vec.end(), [](int& n){ n *= 2; });",
            "",
            "// Print each element",
            "std::for_each(vec.begin(), vec.end(), [](const int& n){ std::cout << n << \" \"; });",
            "std::cout << std::endl;",
            "",
            "// for_each with function object",
            "struct Sum {",
            "    int sum = 0;",
            "    void operator()(int n) { sum += n; }",
            "};",
            "",
            "Sum s = std::for_each(vec.begin(), vec.end(), Sum());",
            "std::cout << \"Sum: \" << s.sum << std::endl;",
            "",
            "// C++17: for_each_n - Apply function to first n elements",
            "std::for_each_n(vec.begin(), 3, [](int& n){ n += 10; });",
            "$0"
        ],
        "description": "Applies the given function object to each element in the range [first, last). The function is applied in order from first to last. If the function object has a return value, it is ignored. for_each returns the function object after it has been applied to all elements. Time complexity: O(n) applications of the function. Link: https://en.cppreference.com/w/cpp/algorithm/for_each"
    },
    "cpp_algorithm__count_count_if": {
        "prefix": "cpp_algorithm__count_count_if",
        "body": [
            "// std::count, std::count_if - Count elements satisfying criteria",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/count",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> vec = {1, 2, 3, 2, 5, 2, 6, 2};",
            "",
            "// count: Count occurrences of a specific value",
            "auto count_2 = std::count(vec.begin(), vec.end(), 2);",
            "std::cout << \"Count of 2: \" << count_2 << std::endl; // 4",
            "",
            "// count_if: Count elements satisfying a predicate",
            "auto count_even = std::count_if(vec.begin(), vec.end(), ",
            "                                [](int i){ return i % 2 == 0; });",
            "std::cout << \"Count of even numbers: \" << count_even << std::endl; // 5",
            "",
            "// Count elements in a range",
            "auto count_range = std::count_if(vec.begin(), vec.end(), ",
            "                                 [](int i){ return i >= 3 && i <= 5; });",
            "std::cout << \"Count in range [3,5]: \" << count_range << std::endl; // 3",
            "$0"
        ],
        "description": "Returns the number of elements in the range [first, last) that compare equal to value (count) or satisfy a predicate (count_if). count uses operator== to compare elements with the value. count_if applies the predicate to each element and counts those for which it returns true. Time complexity: O(n) comparisons/applications of the predicate. Link: https://en.cppreference.com/w/cpp/algorithm/count"
    },
    "cpp_algorithm__find_find_if_find_if_not": {
        "prefix": "cpp_algorithm__find_find_if_find_if_not",
        "body": [
            "// std::find, std::find_if, std::find_if_not - Find elements in range",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/find",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> vec = {1, 3, 5, 7, 9, 11};",
            "",
            "// find: Find first occurrence of value",
            "auto it1 = std::find(vec.begin(), vec.end(), 5);",
            "if (it1 != vec.end()) {",
            "    std::cout << \"Found 5 at position: \" << std::distance(vec.begin(), it1) << std::endl;",
            "}",
            "",
            "// find_if: Find first element satisfying predicate",
            "auto it2 = std::find_if(vec.begin(), vec.end(), [](int i){ return i > 6; });",
            "if (it2 != vec.end()) {",
            "    std::cout << \"First element > 6: \" << *it2 << std::endl; // 7",
            "}",
            "",
            "// find_if_not: Find first element NOT satisfying predicate (C++11)",
            "auto it3 = std::find_if_not(vec.begin(), vec.end(), [](int i){ return i % 2 == 1; });",
            "if (it3 == vec.end()) {",
            "    std::cout << \"All elements are odd\\n\";",
            "}",
            "",
            "// Find with custom comparison",
            "struct Person { std::string name; int age; };",
            "std::vector<Person> people = {{\"Alice\", 30}, {\"Bob\", 25}, {\"Carol\", 35}};",
            "auto person = std::find_if(people.begin(), people.end(), ",
            "                          [](const Person& p){ return p.age > 30; });",
            "$0"
        ],
        "description": "Searches for elements in a range. find searches for the first element equal to value. find_if searches for the first element for which predicate returns true. find_if_not searches for the first element for which predicate returns false. Returns an iterator to the first element found, or last if no such element is found. Time complexity: O(n) comparisons. Link: https://en.cppreference.com/w/cpp/algorithm/find"
    },
    "cpp_algorithm__find_end": {
        "prefix": "cpp_algorithm__find_end",
        "body": [
            "// std::find_end - Find last occurrence of a subsequence",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/find_end",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> haystack = {1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4};",
            "std::vector<int> needle = {1, 2, 3};",
            "",
            "// Find last occurrence of subsequence",
            "auto it = std::find_end(haystack.begin(), haystack.end(),",
            "                       needle.begin(), needle.end());",
            "",
            "if (it != haystack.end()) {",
            "    std::cout << \"Last occurrence at position: \" ",
            "              << std::distance(haystack.begin(), it) << std::endl; // 8",
            "}",
            "",
            "// With custom predicate",
            "auto it2 = std::find_end(haystack.begin(), haystack.end(),",
            "                        needle.begin(), needle.end(),",
            "                        [](int a, int b){ return a == b; });",
            "$0"
        ],
        "description": "Searches for the last occurrence of the sequence [s_first, s_last) within the range [first, last). Returns an iterator to the beginning of the last occurrence of the sequence in the range, or last if no such sequence is found. The elements are compared using operator== or the given binary predicate. Time complexity: O(S*(N-S+1)) where S is the distance between s_first and s_last. Link: https://en.cppreference.com/w/cpp/algorithm/find_end"
    },
    "cpp_algorithm__find_first_of": {
        "prefix": "cpp_algorithm__find_first_of",
        "body": [
            "// std::find_first_of - Find first element from a set",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/find_first_of",
            "#include <algorithm>",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "",
            "std::string str = \"Hello, World!\";",
            "std::string vowels = \"aeiouAEIOU\";",
            "",
            "// Find first vowel in string",
            "auto it = std::find_first_of(str.begin(), str.end(),",
            "                            vowels.begin(), vowels.end());",
            "",
            "if (it != str.end()) {",
            "    std::cout << \"First vowel: '\" << *it << \"' at position \" ",
            "              << std::distance(str.begin(), it) << std::endl; // 'e' at position 1",
            "}",
            "",
            "// With integers",
            "std::vector<int> vec = {0, 2, 3, 25, 5};",
            "std::vector<int> targets = {3, 19, 10, 2};",
            "",
            "auto it2 = std::find_first_of(vec.begin(), vec.end(),",
            "                             targets.begin(), targets.end());",
            "if (it2 != vec.end()) {",
            "    std::cout << \"First match: \" << *it2 << std::endl; // 2",
            "}",
            "$0"
        ],
        "description": "Searches the range [first, last) for any of the elements in the range [s_first, s_last). Returns an iterator to the first element in the range that is equal to an element from the sequence, or last if no such element is found. Elements are compared using operator== or the given binary predicate. Time complexity: O(N*S) where N is the distance between first and last, and S is the distance between s_first and s_last. Link: https://en.cppreference.com/w/cpp/algorithm/find_first_of"
    },
    "cpp_algorithm__adjacent_find": {
        "prefix": "cpp_algorithm__adjacent_find",
        "body": [
            "// std::adjacent_find - Find first pair of adjacent equal elements",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/adjacent_find",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> vec = {1, 2, 3, 3, 4, 5, 5, 5, 6};",
            "",
            "// Find first pair of equal adjacent elements",
            "auto it = std::adjacent_find(vec.begin(), vec.end());",
            "if (it != vec.end()) {",
            "    std::cout << \"First adjacent pair: \" << *it << \" at position \"",
            "              << std::distance(vec.begin(), it) << std::endl; // 3 at position 2",
            "}",
            "",
            "// With custom predicate - find adjacent elements where second > first + 1",
            "auto it2 = std::adjacent_find(vec.begin(), vec.end(),",
            "                             [](int a, int b){ return b > a + 1; });",
            "if (it2 != vec.end()) {",
            "    std::cout << \"Jump from \" << *it2 << \" to \" << *(it2 + 1) << std::endl;",
            "}",
            "",
            "// Find adjacent elements with specific difference",
            "auto it3 = std::adjacent_find(vec.begin(), vec.end(),",
            "                             [](int a, int b){ return std::abs(a - b) > 2; });",
            "$0"
        ],
        "description": "Searches the range [first, last) for two consecutive identical elements. Returns an iterator to the first of the first pair of identical elements, or last if no such pair is found. Can use a custom binary predicate to determine if elements should be treated as equal. Time complexity: O(n) applications of the predicate. Link: https://en.cppreference.com/w/cpp/algorithm/adjacent_find"
    },
    "cpp_algorithm__search": {
        "prefix": "cpp_algorithm__search",
        "body": [
            "// std::search - Search for a subsequence",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/search",
            "#include <algorithm>",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "",
            "std::string text = \"The quick brown fox jumps over the lazy dog\";",
            "std::string pattern = \"fox\";",
            "",
            "// Search for pattern in text",
            "auto it = std::search(text.begin(), text.end(),",
            "                     pattern.begin(), pattern.end());",
            "",
            "if (it != text.end()) {",
            "    std::cout << \"Found at position: \" << std::distance(text.begin(), it) << std::endl;",
            "}",
            "",
            "// Search with custom predicate",
            "std::vector<int> vec1 = {1, 2, 3, 4, 5, 6, 7, 8, 9};",
            "std::vector<int> vec2 = {4, 5, 6};",
            "",
            "auto it2 = std::search(vec1.begin(), vec1.end(),",
            "                      vec2.begin(), vec2.end());",
            "",
            "// C++17: Search with searcher",
            "auto it3 = std::search(text.begin(), text.end(),",
            "                      std::boyer_moore_searcher(pattern.begin(), pattern.end()));",
            "$0"
        ],
        "description": "Searches for the first occurrence of the sequence [s_first, s_last) in the range [first, last). Returns an iterator to the beginning of the first occurrence of the sequence in the range, or last if no such sequence is found. Can use custom predicates or C++17 searchers for optimized searching. Time complexity: O((N-S+1)*S) for naive search. Link: https://en.cppreference.com/w/cpp/algorithm/search"
    },
    "cpp_algorithm__search_n": {
        "prefix": "cpp_algorithm__search_n",
        "body": [
            "// std::search_n - Search for n consecutive copies of value",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/search_n",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> vec = {1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5};",
            "",
            "// Search for 3 consecutive 3s",
            "auto it = std::search_n(vec.begin(), vec.end(), 3, 3);",
            "",
            "if (it != vec.end()) {",
            "    std::cout << \"Found 3 consecutive 3s at position: \"",
            "              << std::distance(vec.begin(), it) << std::endl; // 3",
            "}",
            "",
            "// Search with custom predicate - find 2 consecutive elements > 3",
            "auto it2 = std::search_n(vec.begin(), vec.end(), 2, 3,",
            "                        [](int elem, int value){ return elem > value; });",
            "",
            "if (it2 != vec.end()) {",
            "    std::cout << \"Found at position: \" << std::distance(vec.begin(), it2) << std::endl;",
            "}",
            "$0"
        ],
        "description": "Searches the range [first, last) for the first sequence of count identical elements, each equal to value. Can use a custom binary predicate. Returns an iterator to the beginning of the found sequence, or last if no such sequence is found. Time complexity: O(n) where n is the distance between first and last. Link: https://en.cppreference.com/w/cpp/algorithm/search_n"
    },
    "cpp_algorithm__copy_copy_if_copy_n": {
        "prefix": "cpp_algorithm__copy_copy_if_copy_n",
        "body": [
            "// std::copy, std::copy_if, std::copy_n - Copy elements to another range",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/copy",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "#include <iterator>",
            "",
            "std::vector<int> source = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};",
            "std::vector<int> dest1(source.size());",
            "std::vector<int> dest2;",
            "std::vector<int> dest3(5);",
            "",
            "// copy: Copy all elements",
            "std::copy(source.begin(), source.end(), dest1.begin());",
            "",
            "// copy_if: Copy elements that satisfy condition",
            "std::copy_if(source.begin(), source.end(), ",
            "             std::back_inserter(dest2),",
            "             [](int i){ return i % 2 == 0; });",
            "// dest2 now contains: 2, 4, 6, 8, 10",
            "",
            "// copy_n: Copy first n elements",
            "std::copy_n(source.begin(), 5, dest3.begin());",
            "// dest3 now contains: 1, 2, 3, 4, 5",
            "",
            "// Copy to output stream",
            "std::copy(source.begin(), source.end(), ",
            "          std::ostream_iterator<int>(std::cout, \" \"));",
            "$0"
        ],
        "description": "Copies elements from one range to another. copy copies all elements, copy_if copies only elements satisfying a predicate, copy_n copies exactly n elements. The destination range must have enough space. Returns an iterator to the end of the destination range. Time complexity: O(n) for all variants. Link: https://en.cppreference.com/w/cpp/algorithm/copy"
    },
    "cpp_algorithm__copy_backward": {
        "prefix": "cpp_algorithm__copy_backward",
        "body": [
            "// std::copy_backward - Copy elements backwards",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/copy_backward",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};",
            "",
            "// Shift elements to the right by 2 positions",
            "// Must copy backwards to avoid overwriting",
            "std::copy_backward(vec.begin(), vec.begin() + 8, vec.begin() + 10);",
            "",
            "// Now vec contains: 1, 2, 1, 2, 3, 4, 5, 6, 7, 8",
            "",
            "// Safe overlapping copy example",
            "std::vector<int> data = {1, 2, 3, 4, 5};",
            "// Copy [0,3) to [2,5) - overlapping ranges",
            "std::copy_backward(data.begin(), data.begin() + 3, data.begin() + 5);",
            "// Result: 1, 2, 1, 2, 3",
            "",
            "for (int n : data) {",
            "    std::cout << n << \" \";",
            "}",
            "$0"
        ],
        "description": "Copies elements from the range [first, last) to another range ending at d_last. The elements are copied in reverse order (the last element is copied first), but their relative order is preserved. Useful for shifting elements when ranges overlap. Returns an iterator to the beginning of the destination range. Time complexity: O(n). Link: https://en.cppreference.com/w/cpp/algorithm/copy_backward"
    },
    "cpp_algorithm__move_move_backward": {
        "prefix": "cpp_algorithm__move_move_backward",
        "body": [
            "// std::move (algorithm), std::move_backward - Move elements",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/move",
            "#include <algorithm>",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "",
            "// Move with std::move (algorithm version)",
            "std::vector<std::string> source = {\"Hello\", \"World\", \"C++\", \"Algorithm\"};",
            "std::vector<std::string> dest(source.size());",
            "",
            "// Move all elements",
            "std::move(source.begin(), source.end(), dest.begin());",
            "// source strings are now in valid but unspecified state",
            "",
            "// Move backward example",
            "std::vector<std::string> vec = {\"A\", \"B\", \"C\", \"D\", \"E\"};",
            "// Shift elements to the right",
            "std::move_backward(vec.begin(), vec.begin() + 3, vec.begin() + 5);",
            "// Result: \"A\", \"B\", \"A\", \"B\", \"C\"",
            "",
            "// Practical example: inserting element in middle",
            "std::vector<std::string> data = {\"one\", \"two\", \"four\", \"five\"};",
            "data.resize(data.size() + 1);",
            "std::move_backward(data.begin() + 2, data.end() - 1, data.end());",
            "data[2] = \"three\";",
            "// Result: \"one\", \"two\", \"three\", \"four\", \"five\"",
            "$0"
        ],
        "description": "Moves elements from one range to another. std::move transfers ownership of elements using move semantics. move_backward moves elements in reverse order but preserves their relative order, useful for shifting elements when ranges overlap. After moving, the source elements are left in a valid but unspecified state. Time complexity: O(n). Link: https://en.cppreference.com/w/cpp/algorithm/move"
    },
    "cpp_algorithm__fill_fill_n": {
        "prefix": "cpp_algorithm__fill_fill_n",
        "body": [
            "// std::fill, std::fill_n - Fill range with value",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/fill",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> vec(10);",
            "",
            "// fill: Fill entire range with value",
            "std::fill(vec.begin(), vec.end(), 42);",
            "// vec now contains: 42, 42, 42, 42, 42, 42, 42, 42, 42, 42",
            "",
            "// Fill subrange",
            "std::fill(vec.begin() + 2, vec.begin() + 5, 99);",
            "// vec now contains: 42, 42, 99, 99, 99, 42, 42, 42, 42, 42",
            "",
            "// fill_n: Fill n elements starting from iterator",
            "std::fill_n(vec.begin(), 3, 0);",
            "// vec now contains: 0, 0, 0, 99, 99, 42, 42, 42, 42, 42",
            "",
            "// fill_n returns iterator to element past the last filled",
            "auto it = std::fill_n(vec.begin() + 5, 2, 77);",
            "std::cout << \"Next element after filled: \" << *it << std::endl; // 42",
            "",
            "// Fill with custom objects",
            "struct Point { int x, y; };",
            "std::vector<Point> points(5);",
            "std::fill(points.begin(), points.end(), Point{10, 20});",
            "$0"
        ],
        "description": "Assigns the given value to elements in a range. fill assigns to all elements in [first, last). fill_n assigns to the first n elements starting at first. fill returns void, while fill_n returns an iterator one past the last element assigned. Time complexity: O(n) assignments. Link: https://en.cppreference.com/w/cpp/algorithm/fill"
    },
    "cpp_algorithm__transform": {
        "prefix": "cpp_algorithm__transform",
        "body": [
            "// std::transform - Apply operation to elements and store results",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/transform",
            "#include <algorithm>",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <cctype>",
            "",
            "std::vector<int> vec1 = {1, 2, 3, 4, 5};",
            "std::vector<int> vec2 = {10, 20, 30, 40, 50};",
            "std::vector<int> result(5);",
            "",
            "// Unary operation - square each element",
            "std::transform(vec1.begin(), vec1.end(), result.begin(),",
            "               [](int x) { return x * x; });",
            "// result: 1, 4, 9, 16, 25",
            "",
            "// Binary operation - add corresponding elements",
            "std::transform(vec1.begin(), vec1.end(), vec2.begin(), result.begin(),",
            "               [](int a, int b) { return a + b; });",
            "// result: 11, 22, 33, 44, 55",
            "",
            "// Transform in-place",
            "std::transform(vec1.begin(), vec1.end(), vec1.begin(),",
            "               [](int x) { return x * 2; });",
            "// vec1: 2, 4, 6, 8, 10",
            "",
            "// String transformation example",
            "std::string str = \"hello world\";",
            "std::transform(str.begin(), str.end(), str.begin(), ::toupper);",
            "// str: \"HELLO WORLD\"",
            "$0"
        ],
        "description": "Applies the given function to a range and stores the result in another range. The unary version applies a unary operation to each element. The binary version applies a binary operation to pairs of elements from two ranges. Returns an iterator to the element past the last element written. Time complexity: O(n) applications of the operation. Link: https://en.cppreference.com/w/cpp/algorithm/transform"
    },
    "cpp_algorithm__generate_generate_n": {
        "prefix": "cpp_algorithm__generate_generate_n",
        "body": [
            "// std::generate, std::generate_n - Fill range with generated values",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/generate",
            "#include <algorithm>",
            "#include <vector>",
            "#include <random>",
            "#include <iostream>",
            "",
            "// Random number generator",
            "std::random_device rd;",
            "std::mt19937 gen(rd());",
            "std::uniform_int_distribution<> dis(1, 100);",
            "",
            "std::vector<int> vec1(10);",
            "std::vector<int> vec2(10);",
            "",
            "// generate: Fill entire range with generated values",
            "std::generate(vec1.begin(), vec1.end(), [&]() { return dis(gen); });",
            "",
            "// generate_n: Fill n elements with generated values",
            "std::generate_n(vec2.begin(), 5, [&]() { return dis(gen); });",
            "",
            "// Generate sequence",
            "int counter = 0;",
            "std::generate(vec1.begin(), vec1.end(), [&counter]() { return counter++; });",
            "// vec1: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9",
            "",
            "// Generate Fibonacci sequence",
            "int a = 0, b = 1;",
            "std::generate_n(vec2.begin(), 10, [&]() {",
            "    int result = a;",
            "    int temp = a + b;",
            "    a = b;",
            "    b = temp;",
            "    return result;",
            "});",
            "// vec2: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34",
            "$0"
        ],
        "description": "Assigns the result of successive calls to a generator function to elements in a range. generate assigns to all elements in [first, last). generate_n assigns to the first n elements. The generator is called once for each element. Time complexity: O(n) invocations of the generator. Link: https://en.cppreference.com/w/cpp/algorithm/generate"
    },
    "cpp_algorithm__remove_remove_if": {
        "prefix": "cpp_algorithm__remove_remove_if",
        "body": [
            "// std::remove, std::remove_if - Remove elements from range",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/remove",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> vec = {1, 2, 3, 2, 5, 2, 6, 2};",
            "",
            "// remove: Remove all occurrences of value",
            "// Note: doesn't actually erase elements, just moves them to the end",
            "auto new_end = std::remove(vec.begin(), vec.end(), 2);",
            "vec.erase(new_end, vec.end()); // Actually erase the removed elements",
            "// vec now contains: 1, 3, 5, 6",
            "",
            "// remove_if: Remove elements satisfying predicate",
            "std::vector<int> vec2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};",
            "auto new_end2 = std::remove_if(vec2.begin(), vec2.end(),",
            "                               [](int x) { return x % 2 == 0; });",
            "vec2.erase(new_end2, vec2.end());",
            "// vec2 now contains: 1, 3, 5, 7, 9",
            "",
            "// Remove-erase idiom in one line",
            "vec.erase(std::remove(vec.begin(), vec.end(), 3), vec.end());",
            "",
            "// Remove with custom objects",
            "struct Person { std::string name; int age; };",
            "std::vector<Person> people = {{\"Alice\", 30}, {\"Bob\", 25}, {\"Carol\", 35}};",
            "people.erase(",
            "    std::remove_if(people.begin(), people.end(),",
            "                   [](const Person& p) { return p.age < 30; }),",
            "    people.end());",
            "$0"
        ],
        "description": "Removes elements equal to value (remove) or satisfying a predicate (remove_if) by moving elements to preserve relative order of remaining elements. Returns an iterator to the new end of the range. Elements between the new end and the old end have unspecified values. Typically used with container's erase method (remove-erase idiom). Time complexity: O(n) comparisons. Link: https://en.cppreference.com/w/cpp/algorithm/remove"
    },
    "cpp_algorithm__remove_copy_remove_copy_if": {
        "prefix": "cpp_algorithm__remove_copy_remove_copy_if",
        "body": [
            "// std::remove_copy, std::remove_copy_if - Copy elements except those to remove",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/remove_copy",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "#include <iterator>",
            "",
            "std::vector<int> source = {1, 2, 3, 2, 5, 2, 6, 2};",
            "std::vector<int> dest;",
            "",
            "// remove_copy: Copy all except specified value",
            "std::remove_copy(source.begin(), source.end(),",
            "                 std::back_inserter(dest), 2);",
            "// dest contains: 1, 3, 5, 6",
            "",
            "// remove_copy_if: Copy all except those satisfying predicate",
            "std::vector<int> source2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};",
            "std::vector<int> dest2;",
            "",
            "std::remove_copy_if(source2.begin(), source2.end(),",
            "                    std::back_inserter(dest2),",
            "                    [](int x) { return x % 2 == 0; });",
            "// dest2 contains: 1, 3, 5, 7, 9",
            "",
            "// Copy to output stream, removing vowels",
            "std::string text = \"Hello World\";",
            "std::remove_copy_if(text.begin(), text.end(),",
            "                    std::ostream_iterator<char>(std::cout),",
            "                    [](char c) {",
            "                        return std::string(\"aeiouAEIOU\").find(c) != std::string::npos;",
            "                    });",
            "// Output: \"Hll Wrld\"",
            "$0"
        ],
        "description": "Copies elements from the source range to the destination range, omitting elements equal to value (remove_copy) or satisfying a predicate (remove_copy_if). The relative order of elements that are not removed is preserved. Returns an iterator to the element past the last element copied. Time complexity: O(n) comparisons. Link: https://en.cppreference.com/w/cpp/algorithm/remove_copy"
    },
    "cpp_algorithm__replace_replace_if": {
        "prefix": "cpp_algorithm__replace_replace_if",
        "body": [
            "// std::replace, std::replace_if - Replace elements in range",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/replace",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> vec = {1, 2, 3, 2, 5, 2, 6, 2};",
            "",
            "// replace: Replace all occurrences of old_value with new_value",
            "std::replace(vec.begin(), vec.end(), 2, 99);",
            "// vec now contains: 1, 99, 3, 99, 5, 99, 6, 99",
            "",
            "// replace_if: Replace elements satisfying predicate",
            "std::vector<int> vec2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};",
            "std::replace_if(vec2.begin(), vec2.end(),",
            "                [](int x) { return x > 5; }, 0);",
            "// vec2 now contains: 1, 2, 3, 4, 5, 0, 0, 0, 0, 0",
            "",
            "// Replace negative values with zero",
            "std::vector<int> data = {5, -3, 2, -1, 8, -4, 7};",
            "std::replace_if(data.begin(), data.end(),",
            "                [](int x) { return x < 0; }, 0);",
            "// data now contains: 5, 0, 2, 0, 8, 0, 7",
            "",
            "// Replace with calculation",
            "std::replace_if(vec2.begin(), vec2.end(),",
            "                [](int x) { return x % 2 == 0; }, -1);",
            "$0"
        ],
        "description": "Replaces all elements equal to old_value with new_value (replace) or all elements satisfying a predicate with new_value (replace_if). Modifies elements in-place. Time complexity: O(n) comparisons. Link: https://en.cppreference.com/w/cpp/algorithm/replace"
    },
    "cpp_algorithm__replace_copy_replace_copy_if": {
        "prefix": "cpp_algorithm__replace_copy_replace_copy_if",
        "body": [
            "// std::replace_copy, std::replace_copy_if - Copy with replacements",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/replace_copy",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "#include <iterator>",
            "",
            "std::vector<int> source = {1, 2, 3, 2, 5, 2, 6, 2};",
            "std::vector<int> dest(source.size());",
            "",
            "// replace_copy: Copy with specific value replaced",
            "std::replace_copy(source.begin(), source.end(),",
            "                  dest.begin(), 2, 99);",
            "// dest contains: 1, 99, 3, 99, 5, 99, 6, 99",
            "",
            "// replace_copy_if: Copy with conditional replacement",
            "std::vector<int> source2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};",
            "std::vector<int> dest2;",
            "",
            "std::replace_copy_if(source2.begin(), source2.end(),",
            "                     std::back_inserter(dest2),",
            "                     [](int x) { return x % 2 == 0; }, 0);",
            "// dest2 contains: 1, 0, 3, 0, 5, 0, 7, 0, 9, 0",
            "",
            "// Censor bad words example",
            "std::vector<std::string> words = {\"good\", \"bad\", \"nice\", \"ugly\", \"great\"};",
            "std::vector<std::string> censored;",
            "",
            "std::replace_copy_if(words.begin(), words.end(),",
            "                     std::back_inserter(censored),",
            "                     [](const std::string& s) {",
            "                         return s == \"bad\" || s == \"ugly\";",
            "                     }, \"****\");",
            "$0"
        ],
        "description": "Copies elements from source range to destination range, replacing elements equal to old_value with new_value (replace_copy) or elements satisfying a predicate with new_value (replace_copy_if). Source range is not modified. Returns an iterator to the element past the last element copied. Time complexity: O(n) comparisons. Link: https://en.cppreference.com/w/cpp/algorithm/replace_copy"
    },
    "cpp_algorithm__swap_swap_ranges_iter_swap": {
        "prefix": "cpp_algorithm__swap_swap_ranges_iter_swap",
        "body": [
            "// std::swap, std::swap_ranges, std::iter_swap - Swap elements",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/swap",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "// std::swap - swap two objects",
            "int a = 5, b = 10;",
            "std::swap(a, b);",
            "// Now a = 10, b = 5",
            "",
            "// std::swap_ranges - swap two ranges",
            "std::vector<int> vec1 = {1, 2, 3, 4, 5};",
            "std::vector<int> vec2 = {6, 7, 8, 9, 10};",
            "",
            "std::swap_ranges(vec1.begin(), vec1.begin() + 3, vec2.begin());",
            "// vec1: 6, 7, 8, 4, 5",
            "// vec2: 1, 2, 3, 9, 10",
            "",
            "// std::iter_swap - swap values pointed to by two iterators",
            "auto it1 = vec1.begin() + 1;",
            "auto it2 = vec1.begin() + 3;",
            "std::iter_swap(it1, it2);",
            "// Swaps vec1[1] and vec1[3]",
            "",
            "// Practical example: reverse array manually",
            "std::vector<int> arr = {1, 2, 3, 4, 5};",
            "for (size_t i = 0; i < arr.size() / 2; ++i) {",
            "    std::iter_swap(arr.begin() + i, arr.end() - 1 - i);",
            "}",
            "// arr: 5, 4, 3, 2, 1",
            "$0"
        ],
        "description": "Swaps values of objects or ranges. std::swap exchanges values of two objects. swap_ranges exchanges elements between two ranges. iter_swap exchanges values pointed to by two iterators. All operations use move semantics when possible. Time complexity: O(1) for swap and iter_swap, O(n) for swap_ranges. Link: https://en.cppreference.com/w/cpp/algorithm/swap"
    },
    "cpp_algorithm__reverse_reverse_copy": {
        "prefix": "cpp_algorithm__reverse_reverse_copy",
        "body": [
            "// std::reverse, std::reverse_copy - Reverse order of elements",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/reverse",
            "#include <algorithm>",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "",
            "// reverse: Reverse in-place",
            "std::vector<int> vec = {1, 2, 3, 4, 5};",
            "std::reverse(vec.begin(), vec.end());",
            "// vec: 5, 4, 3, 2, 1",
            "",
            "// Reverse substring",
            "std::string str = \"Hello World\";",
            "std::reverse(str.begin(), str.begin() + 5);",
            "// str: \"olleH World\"",
            "",
            "// reverse_copy: Copy in reversed order",
            "std::vector<int> source = {1, 2, 3, 4, 5};",
            "std::vector<int> dest(source.size());",
            "",
            "std::reverse_copy(source.begin(), source.end(), dest.begin());",
            "// dest: 5, 4, 3, 2, 1",
            "// source unchanged",
            "",
            "// Check if palindrome",
            "std::string text = \"racecar\";",
            "std::string reversed;",
            "reversed.reserve(text.size());",
            "std::reverse_copy(text.begin(), text.end(), std::back_inserter(reversed));",
            "bool is_palindrome = (text == reversed);",
            "$0"
        ],
        "description": "Reverses the order of elements in a range. reverse modifies the range in-place by swapping elements. reverse_copy copies elements to a destination range in reverse order without modifying the source. Time complexity: O(n/2) swaps for reverse, O(n) assignments for reverse_copy. Link: https://en.cppreference.com/w/cpp/algorithm/reverse"
    },
    "cpp_algorithm__rotate_rotate_copy": {
        "prefix": "cpp_algorithm__rotate_rotate_copy",
        "body": [
            "// std::rotate, std::rotate_copy - Rotate elements in range",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/rotate",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "// rotate: Rotate left so that n_first becomes the first element",
            "std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8};",
            "",
            "// Rotate left by 3 positions",
            "std::rotate(vec.begin(), vec.begin() + 3, vec.end());",
            "// vec: 4, 5, 6, 7, 8, 1, 2, 3",
            "",
            "// Rotate right by 2 positions (rotate left by size-2)",
            "std::vector<int> vec2 = {1, 2, 3, 4, 5};",
            "std::rotate(vec2.begin(), vec2.end() - 2, vec2.end());",
            "// vec2: 4, 5, 1, 2, 3",
            "",
            "// rotate_copy: Copy with rotation",
            "std::vector<int> source = {1, 2, 3, 4, 5};",
            "std::vector<int> dest(source.size());",
            "",
            "std::rotate_copy(source.begin(), source.begin() + 2, source.end(), dest.begin());",
            "// dest: 3, 4, 5, 1, 2",
            "",
            "// Practical example: move element to front",
            "auto it = std::find(vec.begin(), vec.end(), 6);",
            "if (it != vec.end()) {",
            "    std::rotate(vec.begin(), it, it + 1);",
            "}",
            "// Moves 6 to the front",
            "$0"
        ],
        "description": "Rotates elements in a range such that the element at n_first becomes the new first element. rotate performs left rotation in-place. rotate_copy copies elements to a destination range with rotation. Returns iterator to the new position of the first element. Time complexity: O(n) for both algorithms. Link: https://en.cppreference.com/w/cpp/algorithm/rotate"
    },
    "cpp_algorithm__unique_unique_copy": {
        "prefix": "cpp_algorithm__unique_unique_copy",
        "body": [
            "// std::unique, std::unique_copy - Remove consecutive duplicates",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/unique",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "// unique: Remove consecutive duplicates in-place",
            "std::vector<int> vec = {1, 1, 2, 2, 2, 3, 3, 4, 5, 5};",
            "",
            "auto new_end = std::unique(vec.begin(), vec.end());",
            "vec.erase(new_end, vec.end());",
            "// vec: 1, 2, 3, 4, 5",
            "",
            "// unique with custom predicate",
            "std::vector<int> vec2 = {1, 3, 3, 7, 7, 8, 10, 10};",
            "auto new_end2 = std::unique(vec2.begin(), vec2.end(),",
            "                           [](int a, int b) { return b == a + 1; });",
            "vec2.erase(new_end2, vec2.end());",
            "",
            "// unique_copy: Copy without consecutive duplicates",
            "std::vector<int> source = {1, 1, 2, 2, 2, 3, 3, 4, 5, 5};",
            "std::vector<int> dest;",
            "",
            "std::unique_copy(source.begin(), source.end(), std::back_inserter(dest));",
            "// dest: 1, 2, 3, 4, 5",
            "",
            "// Remove all duplicates (not just consecutive)",
            "std::vector<int> data = {3, 1, 4, 1, 5, 9, 2, 6, 5};",
            "std::sort(data.begin(), data.end()); // Sort first",
            "data.erase(std::unique(data.begin(), data.end()), data.end());",
            "// data: 1, 2, 3, 4, 5, 6, 9",
            "$0"
        ],
        "description": "Eliminates consecutive duplicate elements from a range. unique removes consecutive duplicates in-place and returns iterator to new end. unique_copy copies elements to destination omitting consecutive duplicates. Elements are compared using operator== or given predicate. Often used after sort to remove all duplicates. Time complexity: O(n) comparisons. Link: https://en.cppreference.com/w/cpp/algorithm/unique"
    },
    "cpp_algorithm__partition_stable_partition": {
        "prefix": "cpp_algorithm__partition_stable_partition",
        "body": [
            "// std::partition, std::stable_partition - Partition range by predicate",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/partition",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "// partition: Reorder so elements satisfying predicate come first",
            "std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};",
            "",
            "auto pivot = std::partition(vec.begin(), vec.end(),",
            "                           [](int x) { return x % 2 == 0; });",
            "// All even numbers before pivot, odd numbers after",
            "// Order within each partition is not guaranteed",
            "",
            "std::cout << \"Even numbers: \";",
            "std::for_each(vec.begin(), pivot, [](int n) { std::cout << n << \" \"; });",
            "std::cout << \"\\nOdd numbers: \";",
            "std::for_each(pivot, vec.end(), [](int n) { std::cout << n << \" \"; });",
            "",
            "// stable_partition: Maintains relative order within partitions",
            "std::vector<int> vec2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};",
            "",
            "auto pivot2 = std::stable_partition(vec2.begin(), vec2.end(),",
            "                                   [](int x) { return x > 5; });",
            "// Elements > 5 come first, maintaining their relative order",
            "// Result: 6, 7, 8, 9, 10, 1, 2, 3, 4, 5",
            "",
            "// Practical example: separate positive and negative",
            "std::vector<int> numbers = {-5, 3, -2, 7, -1, 4, -8, 6};",
            "std::stable_partition(numbers.begin(), numbers.end(),",
            "                     [](int x) { return x >= 0; });",
            "// Result: 3, 7, 4, 6, -5, -2, -1, -8",
            "$0"
        ],
        "description": "Reorders elements so that elements satisfying the predicate appear before those that don't. partition may reorder elements within each group. stable_partition maintains the relative order of elements within each group. Returns iterator to first element of second group. Time complexity: O(n) for partition, O(n log n) for stable_partition. Link: https://en.cppreference.com/w/cpp/algorithm/partition"
    },
    "cpp_algorithm__sort_stable_sort_partial_sort": {
        "prefix": "cpp_algorithm__sort_stable_sort_partial_sort",
        "body": [
            "// std::sort, std::stable_sort, std::partial_sort - Sort elements",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/sort",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "#include <functional>",
            "",
            "// sort: Sort entire range (typically introsort)",
            "std::vector<int> vec = {3, 1, 4, 1, 5, 9, 2, 6, 5};",
            "std::sort(vec.begin(), vec.end());",
            "// vec: 1, 1, 2, 3, 4, 5, 5, 6, 9",
            "",
            "// Sort in descending order",
            "std::sort(vec.begin(), vec.end(), std::greater<int>());",
            "// vec: 9, 6, 5, 5, 4, 3, 2, 1, 1",
            "",
            "// Sort with custom comparison",
            "struct Person { std::string name; int age; };",
            "std::vector<Person> people = {{\"Alice\", 30}, {\"Bob\", 25}, {\"Carol\", 35}};",
            "",
            "std::sort(people.begin(), people.end(),",
            "          [](const Person& a, const Person& b) { return a.age < b.age; });",
            "",
            "// stable_sort: Maintains relative order of equal elements",
            "std::vector<std::pair<int, char>> pairs = {{1,'a'}, {2,'b'}, {1,'c'}, {2,'d'}};",
            "std::stable_sort(pairs.begin(), pairs.end(),",
            "                [](const auto& a, const auto& b) { return a.first < b.first; });",
            "// Maintains order of elements with same first value",
            "",
            "// partial_sort: Sort only first n elements",
            "std::vector<int> scores = {85, 92, 78, 95, 88, 73, 91, 87, 90};",
            "std::partial_sort(scores.begin(), scores.begin() + 3, scores.end(),",
            "                 std::greater<int>());",
            "// First 3 elements are the 3 highest: 95, 92, 91",
            "// Rest are unspecified order",
            "$0"
        ],
        "description": "Sorts elements in ascending order. sort uses introsort (quicksort + heapsort + insertion sort). stable_sort maintains relative order of equivalent elements. partial_sort sorts only the first n elements. All accept custom comparison functions. Time complexity: O(n log n) average for sort, O(n log n) for stable_sort, O(n log m) for partial_sort where m is number of sorted elements. Link: https://en.cppreference.com/w/cpp/algorithm/sort"
    },
    "cpp_algorithm__nth_element": {
        "prefix": "cpp_algorithm__nth_element",
        "body": [
            "// std::nth_element - Partial sorting algorithm",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/nth_element",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> vec = {5, 2, 8, 1, 9, 3, 7, 4, 6};",
            "",
            "// Find the median (5th element when sorted)",
            "std::nth_element(vec.begin(), vec.begin() + 4, vec.end());",
            "std::cout << \"Median: \" << vec[4] << std::endl; // 5",
            "// Elements before vec[4] are <= vec[4]",
            "// Elements after vec[4] are >= vec[4]",
            "",
            "// Find the 3 smallest elements",
            "std::nth_element(vec.begin(), vec.begin() + 2, vec.end());",
            "// First 3 elements are the 3 smallest (order not specified)",
            "",
            "// Find kth largest element",
            "int k = 3; // Find 3rd largest",
            "std::nth_element(vec.begin(), vec.end() - k, vec.end());",
            "std::cout << k << \"rd largest: \" << vec[vec.size() - k] << std::endl;",
            "",
            "// With custom comparison",
            "std::nth_element(vec.begin(), vec.begin() + 4, vec.end(),",
            "                std::greater<int>());",
            "// Now vec[4] is the 5th largest element",
            "$0"
        ],
        "description": "Rearranges elements so that the element at the nth position is the element that would be in that position if the range was sorted. All elements before nth are less than or equal to the elements after nth. Useful for finding medians or kth smallest/largest elements. Time complexity: O(n) on average. Link: https://en.cppreference.com/w/cpp/algorithm/nth_element"
    },
    "cpp_algorithm__binary_search_lower_bound_upper_bound": {
        "prefix": "cpp_algorithm__binary_search_lower_bound_upper_bound",
        "body": [
            "// std::binary_search, std::lower_bound, std::upper_bound - Binary search operations",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/binary_search",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> vec = {1, 2, 4, 4, 4, 6, 7, 9};",
            "// Note: vector must be sorted for binary search operations",
            "",
            "// binary_search: Check if value exists",
            "bool found = std::binary_search(vec.begin(), vec.end(), 4);",
            "std::cout << \"4 exists: \" << found << std::endl; // true",
            "",
            "// lower_bound: First position where value could be inserted",
            "auto lower = std::lower_bound(vec.begin(), vec.end(), 4);",
            "std::cout << \"Lower bound of 4 at position: \"",
            "          << std::distance(vec.begin(), lower) << std::endl; // 2",
            "",
            "// upper_bound: Last position where value could be inserted",
            "auto upper = std::upper_bound(vec.begin(), vec.end(), 4);",
            "std::cout << \"Upper bound of 4 at position: \"",
            "          << std::distance(vec.begin(), upper) << std::endl; // 5",
            "",
            "// Count occurrences of value",
            "auto count = std::distance(lower, upper);",
            "std::cout << \"Count of 4: \" << count << std::endl; // 3",
            "",
            "// equal_range: Get both bounds at once",
            "auto range = std::equal_range(vec.begin(), vec.end(), 4);",
            "std::cout << \"Range: [\" << std::distance(vec.begin(), range.first)",
            "          << \", \" << std::distance(vec.begin(), range.second) << \")\\n\";",
            "",
            "// Insert in sorted position",
            "int value = 5;",
            "vec.insert(std::upper_bound(vec.begin(), vec.end(), value), value);",
            "$0"
        ],
        "description": "Binary search operations on sorted ranges. binary_search returns true if value is found. lower_bound returns iterator to first element not less than value. upper_bound returns iterator to first element greater than value. equal_range returns both bounds. All require sorted input. Time complexity: O(log n) comparisons. Link: https://en.cppreference.com/w/cpp/algorithm/binary_search"
    },
    "cpp_algorithm__merge_inplace_merge": {
        "prefix": "cpp_algorithm__merge_inplace_merge",
        "body": [
            "// std::merge, std::inplace_merge - Merge sorted sequences",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/merge",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "// merge: Merge two sorted ranges into a third",
            "std::vector<int> vec1 = {1, 3, 5, 7, 9};",
            "std::vector<int> vec2 = {2, 4, 6, 8, 10};",
            "std::vector<int> result(vec1.size() + vec2.size());",
            "",
            "std::merge(vec1.begin(), vec1.end(),",
            "          vec2.begin(), vec2.end(),",
            "          result.begin());",
            "// result: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10",
            "",
            "// Merge with custom comparison",
            "std::merge(vec1.begin(), vec1.end(),",
            "          vec2.begin(), vec2.end(),",
            "          result.begin(), std::greater<int>());",
            "",
            "// inplace_merge: Merge two consecutive sorted ranges",
            "std::vector<int> vec = {1, 3, 5, 7, 9, 2, 4, 6, 8, 10};",
            "// First half [0, 5) and second half [5, 10) are sorted",
            "",
            "std::inplace_merge(vec.begin(), vec.begin() + 5, vec.end());",
            "// vec: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10",
            "",
            "// Practical example: merge sort implementation",
            "void merge_sort(std::vector<int>::iterator first, std::vector<int>::iterator last) {",
            "    if (last - first > 1) {",
            "        auto middle = first + (last - first) / 2;",
            "        merge_sort(first, middle);",
            "        merge_sort(middle, last);",
            "        std::inplace_merge(first, middle, last);",
            "    }",
            "}",
            "$0"
        ],
        "description": "Merges sorted sequences. merge combines two sorted ranges into a third sorted range. inplace_merge merges two consecutive sorted ranges in-place. Both maintain the relative order of equivalent elements (stable). Requires pre-sorted input ranges. Time complexity: O(n+m) for merge, O(n log n) for inplace_merge. Link: https://en.cppreference.com/w/cpp/algorithm/merge"
    },
    "cpp_algorithm__includes_set_operations": {
        "prefix": "cpp_algorithm__includes_set_operations",
        "body": [
            "// Set operations: includes, set_difference, set_intersection, set_union, set_symmetric_difference",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/includes",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "#include <iterator>",
            "",
            "std::vector<int> set1 = {1, 2, 3, 4, 5, 6, 7, 8};",
            "std::vector<int> set2 = {3, 4, 5, 9, 10};",
            "std::vector<int> result;",
            "",
            "// includes: Check if set2 is subset of set1",
            "bool is_subset = std::includes(set1.begin(), set1.end(),",
            "                              set2.begin(), set2.end());",
            "std::cout << \"set2 subset of set1: \" << is_subset << std::endl; // false",
            "",
            "// set_difference: Elements in set1 but not in set2",
            "std::set_difference(set1.begin(), set1.end(),",
            "                   set2.begin(), set2.end(),",
            "                   std::back_inserter(result));",
            "// result: 1, 2, 6, 7, 8",
            "",
            "// set_intersection: Elements in both sets",
            "result.clear();",
            "std::set_intersection(set1.begin(), set1.end(),",
            "                     set2.begin(), set2.end(),",
            "                     std::back_inserter(result));",
            "// result: 3, 4, 5",
            "",
            "// set_union: Elements in either set",
            "result.clear();",
            "std::set_union(set1.begin(), set1.end(),",
            "              set2.begin(), set2.end(),",
            "              std::back_inserter(result));",
            "// result: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10",
            "",
            "// set_symmetric_difference: Elements in either set but not both",
            "result.clear();",
            "std::set_symmetric_difference(set1.begin(), set1.end(),",
            "                             set2.begin(), set2.end(),",
            "                             std::back_inserter(result));",
            "// result: 1, 2, 6, 7, 8, 9, 10",
            "$0"
        ],
        "description": "Set operations on sorted ranges. includes tests if one set is a subset of another. set_difference computes elements in first set but not in second. set_intersection computes common elements. set_union computes all unique elements. set_symmetric_difference computes elements in either set but not both. All require sorted inputs. Time complexity: O(n+m). Link: https://en.cppreference.com/w/cpp/algorithm/includes"
    },
    "cpp_algorithm__heap_operations": {
        "prefix": "cpp_algorithm__heap_operations",
        "body": [
            "// Heap operations: make_heap, push_heap, pop_heap, sort_heap",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/make_heap",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> vec = {3, 1, 4, 1, 5, 9, 2, 6};",
            "",
            "// make_heap: Convert range into a max heap",
            "std::make_heap(vec.begin(), vec.end());",
            "// vec is now a valid max heap with largest element at front",
            "std::cout << \"Max element: \" << vec.front() << std::endl; // 9",
            "",
            "// push_heap: Add element to heap",
            "vec.push_back(7); // Add to end",
            "std::push_heap(vec.begin(), vec.end()); // Restore heap property",
            "",
            "// pop_heap: Remove largest element",
            "std::pop_heap(vec.begin(), vec.end()); // Move largest to end",
            "int largest = vec.back();",
            "vec.pop_back(); // Actually remove it",
            "std::cout << \"Removed: \" << largest << std::endl;",
            "",
            "// sort_heap: Sort a heap",
            "std::sort_heap(vec.begin(), vec.end());",
            "// vec is now sorted in ascending order",
            "",
            "// Min heap using custom comparison",
            "std::vector<int> min_heap = {3, 1, 4, 1, 5, 9, 2, 6};",
            "std::make_heap(min_heap.begin(), min_heap.end(), std::greater<int>());",
            "std::cout << \"Min element: \" << min_heap.front() << std::endl; // 1",
            "",
            "// is_heap: Check if range is a heap",
            "bool is_valid = std::is_heap(vec.begin(), vec.end());",
            "",
            "// is_heap_until: Find first element breaking heap property",
            "auto heap_end = std::is_heap_until(vec.begin(), vec.end());",
            "$0"
        ],
        "description": "Heap operations for creating and manipulating binary heaps. make_heap creates a heap from a range. push_heap inserts element into heap. pop_heap removes largest element. sort_heap sorts a heap. is_heap checks if range is a valid heap. Default creates max heap, use greater<> for min heap. Time complexity: O(n) for make_heap, O(log n) for push/pop_heap, O(n log n) for sort_heap. Link: https://en.cppreference.com/w/cpp/algorithm/make_heap"
    },
    "cpp_algorithm__min_max_operations": {
        "prefix": "cpp_algorithm__min_max_operations",
        "body": [
            "// Min/max operations: min, max, minmax, min_element, max_element, minmax_element",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/min",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "// min/max: Compare two values",
            "int a = 5, b = 10;",
            "std::cout << \"Min: \" << std::min(a, b) << std::endl; // 5",
            "std::cout << \"Max: \" << std::max(a, b) << std::endl; // 10",
            "",
            "// min/max with initializer list",
            "int minimum = std::min({3, 1, 4, 1, 5, 9});",
            "int maximum = std::max({3, 1, 4, 1, 5, 9});",
            "",
            "// minmax: Get both at once (C++11)",
            "auto [min_val, max_val] = std::minmax(a, b);",
            "",
            "// min_element/max_element: Find in range",
            "std::vector<int> vec = {3, 1, 4, 1, 5, 9, 2, 6};",
            "",
            "auto min_it = std::min_element(vec.begin(), vec.end());",
            "auto max_it = std::max_element(vec.begin(), vec.end());",
            "std::cout << \"Min element: \" << *min_it << \" at position \"",
            "          << std::distance(vec.begin(), min_it) << std::endl;",
            "std::cout << \"Max element: \" << *max_it << \" at position \"",
            "          << std::distance(vec.begin(), max_it) << std::endl;",
            "",
            "// minmax_element: Get both iterators at once",
            "auto [min_it2, max_it2] = std::minmax_element(vec.begin(), vec.end());",
            "",
            "// Custom comparison",
            "auto abs_compare = [](int a, int b) { return std::abs(a) < std::abs(b); };",
            "std::vector<int> numbers = {-5, 3, -8, 2, -1};",
            "auto min_abs = std::min_element(numbers.begin(), numbers.end(), abs_compare);",
            "$0"
        ],
        "description": "Min/max operations for finding minimum and maximum values. min/max compare two values or initializer lists. minmax returns both at once. min_element/max_element find extremes in ranges. minmax_element finds both extremes in one pass. All support custom comparison functions. Time complexity: O(1) for value comparisons, O(n) for range operations. Link: https://en.cppreference.com/w/cpp/algorithm/min"
    },
    "cpp_algorithm__clamp": {
        "prefix": "cpp_algorithm__clamp",
        "body": [
            "// std::clamp - Constrain value to range (C++17)",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/clamp",
            "#include <algorithm>",
            "#include <iostream>",
            "",
            "// Basic usage",
            "int value = 15;",
            "int clamped = std::clamp(value, 0, 10);",
            "std::cout << \"Clamped value: \" << clamped << std::endl; // 10",
            "",
            "// Clamp to range",
            "int x = -5;",
            "x = std::clamp(x, 0, 100); // x becomes 0",
            "",
            "int y = 150;",
            "y = std::clamp(y, 0, 100); // y becomes 100",
            "",
            "int z = 50;",
            "z = std::clamp(z, 0, 100); // z remains 50",
            "",
            "// With custom comparison",
            "struct Point { int x, y; };",
            "auto point_compare = [](const Point& a, const Point& b) {",
            "    return a.x < b.x;",
            "};",
            "",
            "Point p = {15, 20};",
            "Point min_p = {0, 0};",
            "Point max_p = {10, 10};",
            "Point clamped_p = std::clamp(p, min_p, max_p, point_compare);",
            "",
            "// Practical example: color component",
            "auto clamp_color = [](int color) {",
            "    return std::clamp(color, 0, 255);",
            "};",
            "$0"
        ],
        "description": "Clamps a value between a minimum and maximum. If v < lo, returns lo. If hi < v, returns hi. Otherwise returns v. The behavior is undefined if lo > hi. Supports custom comparison functions. Time complexity: O(1). Link: https://en.cppreference.com/w/cpp/algorithm/clamp"
    },
    "cpp_algorithm__lexicographical_compare": {
        "prefix": "cpp_algorithm__lexicographical_compare",
        "body": [
            "// std::lexicographical_compare - Compare ranges lexicographically",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/lexicographical_compare",
            "#include <algorithm>",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "",
            "// Compare vectors",
            "std::vector<int> vec1 = {1, 2, 3, 4};",
            "std::vector<int> vec2 = {1, 2, 4, 3};",
            "",
            "bool is_less = std::lexicographical_compare(",
            "    vec1.begin(), vec1.end(),",
            "    vec2.begin(), vec2.end());",
            "std::cout << \"vec1 < vec2: \" << is_less << std::endl; // true",
            "",
            "// Compare strings character by character",
            "std::string str1 = \"apple\";",
            "std::string str2 = \"application\";",
            "",
            "bool str_less = std::lexicographical_compare(",
            "    str1.begin(), str1.end(),",
            "    str2.begin(), str2.end());",
            "// true because \"apple\" < \"application\"",
            "",
            "// Case-insensitive comparison",
            "auto case_insensitive = [](char a, char b) {",
            "    return std::tolower(a) < std::tolower(b);",
            "};",
            "",
            "std::string s1 = \"Apple\";",
            "std::string s2 = \"apple\";",
            "bool case_less = std::lexicographical_compare(",
            "    s1.begin(), s1.end(),",
            "    s2.begin(), s2.end(),",
            "    case_insensitive);",
            "",
            "// Compare arrays of different sizes",
            "int arr1[] = {1, 2, 3};",
            "int arr2[] = {1, 2, 3, 4};",
            "bool arr_less = std::lexicographical_compare(",
            "    std::begin(arr1), std::end(arr1),",
            "    std::begin(arr2), std::end(arr2));",
            "// true because arr1 is prefix of arr2",
            "$0"
        ],
        "description": "Compares two ranges lexicographically (dictionary order). Returns true if the first range is lexicographically less than the second. Comparison stops at first mismatch or when one range ends. Shorter range is considered less if it's a prefix of the longer. Supports custom comparison. Time complexity: O(min(n1,n2)) comparisons. Link: https://en.cppreference.com/w/cpp/algorithm/lexicographical_compare"
    },
    "cpp_algorithm__next_permutation_prev_permutation": {
        "prefix": "cpp_algorithm__next_permutation_prev_permutation",
        "body": [
            "// std::next_permutation, std::prev_permutation - Generate permutations",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/next_permutation",
            "#include <algorithm>",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "",
            "// Generate all permutations of a vector",
            "std::vector<int> vec = {1, 2, 3};",
            "",
            "// Must start with sorted sequence for all permutations",
            "std::sort(vec.begin(), vec.end());",
            "",
            "do {",
            "    for (int n : vec) std::cout << n << \" \";",
            "    std::cout << \"\\n\";",
            "} while (std::next_permutation(vec.begin(), vec.end()));",
            "// Output: 1 2 3, 1 3 2, 2 1 3, 2 3 1, 3 1 2, 3 2 1",
            "",
            "// Generate permutations of string",
            "std::string str = \"abc\";",
            "do {",
            "    std::cout << str << \" \";",
            "} while (std::next_permutation(str.begin(), str.end()));",
            "// Output: abc acb bac bca cab cba",
            "",
            "// prev_permutation: Generate in reverse order",
            "std::vector<int> vec2 = {3, 2, 1};",
            "do {",
            "    for (int n : vec2) std::cout << n << \" \";",
            "    std::cout << \"\\n\";",
            "} while (std::prev_permutation(vec2.begin(), vec2.end()));",
            "",
            "// Check if more permutations exist",
            "std::vector<int> last_perm = {3, 2, 1};",
            "bool has_next = std::next_permutation(last_perm.begin(), last_perm.end());",
            "// has_next is false, last_perm becomes {1, 2, 3}",
            "",
            "// Custom comparison",
            "std::vector<int> vec3 = {3, 2, 1};",
            "std::next_permutation(vec3.begin(), vec3.end(), std::greater<int>());",
            "$0"
        ],
        "description": "Transforms range into next/previous lexicographically-ordered permutation. next_permutation generates the next greater permutation. prev_permutation generates the next smaller permutation. Returns false if the sequence is already the last/first permutation, wrapping around to first/last. Commonly used to generate all permutations by starting with sorted sequence. Time complexity: O(n/2) on average. Link: https://en.cppreference.com/w/cpp/algorithm/next_permutation"
    },
    "cpp_algorithm__iota": {
        "prefix": "cpp_algorithm__iota",
        "body": [
            "// std::iota - Fill range with sequentially increasing values",
            "// Reference: https://en.cppreference.com/w/cpp/numeric/iota",
            "#include <numeric>",
            "#include <vector>",
            "#include <iostream>",
            "#include <list>",
            "",
            "// Fill with sequential integers starting from 0",
            "std::vector<int> vec(10);",
            "std::iota(vec.begin(), vec.end(), 0);",
            "// vec: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9",
            "",
            "// Fill starting from different value",
            "std::vector<int> vec2(5);",
            "std::iota(vec2.begin(), vec2.end(), 100);",
            "// vec2: 100, 101, 102, 103, 104",
            "",
            "// Works with other types",
            "std::vector<char> chars(26);",
            "std::iota(chars.begin(), chars.end(), 'a');",
            "// chars: a, b, c, d, ..., z",
            "",
            "// Create index array",
            "std::vector<size_t> indices(vec.size());",
            "std::iota(indices.begin(), indices.end(), 0);",
            "// Useful for sorting indices instead of values",
            "",
            "// With custom incrementable type",
            "struct Counter {",
            "    int value;",
            "    Counter& operator++() { value += 2; return *this; }",
            "    operator int() const { return value; }",
            "};",
            "",
            "std::vector<int> even_numbers(5);",
            "Counter c{0};",
            "std::iota(even_numbers.begin(), even_numbers.end(), c);",
            "// even_numbers: 0, 2, 4, 6, 8",
            "$0"
        ],
        "description": "Fills a range with sequentially increasing values, starting with value and repeatedly incrementing it. Each element is assigned the current value, then value is incremented. Works with any type that supports operator++. Commonly used to create sequences of numbers or indices. Time complexity: O(n) increments and assignments. Link: https://en.cppreference.com/w/cpp/numeric/iota"
    },
    "cpp_algorithm__accumulate": {
        "prefix": "cpp_algorithm__accumulate",
        "body": [
            "// std::accumulate - Fold/reduce operation",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/accumulate",
            "#include <numeric>",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <functional>",
            "",
            "std::vector<int> vec = {1, 2, 3, 4, 5};",
            "",
            "// Sum all elements",
            "int sum = std::accumulate(vec.begin(), vec.end(), 0);",
            "std::cout << \"Sum: \" << sum << std::endl; // 15",
            "",
            "// Product of all elements",
            "int product = std::accumulate(vec.begin(), vec.end(), 1,",
            "                             std::multiplies<int>());",
            "std::cout << \"Product: \" << product << std::endl; // 120",
            "",
            "// String concatenation",
            "std::vector<std::string> words = {\"Hello\", \" \", \"World\", \"!\"};",
            "std::string sentence = std::accumulate(words.begin(), words.end(),",
            "                                      std::string(\"\"));",
            "// sentence: \"Hello World!\"",
            "",
            "// Custom operation - find max",
            "int max_val = std::accumulate(vec.begin(), vec.end(), vec[0],",
            "                             [](int a, int b) { return std::max(a, b); });",
            "",
            "// Calculate average",
            "double average = std::accumulate(vec.begin(), vec.end(), 0.0) / vec.size();",
            "",
            "// Accumulate with different type",
            "std::vector<int> lengths = {3, 5, 2, 8, 1};",
            "std::string repeated = std::accumulate(lengths.begin(), lengths.end(),",
            "                                      std::string(\"\"),",
            "                                      [](std::string s, int n) { return s + std::string(n, '*'); });",
            "// repeated: \"********\" (if lengths = {3, 5})",
            "$0"
        ],
        "description": "Calculates the sum of a range of values, or applies a custom binary operation. It takes an initial value and iterates through the range, applying the operation to the current accumulated value and each element. Supports custom binary operations. Time complexity: O(n) applications of the binary operation. Link: https://en.cppreference.com/w/cpp/algorithm/accumulate"
    },
    "cpp_algorithm__equal": {
        "prefix": "cpp_algorithm__equal",
        "body": [
            "// std::equal - Compare two ranges for equality",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/equal",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> v1 = {1, 2, 3, 4, 5};",
            "std::vector<int> v2 = {1, 2, 3, 4, 5};",
            "std::vector<int> v3 = {1, 2, 3, 4, 6};",
            "",
            "// Basic equality check",
            "bool are_equal = std::equal(v1.begin(), v1.end(), v2.begin());",
            "std::cout << \"v1 and v2 are equal: \" << std::boolalpha << are_equal << std::endl; // true",
            "",
            "// Check with different range",
            "bool are_equal2 = std::equal(v1.begin(), v1.end(), v3.begin());",
            "std::cout << \"v1 and v3 are equal: \" << std::boolalpha << are_equal2 << std::endl; // false",
            "",
            "// With custom predicate",
            "auto abs_equal = [](int a, int b) { return std::abs(a) == std::abs(b); };",
            "std::vector<int> v4 = {1, -2, 3, -4, 5};",
            "bool abs_are_equal = std::equal(v1.begin(), v1.end(), v4.begin(), abs_equal);",
            "std::cout << \"v1 and v4 are equal (abs): \" << std::boolalpha << abs_are_equal << std::endl; // true",
            "",
            "// C++14 overload with two pairs of iterators",
            "std::vector<int> v5 = {1, 2, 3};",
            "std::vector<int> v6 = {1, 2, 3};",
            "bool are_equal3 = std::equal(v5.begin(), v5.end(), v6.begin(), v6.end());",
            "std::cout << \"v5 and v6 are equal (two ranges): \" << std::boolalpha << are_equal3 << std::endl; // true",
            "$0"
        ],
        "description": "Compares two ranges for equality. Returns true if all elements in the first range are equal to corresponding elements in the second range. The second range must be at least as long as the first. Supports custom predicates. Time complexity: O(n) comparisons. Link: https://en.cppreference.com/w/cpp/algorithm/equal"
    },
    "cpp_algorithm__mismatch": {
        "prefix": "cpp_algorithm__mismatch",
        "body": [
            "// std::mismatch - Find first position where two ranges differ",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/mismatch",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> v1 = {1, 2, 3, 4, 5};",
            "std::vector<int> v2 = {1, 2, 3, 6, 5};",
            "std::vector<int> v3 = {1, 2, 3, 4, 5};",
            "",
            "// Find first mismatch",
            "auto pair1 = std::mismatch(v1.begin(), v1.end(), v2.begin());",
            "if (pair1.first != v1.end()) {",
            "    std::cout << \"Mismatch at index \" << std::distance(v1.begin(), pair1.first)",
            "              << \": \" << *pair1.first << \" vs \" << *pair1.second << std::endl; // Mismatch at index 3: 4 vs 6",
            "} else {",
            "    std::cout << \"Ranges v1 and v2 are identical.\" << std::endl;",
            "}",
            "",
            "// No mismatch",
            "auto pair2 = std::mismatch(v1.begin(), v1.end(), v3.begin());",
            "if (pair2.first != v1.end()) {",
            "    std::cout << \"Mismatch at index \" << std::distance(v1.begin(), pair2.first)",
            "              << \": \" << *pair2.first << \" vs \" << *pair2.second << std::endl;",
            "} else {",
            "    std::cout << \"Ranges v1 and v3 are identical.\" << std::endl; // Ranges v1 and v3 are identical.",
            "}",
            "",
            "// With custom predicate",
            "auto abs_compare = [](int a, int b) { return std::abs(a) == std::abs(b); };",
            "std::vector<int> v4 = {1, -2, 3, -4, 5};",
            "auto pair3 = std::mismatch(v1.begin(), v1.end(), v4.begin(), abs_compare);",
            "if (pair3.first != v1.end()) {",
            "    std::cout << \"Mismatch (abs) at index \" << std::distance(v1.begin(), pair3.first)",
            "              << \": \" << *pair3.first << \" vs \" << *pair3.second << std::endl;",
            "} else {",
            "    std::cout << \"Ranges v1 and v4 are identical (abs).\" << std::endl; // Ranges v1 and v4 are identical (abs).",
            "}",
            "",
            "// C++14 overload with two pairs of iterators",
            "std::vector<int> v5 = {1, 2, 3};",
            "std::vector<int> v6 = {1, 2, 4};",
            "auto pair4 = std::mismatch(v5.begin(), v5.end(), v6.begin(), v6.end());",
            "if (pair4.first != v5.end()) {",
            "    std::cout << \"Mismatch (two ranges) at index \" << std::distance(v5.begin(), pair4.first)",
            "              << \": \" << *pair4.first << \" vs \" << *pair4.second << std::endl; // Mismatch (two ranges) at index 2: 3 vs 4",
            "}",
            "$0"
        ],
        "description": "Finds the first position where two ranges differ. Returns a pair of iterators to the first differing elements in each range. If the ranges are identical up to the end of the first range, it returns a pair of iterators to the end of the first range and the corresponding position in the second. Supports custom predicates. Time complexity: O(n) comparisons. Link: https://en.cppreference.com/w/cpp/algorithm/mismatch"
    },
    "cpp_algorithm__is_permutation": {
        "prefix": "cpp_algorithm__is_permutation",
        "body": [
            "// std::is_permutation - Check if one range is a permutation of another",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/is_permutation",
            "#include <algorithm>",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "",
            "std::vector<int> v1 = {1, 2, 3, 4, 5};",
            "std::vector<int> v2 = {5, 4, 3, 2, 1};",
            "std::vector<int> v3 = {1, 2, 3, 4, 6};",
            "std::vector<int> v4 = {1, 2, 3, 4};",
            "",
            "// Check if v2 is a permutation of v1",
            "bool is_perm = std::is_permutation(v1.begin(), v1.end(), v2.begin());",
            "std::cout << \"v2 is permutation of v1: \" << std::boolalpha << is_perm << std::endl; // true",
            "",
            "// Check with non-permutation",
            "bool is_perm2 = std::is_permutation(v1.begin(), v1.end(), v3.begin());",
            "std::cout << \"v3 is permutation of v1: \" << std::boolalpha << is_perm2 << std::endl; // false",
            "",
            "// Check with different size (false)",
            "bool is_perm3 = std::is_permutation(v1.begin(), v1.end(), v4.begin());",
            "std::cout << \"v4 is permutation of v1: \" << std::boolalpha << is_perm3 << std::endl; // false (sizes differ)",
            "",
            "// With custom predicate",
            "auto abs_equal = [](int a, int b) { return std::abs(a) == std::abs(b); };",
            "std::vector<int> v5 = {1, -2, 3, -4, 5};",
            "std::vector<int> v6 = {5, 4, -3, 2, -1};",
            "bool is_perm_abs = std::is_permutation(v5.begin(), v5.end(), v6.begin(), abs_equal);",
            "std::cout << \"v6 is permutation of v5 (abs): \" << std::boolalpha << is_perm_abs << std::endl; // true",
            "",
            "// C++14 overload with two pairs of iterators",
            "std::string s1 = \"listen\";",
            "std::string s2 = \"silent\";",
            "bool is_perm_str = std::is_permutation(s1.begin(), s1.end(), s2.begin(), s2.end());",
            "std::cout << \"'silent' is permutation of 'listen': \" << std::boolalpha << is_perm_str << std::endl; // true",
            "$0"
        ],
        "description": "Checks if the elements in one range are a permutation of the elements in another range. Both ranges must have the same number of elements. Supports custom predicates. Time complexity: O(N^2) in general, O(N log N) if elements are hashable or sortable. Link: https://en.cppreference.com/w/cpp/algorithm/is_permutation"
    },
    "cpp_algorithm__is_sorted": {
        "prefix": "cpp_algorithm__is_sorted",
        "body": [
            "// std::is_sorted - Check if range is sorted",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/is_sorted",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> v1 = {1, 2, 3, 4, 5};",
            "std::vector<int> v2 = {1, 3, 2, 4, 5};",
            "std::vector<int> v3 = {5, 4, 3, 2, 1};",
            "",
            "// Check ascending order",
            "bool sorted_asc = std::is_sorted(v1.begin(), v1.end());",
            "std::cout << \"v1 is sorted (asc): \" << std::boolalpha << sorted_asc << std::endl; // true",
            "",
            "bool sorted_asc2 = std::is_sorted(v2.begin(), v2.end());",
            "std::cout << \"v2 is sorted (asc): \" << std::boolalpha << sorted_asc2 << std::endl; // false",
            "",
            "// Check descending order with custom comparator",
            "bool sorted_desc = std::is_sorted(v3.begin(), v3.end(), std::greater<int>());",
            "std::cout << \"v3 is sorted (desc): \" << std::boolalpha << sorted_desc << std::endl; // true",
            "",
            "// Empty or single-element range is always sorted",
            "std::vector<int> empty_v;",
            "bool empty_sorted = std::is_sorted(empty_v.begin(), empty_v.end());",
            "std::cout << \"Empty vector is sorted: \" << std::boolalpha << empty_sorted << std::endl; // true",
            "",
            "std::vector<int> single_v = {42};",
            "bool single_sorted = std::is_sorted(single_v.begin(), single_v.end());",
            "std::cout << \"Single-element vector is sorted: \" << std::boolalpha << single_sorted << std::endl; // true",
            "$0"
        ],
        "description": "Checks if a range is sorted in non-descending order. Returns true if the range is sorted, false otherwise. Supports custom comparison predicates. Time complexity: O(n) comparisons. Link: https://en.cppreference.com/w/cpp/algorithm/is_sorted"
    },
    "cpp_algorithm__is_sorted_until": {
        "prefix": "cpp_algorithm__is_sorted_until",
        "body": [
            "// std::is_sorted_until - Find first unsorted element in range",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/is_sorted_until",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> v1 = {1, 2, 3, 4, 5, 0, 6};",
            "std::vector<int> v2 = {1, 2, 3, 4, 5};",
            "",
            "// Find first unsorted element (ascending)",
            "auto it1 = std::is_sorted_until(v1.begin(), v1.end());",
            "if (it1 != v1.end()) {",
            "    std::cout << \"v1 is sorted until index \" << std::distance(v1.begin(), it1)",
            "              << \", value: \" << *it1 << std::endl; // v1 is sorted until index 5, value: 0",
            "} else {",
            "    std::cout << \"v1 is fully sorted.\" << std::endl;",
            "}",
            "",
            "// Fully sorted range",
            "auto it2 = std::is_sorted_until(v2.begin(), v2.end());",
            "if (it2 != v2.end()) {",
            "    std::cout << \"v2 is sorted until index \" << std::distance(v2.begin(), it2)",
            "              << \", value: \" << *it2 << std::endl;",
            "} else {",
            "    std::cout << \"v2 is fully sorted.\" << std::endl; // v2 is fully sorted.",
            "}",
            "",
            "// With custom comparator (descending)",
            "std::vector<int> v3 = {5, 4, 3, 1, 2, 0};",
            "auto it3 = std::is_sorted_until(v3.begin(), v3.end(), std::greater<int>());",
            "if (it3 != v3.end()) {",
            "    std::cout << \"v3 is sorted (desc) until index \" << std::distance(v3.begin(), it3)",
            "              << \", value: \" << *it3 << std::endl; // v3 is sorted (desc) until index 3, value: 1",
            "}",
            "$0"
        ],
        "description": "Returns an iterator to the first element in a range that is not sorted according to the specified order. If the entire range is sorted, it returns the end iterator. Supports custom comparison predicates. Time complexity: O(n) comparisons. Link: https://en.cppreference.com/w/cpp/algorithm/is_sorted_until"
    },
    "cpp_algorithm__is_partitioned": {
        "prefix": "cpp_algorithm__is_partitioned",
        "body": [
            "// std::is_partitioned - Check if range is partitioned",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/is_partitioned",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "// Predicate: is even",
            "auto is_even = [](int n) { return n % 2 == 0; };",
            "",
            "std::vector<int> v1 = {2, 4, 6, 1, 3, 5}; // Partitioned: evens then odds",
            "std::vector<int> v2 = {2, 1, 4, 3, 6, 5}; // Not partitioned",
            "std::vector<int> v3 = {1, 3, 5, 2, 4, 6}; // Partitioned: odds then evens (predicate is_even)",
            "",
            "// Check if v1 is partitioned by is_even",
            "bool partitioned1 = std::is_partitioned(v1.begin(), v1.end(), is_even);",
            "std::cout << \"v1 is partitioned by is_even: \" << std::boolalpha << partitioned1 << std::endl; // true",
            "",
            "// Check if v2 is partitioned by is_even",
            "bool partitioned2 = std::is_partitioned(v2.begin(), v2.end(), is_even);",
            "std::cout << \"v2 is partitioned by is_even: \" << std::boolalpha << partitioned2 << std::endl; // false",
            "",
            "// Check if v3 is partitioned by is_even",
            "bool partitioned3 = std::is_partitioned(v3.begin(), v3.end(), is_even);",
            "std::cout << \"v3 is partitioned by is_even: \" << std::boolalpha << partitioned3 << std::endl; // false (elements satisfying predicate are not first)",
            "",
            "// A range with all elements satisfying or none satisfying is partitioned",
            "std::vector<int> v4 = {2, 4, 6};",
            "bool partitioned4 = std::is_partitioned(v4.begin(), v4.end(), is_even);",
            "std::cout << \"v4 is partitioned by is_even: \" << std::boolalpha << partitioned4 << std::endl; // true",
            "",
            "std::vector<int> v5 = {1, 3, 5};",
            "bool partitioned5 = std::is_partitioned(v5.begin(), v5.end(), is_even);",
            "std::cout << \"v5 is partitioned by is_even: \" << std::boolalpha << partitioned5 << std::endl; // true",
            "$0"
        ],
        "description": "Checks if a range is partitioned according to a given predicate. A range is partitioned if all elements for which the predicate is true come before all elements for which the predicate is false. Time complexity: O(n) applications of the predicate. Link: https://en.cppreference.com/w/cpp/algorithm/is_partitioned"
    },
    "cpp_algorithm__shuffle": {
        "prefix": "cpp_algorithm__shuffle",
        "body": [
            "// std::shuffle - Randomly reorder elements in a range (C++11)",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/shuffle",
            "#include <algorithm>",
            "#include <vector>",
            "#include <random>",
            "#include <chrono>",
            "#include <iostream>",
            "",
            "std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};",
            "",
            "// Obtain a random number engine",
            "unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();",
            "std::default_random_engine rng(seed);",
            "",
            "std::cout << \"Original vector: \";",
            "for (int x : v) std::cout << x << \" \";",
            "std::cout << std::endl;",
            "",
            "// Shuffle the vector",
            "std::shuffle(v.begin(), v.end(), rng);",
            "",
            "std::cout << \"Shuffled vector: \";",
            "for (int x : v) std::cout << x << \" \";",
            "std::cout << std::endl;",
            "",
            "// Shuffle again",
            "std::shuffle(v.begin(), v.end(), rng);",
            "",
            "std::cout << \"Shuffled again: \";",
            "for (int x : v) std::cout << x << \" \";",
            "std::cout << std::endl;",
            "",
            "// Example with a deck of cards (represented by integers)",
            "std::vector<int> deck(52);",
            "std::iota(deck.begin(), deck.end(), 1); // Fill with 1 to 52",
            "std::shuffle(deck.begin(), deck.end(), rng);",
            "",
            "// Deal first 5 cards",
            "std::cout << \"First 5 cards: \";",
            "for (int i = 0; i < 5; ++i) std::cout << deck[i] << \" \";",
            "std::cout << std::endl;",
            "$0"
        ],
        "description": "Randomly reorders the elements in a range using a given random number generator. Provides a uniform distribution over all possible permutations. Requires a C++11 compatible random number engine. Time complexity: O(n) swaps. Link: https://en.cppreference.com/w/cpp/algorithm/shuffle"
    },
    "cpp_algorithm__sample": {
        "prefix": "cpp_algorithm__sample",
        "body": [
            "// std::sample - Selects n random elements from a range (C++17)",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/sample",
            "#include <algorithm>",
            "#include <vector>",
            "#include <random>",
            "#include <chrono>",
            "#include <iostream>",
            "",
            "std::vector<int> population = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};",
            "std::vector<int> sample_vec(5); // Destination for 5 random elements",
            "",
            "// Obtain a random number engine",
            "unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();",
            "std::default_random_engine rng(seed);",
            "",
            "std::cout << \"Population: \";",
            "for (int x : population) std::cout << x << \" \";",
            "std::cout << std::endl;",
            "",
            "// Take a random sample of 5 elements",
            "std::sample(population.begin(), population.end(),",
            "            sample_vec.begin(), sample_vec.size(), rng);",
            "",
            "std::cout << \"Sample (5 elements): \";",
            "for (int x : sample_vec) std::cout << x << \" \";",
            "std::cout << std::endl;",
            "",
            "// Take a smaller sample directly to cout",
            "std::cout << \"Sample (3 elements, direct): \";",
            "std::sample(population.begin(), population.end(),",
            "            std::ostream_iterator<int>(std::cout, \" \"), 3, rng);",
            "std::cout << std::endl;",
            "",
            "// Sampling with replacement (not directly supported by std::sample, requires custom logic)",
            "// std::sample performs sampling without replacement.",
            "$0"
        ],
        "description": "Selects n random elements from a given range and copies them to a destination range. The selection is done without replacement. The order of the sampled elements is not guaranteed. Requires a C++11 compatible random number engine. Time complexity: O(N) on average, where N is the size of the input range. Link: https://en.cppreference.com/w/cpp/algorithm/sample"
    },
    "cpp_algorithm__partition_copy": {
        "prefix": "cpp_algorithm__partition_copy",
        "body": [
            "// std::partition_copy - Copy elements to two different ranges based on predicate (C++11)",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/partition_copy",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};",
            "std::vector<int> evens;",
            "std::vector<int> odds;",
            "",
            "// Predicate: is even",
            "auto is_even = [](int n) { return n % 2 == 0; };",
            "",
            "// Resize destination vectors to avoid reallocations (optional but good practice)",
            "evens.reserve(numbers.size());",
            "odds.reserve(numbers.size());",
            "",
            "// Partition and copy",
            "std::partition_copy(numbers.begin(), numbers.end(),",
            "                    std::back_inserter(evens),",
            "                    std::back_inserter(odds),",
            "                    is_even);",
            "",
            "std::cout << \"Original numbers: \";",
            "for (int n : numbers) std::cout << n << \" \";",
            "std::cout << std::endl;",
            "",
            "std::cout << \"Evens: \";",
            "for (int n : evens) std::cout << n << \" \";",
            "std::cout << std::endl; // Evens: 2 4 6 8 10",
            "",
            "std::cout << \"Odds: \";",
            "for (int n : odds) std::cout << n << \" \";",
            "std::cout << std::endl; // Odds: 1 3 5 7 9",
            "",
            "// Example with strings based on length",
            "std::vector<std::string> words = {\"apple\", \"cat\", \"banana\", \"dog\", \"elephant\"};",
            "std::vector<std::string> short_words;",
            "std::vector<std::string> long_words;",
            "",
            "auto is_short = [](const std::string& s) { return s.length() <= 4; };",
            "",
            "std::partition_copy(words.begin(), words.end(),",
            "                    std::back_inserter(short_words),",
            "                    std::back_inserter(long_words),",
            "                    is_short);",
            "",
            "std::cout << \"Short words: \";",
            "for (const std::string& s : short_words) std::cout << s << \" \";",
            "std::cout << std::endl; // Short words: cat dog",
            "",
            "std::cout << \"Long words: \";",
            "for (const std::string& s : long_words) std::cout << s << \" \";",
            "std::cout << std::endl; // Long words: apple banana elephant",
            "$0"
        ],
        "description": "Copies elements from an input range to two different output ranges based on a predicate. Elements for which the predicate is true are copied to the first destination, and elements for which it is false are copied to the second. The relative order of elements within each output range is preserved. Time complexity: O(n) applications of the predicate and copies. Link: https://en.cppreference.com/w/cpp/algorithm/partition_copy"
    },
    "cpp_numeric__inner_product": {
        "prefix": "cpp_numeric__inner_product",
        "body": [
            "// std::inner_product - Calculate inner product of two ranges",
            "// Reference: https://en.cppreference.com/w/cpp/numeric/inner_product",
            "#include <numeric>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> a = {1, 2, 3};",
            "std::vector<int> b = {4, 5, 6};",
            "",
            "// Default inner product (sum of products)",
            "// (1*4) + (2*5) + (3*6) = 4 + 10 + 18 = 32",
            "int result = std::inner_product(a.begin(), a.end(), b.begin(), 0);",
            "std::cout << \"Inner product: \" << result << std::endl; // 32",
            "",
            "// Custom operations: e.g., sum of differences",
            "// (1-4) + (2-5) + (3-6) = -3 + -3 + -3 = -9",
            "int custom_result = std::inner_product(a.begin(), a.end(), b.begin(), 0,",
            "                                       std::plus<int>(), std::minus<int>());",
            "std::cout << \"Custom inner product (sum of differences): \" << custom_result << std::endl; // -9",
            "",
            "// Boolean logic: check if all elements are equal (like std::equal)",
            "std::vector<bool> bool_a = {true, false, true};",
            "std::vector<bool> bool_b = {true, false, true};",
            "bool all_equal = std::inner_product(bool_a.begin(), bool_a.end(), bool_b.begin(), true,",
            "                                    std::logical_and<bool>(), std::equal_to<bool>());",
            "std::cout << \"All elements equal: \" << std::boolalpha << all_equal << std::endl; // true",
            "$0"
        ],
        "description": "Calculates the inner product (sum of products) of two ranges. It can also perform custom binary operations for both the accumulation and the element-wise combination. Time complexity: O(n) applications of the binary operations. Link: https://en.cppreference.com/w/cpp/numeric/inner_product"
    },
    "cpp_numeric__adjacent_difference": {
        "prefix": "cpp_numeric__adjacent_difference",
        "body": [
            "// std::adjacent_difference - Calculate differences between adjacent elements",
            "// Reference: https://en.cppreference.com/w/cpp/numeric/adjacent_difference",
            "#include <numeric>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> in = {1, 2, 4, 7, 11, 16};",
            "std::vector<int> out(in.size());",
            "",
            "// Calculate adjacent differences (default: subtraction)",
            "// out[0] = in[0]",
            "// out[i] = in[i] - in[i-1] for i > 0",
            "std::adjacent_difference(in.begin(), in.end(), out.begin());",
            "",
            "std::cout << \"Original: \";",
            "for (int x : in) std::cout << x << \" \";",
            "std::cout << std::endl;",
            "",
            "std::cout << \"Differences: \";",
            "for (int x : out) std::cout << x << \" \";",
            "std::cout << std::endl; // Differences: 1 1 2 3 4 5",
            "",
            "// With custom binary operation (e.g., sum of adjacent elements)",
            "std::vector<int> out_sum(in.size());",
            "std::adjacent_difference(in.begin(), in.end(), out_sum.begin(), std::plus<int>());",
            "",
            "std::cout << \"Sums: \";",
            "for (int x : out_sum) std::cout << x << \" \";",
            "std::cout << std::endl; // Sums: 1 3 6 11 18 27",
            "",
            "// Can be used to reconstruct original sequence from differences (with std::partial_sum)",
            "std::vector<int> reconstructed(out.size());",
            "std::partial_sum(out.begin(), out.end(), reconstructed.begin());",
            "std::cout << \"Reconstructed: \";",
            "for (int x : reconstructed) std::cout << x << \" \";",
            "std::cout << std::endl; // Reconstructed: 1 2 4 7 11 16",
            "$0"
        ],
        "description": "Calculates the differences between adjacent elements in a range and stores them in an output range. The first element of the output range is the same as the first element of the input range. Subsequent elements are the result of applying a binary operation (default: subtraction) to the current element and the previous element. Time complexity: O(n) applications of the binary operation. Link: https://en.cppreference.com/w/cpp/numeric/adjacent_difference"
    },
    "cpp_numeric__partial_sum": {
        "prefix": "cpp_numeric__partial_sum",
        "body": [
            "// std::partial_sum - Calculate partial sums (prefix sums)",
            "// Reference: https://en.cppreference.com/w/cpp/numeric/partial_sum",
            "#include <numeric>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> in = {1, 2, 3, 4, 5};",
            "std::vector<int> out(in.size());",
            "",
            "// Calculate partial sums (default: addition)",
            "// out[0] = in[0]",
            "// out[i] = out[i-1] + in[i]",
            "std::partial_sum(in.begin(), in.end(), out.begin());",
            "",
            "std::cout << \"Original: \";",
            "for (int x : in) std::cout << x << \" \";",
            "std::cout << std::endl;",
            "",
            "std::cout << \"Partial sums: \";",
            "for (int x : out) std::cout << x << \" \";",
            "std::cout << std::endl; // Partial sums: 1 3 6 10 15",
            "",
            "// With custom binary operation (e.g., partial products)",
            "std::vector<int> out_prod(in.size());",
            "std::partial_sum(in.begin(), in.end(), out_prod.begin(), std::multiplies<int>());",
            "",
            "std::cout << \"Partial products: \";",
            "for (int x : out_prod) std::cout << x << \" \";",
            "std::cout << std::endl; // Partial products: 1 2 6 24 120",
            "",
            "// Using std::partial_sum to reconstruct original sequence from adjacent_difference",
            "std::vector<int> diffs = {1, 1, 2, 3, 4, 5}; // From previous adjacent_difference example",
            "std::vector<int> reconstructed(diffs.size());",
            "std::partial_sum(diffs.begin(), diffs.end(), reconstructed.begin());",
            "std::cout << \"Reconstructed from diffs: \";",
            "for (int x : reconstructed) std::cout << x << \" \";",
            "std::cout << std::endl; // Reconstructed from diffs: 1 2 4 7 11 16",
            "$0"
        ],
        "description": "Calculates the partial sums (prefix sums) of a range and stores them in an output range. Each element in the output range is the result of applying a binary operation (default: addition) to the current element and the accumulated sum of previous elements. Supports custom binary operations. Time complexity: O(n) applications of the binary operation. Link: https://en.cppreference.com/w/cpp/numeric/partial_sum"
    },
    "cpp_numeric__exclusive_scan": {
        "prefix": "cpp_numeric__exclusive_scan",
        "body": [
            "// std::exclusive_scan - Computes an exclusive prefix sum (C++17)",
            "// Reference: https://en.cppreference.com/w/cpp/numeric/exclusive_scan",
            "#include <numeric>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> in = {1, 2, 3, 4, 5};",
            "std::vector<int> out(in.size());",
            "",
            "// Exclusive scan (default: addition, initial value 0)",
            "// out[0] = init",
            "// out[i] = out[i-1] + in[i-1]",
            "std::exclusive_scan(in.begin(), in.end(), out.begin(), 0);",
            "",
            "std::cout << \"Original: \";",
            "for (int x : in) std::cout << x << \" \";",
            "std::cout << std::endl;",
            "",
            "std::cout << \"Exclusive scan (sum, init 0): \";",
            "for (int x : out) std::cout << x << \" \";",
            "std::cout << std::endl; // Exclusive scan (sum, init 0): 0 1 3 6 10",
            "",
            "// Exclusive scan with different initial value and custom operation (e.g., multiplication)",
            "std::vector<int> out_prod(in.size());",
            "std::exclusive_scan(in.begin(), in.end(), out_prod.begin(), 1, std::multiplies<int>());",
            "",
            "std::cout << \"Exclusive scan (product, init 1): \";",
            "for (int x : out_prod) std::cout << x << \" \";",
            "std::cout << std::endl; // Exclusive scan (product, init 1): 1 1 2 6 24",
            "$0"
        ],
        "description": "Computes an exclusive prefix sum (or other binary operation) over a range. The i-th element of the output is the result of applying the binary operation to the initial value and the first i-1 elements of the input range. The first element of the output is always the initial value. Time complexity: O(n) applications of the binary operation. Link: https://en.cppreference.com/w/cpp/numeric/exclusive_scan"
    },
    "cpp_numeric__inclusive_scan": {
        "prefix": "cpp_numeric__inclusive_scan",
        "body": [
            "// std::inclusive_scan - Computes an inclusive prefix sum (C++17)",
            "// Reference: https://en.cppreference.com/w/cpp/numeric/inclusive_scan",
            "#include <numeric>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> in = {1, 2, 3, 4, 5};",
            "std::vector<int> out(in.size());",
            "",
            "// Inclusive scan (default: addition)",
            "// out[0] = in[0]",
            "// out[i] = out[i-1] + in[i]",
            "std::inclusive_scan(in.begin(), in.end(), out.begin());",
            "",
            "std::cout << \"Original: \";",
            "for (int x : in) std::cout << x << \" \";",
            "std::cout << std::endl;",
            "",
            "std::cout << \"Inclusive scan (sum): \";",
            "for (int x : out) std::cout << x << \" \";",
            "std::cout << std::endl; // Inclusive scan (sum): 1 3 6 10 15",
            "",
            "// Inclusive scan with custom operation (e.g., multiplication)",
            "std::vector<int> out_prod(in.size());",
            "std::inclusive_scan(in.begin(), in.end(), out_prod.begin(), std::multiplies<int>());",
            "",
            "std::cout << \"Inclusive scan (product): \";",
            "for (int x : out_prod) std::cout << x << \" \";",
            "std::cout << std::endl; // Inclusive scan (product): 1 2 6 24 120",
            "",
            "// Inclusive scan with initial value",
            "std::vector<int> out_init(in.size());",
            "std::inclusive_scan(in.begin(), in.end(), out_init.begin(), std::plus<int>(), 100);",
            "",
            "std::cout << \"Inclusive scan (sum, init 100): \";",
            "for (int x : out_init) std::cout << x << \" \";",
            "std::cout << std::endl; // Inclusive scan (sum, init 100): 101 103 106 110 115",
            "$0"
        ],
        "description": "Computes an inclusive prefix sum (or other binary operation) over a range. The i-th element of the output is the result of applying the binary operation to the first i elements of the input range. The first element of the output is the first element of the input. Supports custom binary operations and an optional initial value. Time complexity: O(n) applications of the binary operation. Link: https://en.cppreference.com/w/cpp/numeric/inclusive_scan"
    },
    "cpp_numeric__transform_reduce": {
        "prefix": "cpp_numeric__transform_reduce",
        "body": [
            "// std::transform_reduce - Transform and reduce range (C++17)",
            "// Reference: https://en.cppreference.com/w/cpp/numeric/transform_reduce",
            "#include <numeric>",
            "#include <vector>",
            "#include <iostream>",
            "#include <functional>",
            "",
            "std::vector<int> v1 = {1, 2, 3, 4, 5};",
            "std::vector<int> v2 = {10, 20, 30, 40, 50};",
            "",
            "// Transform and reduce: sum of squares",
            "// (1*1) + (2*2) + (3*3) + (4*4) + (5*5) = 1 + 4 + 9 + 16 + 25 = 55",
            "int sum_of_squares = std::transform_reduce(v1.begin(), v1.end(), 0,",
            "                                           std::plus<int>(),",
            "                                           [](int x){ return x * x; });",
            "std::cout << \"Sum of squares: \" << sum_of_squares << std::endl; // 55",
            "",
            "// Transform and reduce: inner product (equivalent to std::inner_product)",
            "// (1*10) + (2*20) + (3*30) + (4*40) + (5*50) = 10 + 40 + 90 + 160 + 250 = 550",
            "int inner_prod = std::transform_reduce(v1.begin(), v1.end(), v2.begin(), 0);",
            "std::cout << \"Inner product (using transform_reduce): \" << inner_prod << std::endl; // 550",
            "",
            "// Custom transform and reduce: sum of absolute differences",
            "// |1-10| + |2-20| + |3-30| + |4-40| + |5-50| = 9 + 18 + 27 + 36 + 45 = 135",
            "int sum_abs_diff = std::transform_reduce(v1.begin(), v1.end(), v2.begin(), 0,",
            "                                         std::plus<int>(),",
            "                                         [](int x, int y){ return std::abs(x - y); });",
            "std::cout << \"Sum of absolute differences: \" << sum_abs_diff << std::endl; // 135",
            "$0"
        ],
        "description": "Applies a transformation to each element (or pair of elements from two ranges) and then reduces the results using a binary operation. It's a generalization of std::accumulate and std::inner_product. Supports custom transformation and reduction operations. Can be parallelized with execution policies. Time complexity: O(n) applications of the transformation and reduction operations. Link: https://en.cppreference.com/w/cpp/numeric/transform_reduce"
    },
    "cpp_numeric__gcd": {
        "prefix": "cpp_numeric__gcd",
        "body": [
            "// std::gcd - Greatest common divisor (C++17)",
            "// Reference: https://en.cppreference.com/w/cpp/numeric/gcd",
            "#include <numeric>",
            "#include <iostream>",
            "",
            "// Basic usage",
            "int g1 = std::gcd(12, 18);",
            "std::cout << \"GCD(12, 18): \" << g1 << std::endl; // 6",
            "",
            "int g2 = std::gcd(35, 10);",
            "std::cout << \"GCD(35, 10): \" << g2 << std::endl; // 5",
            "",
            "int g3 = std::gcd(7, 13);",
            "std::cout << \"GCD(7, 13): \" << g3 << std::endl; // 1 (coprime)",
            "",
            "// One argument is zero",
            "int g4 = std::gcd(0, 5);",
            "std::cout << \"GCD(0, 5): \" << g4 << std::endl; // 5",
            "",
            "int g5 = std::gcd(10, 0);",
            "std::cout << \"GCD(10, 0): \" << g5 << std::endl; // 10",
            "",
            "int g6 = std::gcd(0, 0);",
            "std::cout << \"GCD(0, 0): \" << g6 << std::endl; // 0",
            "",
            "// Negative numbers (result is always non-negative)",
            "int g7 = std::gcd(-12, 18);",
            "std::cout << \"GCD(-12, 18): \" << g7 << std::endl; // 6",
            "",
            "int g8 = std::gcd(-12, -18);",
            "std::cout << \"GCD(-12, -18): \" << g8 << std::endl; // 6",
            "$0"
        ],
        "description": "Computes the greatest common divisor (GCD) of two integers. The result is always non-negative. If both arguments are zero, the result is zero. Time complexity: Logarithmic in the values of the arguments. Link: https://en.cppreference.com/w/cpp/numeric/gcd"
    },
    "cpp_numeric__lcm": {
        "prefix": "cpp_numeric__lcm",
        "body": [
            "// std::lcm - Least common multiple (C++17)",
            "// Reference: https://en.cppreference.com/w/cpp/numeric/lcm",
            "#include <numeric>",
            "#include <iostream>",
            "",
            "// Basic usage",
            "int l1 = std::lcm(12, 18);",
            "std::cout << \"LCM(12, 18): \" << l1 << std::endl; // 36",
            "",
            "int l2 = std::lcm(7, 13);",
            "std::cout << \"LCM(7, 13): \" << l2 << std::endl; // 91 (coprime)",
            "",
            "int l3 = std::lcm(4, 6);",
            "std::cout << \"LCM(4, 6): \" << l3 << std::endl; // 12",
            "",
            "// One argument is zero (result is zero)",
            "int l4 = std::lcm(0, 5);",
            "std::cout << \"LCM(0, 5): \" << l4 << std::endl; // 0",
            "",
            "int l5 = std::lcm(10, 0);",
            "std::cout << \"LCM(10, 0): \" << l5 << std::endl; // 0",
            "",
            "int l6 = std::lcm(0, 0);",
            "std::cout << \"LCM(0, 0): \" << l6 << std::endl; // 0",
            "",
            "// Negative numbers (result is always non-negative)",
            "int l7 = std::lcm(-12, 18);",
            "std::cout << \"LCM(-12, 18): \" << l7 << std::endl; // 36",
            "",
            "int l8 = std::lcm(-12, -18);",
            "std::cout << \"LCM(-12, -18): \" << l8 << std::endl; // 36",
            "$0"
        ],
        "description": "Computes the least common multiple (LCM) of two integers. The result is always non-negative. If either argument is zero, the result is zero. Time complexity: Logarithmic in the values of the arguments. Link: https://en.cppreference.com/w/cpp/numeric/lcm"
    },
    "cpp_raw_memory__uninitialized_copy": {
        "prefix": "cpp_raw_memory__uninitialized_copy",
        "body": [
            "// std::uninitialized_copy - Copy elements to uninitialized memory (C++11)",
            "// Reference: https://en.cppreference.com/w/cpp/memory/uninitialized_copy",
            "#include <memory>",
            "#include <vector>",
            "#include <iostream>",
            "#include <string>",
            "",
            "// Example with integers",
            "std::vector<int> source = {1, 2, 3, 4, 5};",
            "// Allocate raw memory for 5 integers",
            "int* dest_raw = static_cast<int*>(::operator new(sizeof(int) * source.size()));",
            "",
            "try {",
            "    // Copy elements from source to uninitialized dest_raw",
            "    // This constructs elements in dest_raw using copy constructor",
            "    std::uninitialized_copy(source.begin(), source.end(), dest_raw);",
            "",
            "    std::cout << \"Copied integers: \";",
            "    for (size_t i = 0; i < source.size(); ++i) {",
            "        std::cout << dest_raw[i] << \" \";",
            "    }",
            "    std::cout << std::endl;",
            "",
            "} catch (...) {",
            "    // Handle exceptions during construction",
            "}",
            "",
            "// Remember to destroy objects and deallocate memory",
            "for (size_t i = 0; i < source.size(); ++i) {",
            "    std::destroy_at(dest_raw + i); // C++17",
            "}",
            "::operator delete(dest_raw, sizeof(int) * source.size());",
            "",
            "// Example with strings (more complex objects)",
            "std::vector<std::string> str_source = {\"hello\", \"world\", \"cpp\"};",
            "std::string* str_dest_raw = static_cast<std::string*>(::operator new(sizeof(std::string) * str_source.size()));",
            "",
            "try {",
            "    std::uninitialized_copy(str_source.begin(), str_source.end(), str_dest_raw);",
            "",
            "    std::cout << \"Copied strings: \";",
            "    for (size_t i = 0; i < str_source.size(); ++i) {",
            "        std::cout << str_dest_raw[i] << \" \";",
            "    }",
            "    std::cout << std::endl;",
            "",
            "} catch (...) {",
            "    // Proper cleanup in case of exception during construction",
            "    // Need to destroy already constructed objects before rethrowing",
            "    for (size_t i = 0; i < str_source.size(); ++i) {",
            "        std::destroy_at(str_dest_raw + i);",
            "    }",
            "}",
            "for (size_t i = 0; i < str_source.size(); ++i) {",
            "    std::destroy_at(str_dest_raw + i);",
            "}",
            "::operator delete(str_dest_raw, sizeof(std::string) * str_source.size());",
            "$0"
        ],
        "description": "Copies elements from a source range to a destination range of uninitialized memory. It constructs new objects in the destination using the copy constructor. Useful for placement new scenarios or custom memory management. Time complexity: O(n) copy constructions. Link: https://en.cppreference.com/w/cpp/memory/uninitialized_copy"
    },
    "cpp_raw_memory__uninitialized_fill": {
        "prefix": "cpp_raw_memory__uninitialized_fill",
        "body": [
            "// std::uninitialized_fill - Fill uninitialized memory with copies of a value (C++11)",
            "// Reference: https://en.cppreference.com/w/cpp/memory/uninitialized_fill",
            "#include <memory>",
            "#include <vector>",
            "#include <iostream>",
            "#include <string>",
            "",
            "// Allocate raw memory for 5 strings",
            "std::string* str_raw = static_cast<std::string*>(::operator new(sizeof(std::string) * 5));",
            "",
            "try {",
            "    // Fill uninitialized memory with copies of \"test\"",
            "    std::uninitialized_fill(str_raw, str_raw + 5, std::string(\"test\"));",
            "",
            "    std::cout << \"Filled strings: \";",
            "    for (size_t i = 0; i < 5; ++i) {",
            "        std::cout << str_raw[i] << \" \";",
            "    }",
            "    std::cout << std::endl; // Filled strings: test test test test test",
            "",
            "} catch (...) {",
            "    // Proper cleanup in case of exception during construction",
            "    // Need to destroy already constructed objects before rethrowing",
            "    // (This example is simplified; real code needs to track constructed count)",
            "}",
            "",
            "// Remember to destroy objects and deallocate memory",
            "for (size_t i = 0; i < 5; ++i) {",
            "    std::destroy_at(str_raw + i); // C++17",
            "}",
            "::operator delete(str_raw, sizeof(std::string) * 5);",
            "",
            "// Example with integers (trivial type, no special construction needed)",
            "int* int_raw = static_cast<int*>(::operator new(sizeof(int) * 3));",
            "std::uninitialized_fill(int_raw, int_raw + 3, 42);",
            "std::cout << \"Filled integers: \";",
            "for (size_t i = 0; i < 3; ++i) {",
            "    std::cout << int_raw[i] << \" \";",
            "}",
            "std::cout << std::endl; // Filled integers: 42 42 42",
            "::operator delete(int_raw, sizeof(int) * 3);",
            "$0"
        ],
        "description": "Fills a range of uninitialized memory with copies of a provided value. It constructs new objects in the destination using the copy constructor. Useful for initializing raw memory buffers. Time complexity: O(n) copy constructions. Link: https://en.cppreference.com/w/cpp/memory/uninitialized_fill"
    },
    "cpp_raw_memory__uninitialized_move": {
        "prefix": "cpp_raw_memory__uninitialized_move",
        "body": [
            "// std::uninitialized_move - Move elements to uninitialized memory (C++11)",
            "// Reference: https://en.cppreference.com/w/cpp/memory/uninitialized_move",
            "#include <memory>",
            "#include <vector>",
            "#include <iostream>",
            "#include <string>",
            "",
            "// Example with strings",
            "std::vector<std::string> source = {\"apple\", \"banana\", \"cherry\"};",
            "// Allocate raw memory for 3 strings",
            "std::string* dest_raw = static_cast<std::string*>(::operator new(sizeof(std::string) * source.size()));",
            "",
            "std::cout << \"Original source: \";",
            "for (const auto& s : source) std::cout << \"'\" << s << \"' \";",
            "std::cout << std::endl;",
            "",
            "try {",
            "    // Move elements from source to uninitialized dest_raw",
            "    // This constructs elements in dest_raw using move constructor",
            "    std::uninitialized_move(source.begin(), source.end(), dest_raw);",
            "",
            "    std::cout << \"Moved strings to raw memory: \";",
            "    for (size_t i = 0; i < source.size(); ++i) {",
            "        std::cout << \"'\" << dest_raw[i] << \"' \";",
            "    }",
            "    std::cout << std::endl; // Moved strings to raw memory: 'apple' 'banana' 'cherry'",
            "",
            "    // Source elements are now in a valid but unspecified state (often empty)",
            "    std::cout << \"Source after move: \";",
            "    for (const auto& s : source) std::cout << \"'\" << s << \"' \";",
            "    std::cout << std::endl; // Source after move: '' '' '' (or similar)",
            "",
            "} catch (...) {",
            "    // Proper cleanup in case of exception during construction",
            "    // Need to destroy already constructed objects before rethrowing",
            "}",
            "",
            "// Remember to destroy objects and deallocate memory",
            "for (size_t i = 0; i < source.size(); ++i) {",
            "    std::destroy_at(dest_raw + i);",
            "}",
            "::operator delete(dest_raw, sizeof(std::string) * source.size());",
            "$0"
        ],
        "description": "Moves elements from a source range to a destination range of uninitialized memory. It constructs new objects in the destination using the move constructor, potentially leaving source elements in a valid but unspecified state. Useful for efficient transfer of resources. Time complexity: O(n) move constructions. Link: https://en.cppreference.com/w/cpp/memory/uninitialized_move"
    },
    "cpp_raw_memory__destroy": {
        "prefix": "cpp_raw_memory__destroy",
        "body": [
            "// std::destroy - Destroys objects in a range (C++17)",
            "// Reference: https://en.cppreference.com/w/cpp/memory/destroy",
            "#include <memory>",
            "#include <vector>",
            "#include <iostream>",
            "#include <string>",
            "",
            "struct MyObject {",
            "    std::string name;",
            "    MyObject(const std::string& n) : name(n) {",
            "        std::cout << \"Constructing MyObject: \" << name << std::endl;",
            "    }",
            "    ~MyObject() {",
            "        std::cout << \"Destroying MyObject: \" << name << std::endl;",
            "    }",
            "};",
            "",
            "int main() {",
            "    // Allocate raw memory for 3 MyObjects",
            "    MyObject* raw_mem = static_cast<MyObject*>(::operator new(sizeof(MyObject) * 3));",
            "",
            "    // Construct objects in raw memory using placement new",
            "    new (raw_mem + 0) MyObject(\"One\");",
            "    new (raw_mem + 1) MyObject(\"Two\");",
            "    new (raw_mem + 2) MyObject(\"Three\");",
            "",
            "    std::cout << \"Objects constructed. Now destroying...\" << std::endl;",
            "",
            "    // Destroy the objects in the raw memory range",
            "    std::destroy(raw_mem, raw_mem + 3);",
            "",
            "    std::cout << \"Objects destroyed. Now deallocating memory.\" << std::endl;",
            "",
            "    // Deallocate the raw memory",
            "    ::operator delete(raw_mem, sizeof(MyObject) * 3);",
            "",
            "    return 0;",
            "}",
            "$0"
        ],
        "description": "Calls the destructors for all objects in a specified range of memory. This does not deallocate the memory itself, only destroys the objects. Useful for managing objects in raw memory buffers. Time complexity: O(n) destructor calls. Link: https://en.cppreference.com/w/cpp/memory/destroy"
    },
    "cpp_raw_memory__destroy_at": {
        "prefix": "cpp_raw_memory__destroy_at",
        "body": [
            "// std::destroy_at - Destroys an object at a specific location (C++17)",
            "// Reference: https://en.cppreference.com/w/cpp/memory/destroy_at",
            "#include <memory>",
            "#include <iostream>",
            "#include <string>",
            "",
            "struct MyObject {",
            "    std::string name;",
            "    MyObject(const std::string& n) : name(n) {",
            "        std::cout << \"Constructing MyObject: \" << name << std::endl;",
            "    }",
            "    ~MyObject() {",
            "        std::cout << \"Destroying MyObject: \" << name << std::endl;",
            "    }",
            "};",
            "",
            "int main() {",
            "    // Allocate raw memory for one MyObject",
            "    MyObject* raw_mem = static_cast<MyObject*>(::operator new(sizeof(MyObject)));",
            "",
            "    // Construct object in raw memory using placement new",
            "    new (raw_mem) MyObject(\"SingleObject\");",
            "",
            "    std::cout << \"Object constructed. Now destroying at location.\" << std::endl;",
            "",
            "    // Destroy the object at the specific memory location",
            "    std::destroy_at(raw_mem);",
            "",
            "    std::cout << \"Object destroyed. Now deallocating memory.\" << std::endl;",
            "",
            "    // Deallocate the raw memory",
            "    ::operator delete(raw_mem, sizeof(MyObject));",
            "",
            "    return 0;",
            "}",
            "$0"
        ],
        "description": "Calls the destructor for the object pointed to by the given pointer. This does not deallocate the memory. Useful for precise destruction of objects in raw memory. Time complexity: O(1) destructor call. Link: https://en.cppreference.com/w/cpp/memory/destroy_at"
    },
    "cpp_raw_memory__destroy_n": {
        "prefix": "cpp_raw_memory__destroy_n",
        "body": [
            "// std::destroy_n - Destroys n objects starting from a location (C++17)",
            "// Reference: https://en.cppreference.com/w/cpp/memory/destroy_n",
            "#include <memory>",
            "#include <vector>",
            "#include <iostream>",
            "#include <string>",
            "",
            "struct MyObject {",
            "    std::string name;",
            "    MyObject(const std::string& n) : name(n) {",
            "        std::cout << \"Constructing MyObject: \" << name << std::endl;",
            "    }",
            "    ~MyObject() {",
            "        std::cout << \"Destroying MyObject: \" << name << std::endl;",
            "    }",
            "};",
            "",
            "int main() {",
            "    // Allocate raw memory for 5 MyObjects",
            "    MyObject* raw_mem = static_cast<MyObject*>(::operator new(sizeof(MyObject) * 5));",
            "",
            "    // Construct objects in raw memory",
            "    new (raw_mem + 0) MyObject(\"Alpha\");",
            "    new (raw_mem + 1) MyObject(\"Beta\");",
            "    new (raw_mem + 2) MyObject(\"Gamma\");",
            "    new (raw_mem + 3) MyObject(\"Delta\");",
            "    new (raw_mem + 4) MyObject(\"Epsilon\");",
            "",
            "    std::cout << \"Objects constructed. Now destroying first 3...\" << std::endl;",
            "",
            "    // Destroy the first 3 objects",
            "    std::destroy_n(raw_mem, 3);",
            "",
            "    std::cout << \"First 3 objects destroyed. Now destroying remaining 2.\" << std::endl;",
            "",
            "    // Destroy the remaining 2 objects",
            "    std::destroy_n(raw_mem + 3, 2);",
            "",
            "    std::cout << \"All objects destroyed. Now deallocating memory.\" << std::endl;",
            "",
            "    // Deallocate the raw memory",
            "    ::operator delete(raw_mem, sizeof(MyObject) * 5);",
            "",
            "    return 0;",
            "}",
            "$0"
        ],
        "description": "Calls the destructors for n objects starting from a given memory location. This does not deallocate the memory. Useful for destroying a specific number of objects in a raw memory buffer. Time complexity: O(n) destructor calls. Link: https://en.cppreference.com/w/cpp/memory/destroy_n"
    },
    "cpp_algorithm__shift_left": {
        "prefix": "cpp_algorithm__shift_left",
        "body": [
            "// std::shift_left - Shifts elements to the left (C++20)",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/shift_left",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> v = {1, 2, 3, 4, 5};",
            "",
            "std::cout << \"Original: \";",
            "for (int x : v) std::cout << x << \" \";",
            "std::cout << std::endl;",
            "",
            "// Shift left by 2 positions",
            "// Elements {1, 2} are discarded, {3, 4, 5} move to front",
            "// Remaining elements are default-constructed or left in unspecified state",
            "std::shift_left(v.begin(), v.end(), 2);",
            "",
            "std::cout << \"Shifted left by 2: \";",
            "for (int x : v) std::cout << x << \" \";",
            "std::cout << std::endl; // Shifted left by 2: 3 4 5 0 0 (or garbage for non-POD types)",
            "",
            "// Example with strings",
            "std::vector<std::string> words = {\"apple\", \"banana\", \"cherry\", \"date\"};",
            "std::shift_left(words.begin(), words.end(), 1);",
            "std::cout << \"Shifted strings left by 1: \";",
            "for (const std::string& s : words) std::cout << \"'\" << s << \"' \";",
            "std::cout << std::endl; // Shifted strings left by 1: 'banana' 'cherry' 'date' ''",
            "",
            "// Shifting by count >= range size results in empty range",
            "std::vector<int> v2 = {1, 2, 3};",
            "std::shift_left(v2.begin(), v2.end(), 3);",
            "std::cout << \"Shifted left by 3: \";",
            "for (int x : v2) std::cout << x << \" \";",
            "std::cout << std::endl; // Shifted left by 3: 0 0 0",
            "$0"
        ],
        "description": "Shifts elements in a range to the left by n positions. The first n elements are discarded. The remaining elements are moved to the beginning of the range. The elements at the end of the range are left in a valid but unspecified state (for non-trivial types, they are typically default-constructed or zero-initialized for POD types). Time complexity: O(n) moves. Link: https://en.cppreference.com/w/cpp/algorithm/shift_left"
    },
    "cpp_algorithm__shift_right": {
        "prefix": "cpp_algorithm__shift_right",
        "body": [
            "// std::shift_right - Shifts elements to the right (C++20)",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/shift_right",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> v = {1, 2, 3, 4, 5};",
            "",
            "std::cout << \"Original: \";",
            "for (int x : v) std::cout << x << \" \";",
            "std::cout << std::endl;",
            "",
            "// Shift right by 2 positions",
            "// Elements {1, 2, 3} move to {3, 4, 5} positions",
            "// First 2 elements are default-constructed or left in unspecified state",
            "std::shift_right(v.begin(), v.end(), 2);",
            "",
            "std::cout << \"Shifted right by 2: \";",
            "for (int x : v) std::cout << x << \" \";",
            "std::cout << std::endl; // Shifted right by 2: 0 0 1 2 3 (or garbage for non-POD types)",
            "",
            "// Example with strings",
            "std::vector<std::string> words = {\"apple\", \"banana\", \"cherry\", \"date\"};",
            "std::shift_right(words.begin(), words.end(), 1);",
            "std::cout << \"Shifted strings right by 1: \";",
            "for (const std::string& s : words) std::cout << \"'\" << s << \"' \";",
            "std::cout << std::endl; // Shifted strings right by 1: '' 'apple' 'banana' 'cherry'",
            "",
            "// Shifting by count >= range size results in empty range",
            "std::vector<int> v2 = {1, 2, 3};",
            "std::shift_right(v2.begin(), v2.end(), 3);",
            "std::cout << \"Shifted right by 3: \";",
            "for (int x : v2) std::cout << x << \" \";",
            "std::cout << std::endl; // Shifted right by 3: 0 0 0",
            "$0"
        ],
        "description": "Shifts elements in a range to the right by n positions. The last n elements are discarded. The remaining elements are moved towards the end of the range. The elements at the beginning of the range are left in a valid but unspecified state (for non-trivial types, they are typically default-constructed or zero-initialized for POD types). Time complexity: O(n) moves. Link: https://en.cppreference.com/w/cpp/algorithm/shift_right"
    },
    "cpp_string__starts_with": {
        "prefix": "cpp_string__starts_with",
        "body": [
            "// std::string::starts_with - Check if string starts with prefix (C++20)",
            "// Reference: https://en.cppreference.com/w/cpp/string/basic_string/starts_with",
            "#include <string>",
            "#include <iostream>",
            "",
            "std::string s = \"hello world\";",
            "",
            "// Check with char",
            "bool starts_h = s.starts_with('h');",
            "std::cout << \"'hello world' starts with 'h': \" << std::boolalpha << starts_h << std::endl; // true",
            "",
            "// Check with string literal",
            "bool starts_hello = s.starts_with(\"hello\");",
            "std::cout << \"'hello world' starts with \"hello\": \" << std::boolalpha << starts_hello << std::endl; // true",
            "",
            "// Check with std::string_view",
            "std::string_view prefix = \"world\";",
            "bool starts_world = s.starts_with(prefix);",
            "std::cout << \"'hello world' starts with \"world\": \" << std::boolalpha << starts_world << std::endl; // false",
            "",
            "// Case-sensitive",
            "bool starts_H = s.starts_with('H');",
            "std::cout << \"'hello world' starts with 'H': \" << std::boolalpha << starts_H << std::endl; // false",
            "",
            "// Empty string prefix",
            "bool starts_empty = s.starts_with(\"\");",
            "std::cout << \"'hello world' starts with empty string: \" << std::boolalpha << starts_empty << std::endl; // true",
            "$0"
        ],
        "description": "Checks if a string (or string_view) begins with a specified prefix. Overloaded for char, string literal, and string_view. Case-sensitive. Time complexity: O(length of prefix). Link: https://en.cppreference.com/w/cpp/string/basic_string/starts_with"
    },
    "cpp_string__ends_with": {
        "prefix": "cpp_string__ends_with",
        "body": [
            "// std::string::ends_with - Check if string ends with suffix (C++20)",
            "// Reference: https://en.cppreference.com/w/cpp/string/basic_string/ends_with",
            "#include <string>",
            "#include <iostream>",
            "",
            "std::string s = \"hello world\";",
            "",
            "// Check with char",
            "bool ends_d = s.ends_with('d');",
            "std::cout << \"'hello world' ends with 'd': \" << std::boolalpha << ends_d << std::endl; // true",
            "",
            "// Check with string literal",
            "bool ends_world = s.ends_with(\"world\");",
            "std::cout << \"'hello world' ends with \"world\": \" << std::boolalpha << ends_world << std::endl; // true",
            "",
            "// Check with std::string_view",
            "std::string_view suffix = \"hello\";",
            "bool ends_hello = s.ends_with(suffix);",
            "std::cout << \"'hello world' ends with \"hello\": \" << std::boolalpha << ends_hello << std::endl; // false",
            "",
            "// Case-sensitive",
            "bool ends_D = s.ends_with('D');",
            "std::cout << \"'hello world' ends with 'D': \" << std::boolalpha << ends_D << std::endl; // false",
            "",
            "// Empty string suffix",
            "bool ends_empty = s.ends_with(\"\");",
            "std::cout << \"'hello world' ends with empty string: \" << std::boolalpha << ends_empty << std::endl; // true",
            "$0"
        ],
        "description": "Checks if a string (or string_view) ends with a specified suffix. Overloaded for char, string literal, and string_view. Case-sensitive. Time complexity: O(length of suffix). Link: https://en.cppreference.com/w/cpp/string/basic_string/ends_with"
    },
    "cpp_algorithm__contains": {
        "prefix": "cpp_algorithm__contains",
        "body": [
            "// std::ranges::contains - Check if range contains element (C++23)",
            "// Reference: https://en.cppreference.com/w/cpp/algorithm/ranges/contains",
            "#include <algorithm>",
            "#include <vector>",
            "#include <iostream>",
            "",
            "std::vector<int> v = {1, 2, 3, 4, 5};",
            "",
            "// Check if value exists",
            "bool has_3 = std::ranges::contains(v, 3);",
            "std::cout << \"Vector contains 3: \" << std::boolalpha << has_3 << std::endl; // true",
            "",
            "bool has_9 = std::ranges::contains(v, 9);",
            "std::cout << \"Vector contains 9: \" << std::boolalpha << has_9 << std::endl; // false",
            "",
            "// Check if sub-range exists",
            "std::vector<int> sub1 = {2, 3};",
            "bool has_sub1 = std::ranges::contains(v, sub1);",
            "std::cout << \"Vector contains {2, 3}: \" << std::boolalpha << has_sub1 << std::endl; // true",
            "",
            "std::vector<int> sub2 = {3, 5};",
            "bool has_sub2 = std::ranges::contains(v, sub2);",
            "std::cout << \"Vector contains {3, 5}: \" << std::boolalpha << has_sub2 << std::endl; // false",
            "",
            "// With custom predicate",
            "auto is_even = [](int n) { return n % 2 == 0; };",
            "// Check if any even number exists (equivalent to std::any_of)",
            "bool has_even = std::ranges::contains(v, 0, std::equal_to<int>(), is_even);",
            "// Note: std::ranges::contains with a projection and value is for checking if a transformed value exists.",
            "// For checking if *any* element satisfies a predicate, std::ranges::any_of is more direct.",
            "// The above example is conceptually flawed for 'any_of' use case.",
            "// Correct use for contains with predicate: check if a specific transformed value exists.",
            "// E.g., check if any element's square is 9",
            "bool has_square_9 = std::ranges::contains(v, 9, {}, [](int n){ return n * n; });",
            "std::cout << \"Vector contains element whose square is 9: \" << std::boolalpha << has_square_9 << std::endl; // true (for 3)",
            "$0"
        ],
        "description": "Checks if a range contains a specific value or a sub-range. For a single value, it uses `std::find`. For a sub-range, it uses `std::search`. Supports custom predicates and projections. Time complexity: O(N) for single value, O(N*M) for sub-range (where M is sub-range size). Link: https://en.cppreference.com/w/cpp/algorithm/ranges/contains"
    },
    "cpp_container__ssize": {
        "prefix": "cpp_container__ssize",
        "body": [
            "// std::ssize - Signed size of a container or array (C++17)",
            "// Reference: https://en.cppreference.com/w/cpp/iterator/ssize",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <iterator>",
            "",
            "std::vector<int> v = {1, 2, 3, 4, 5};",
            "std::string s = \"hello\";",
            "int arr[] = {10, 20, 30};",
            "",
            "// Get signed size of vector",
            "auto vec_size = std::ssize(v);",
            "std::cout << \"Vector size (signed): \" << vec_size << std::endl; // 5",
            "std::cout << \"Type of vec_size: \" << typeid(vec_size).name() << std::endl; // long or long long",
            "",
            "// Get signed size of string",
            "auto str_size = std::ssize(s);",
            "std::cout << \"String size (signed): \" << str_size << std::endl; // 5",
            "",
            "// Get signed size of C-style array",
            "auto arr_size = std::ssize(arr);",
            "std::cout << \"Array size (signed): \" << arr_size << std::endl; // 3",
            "",
            "// Useful for avoiding signed/unsigned comparison warnings",
            "for (long long i = 0; i < std::ssize(v); ++i) {",
            "    // Safe loop without warnings",
            "}",
            "",
            "// Can be used with empty containers",
            "std::vector<double> empty_v;",
            "auto empty_size = std::ssize(empty_v);",
            "std::cout << \"Empty vector size (signed): \" << empty_size << std::endl; // 0",
            "$0"
        ],
        "description": "Returns the signed size of a container or C-style array. This is useful for avoiding signed/unsigned comparison warnings and errors when iterating or performing arithmetic with sizes. Returns a signed integer type (e.g., std::ptrdiff_t). Time complexity: O(1). Link: https://en.cppreference.com/w/cpp/iterator/ssize"
    },
    "cpp_numeric__midpoint": {
        "prefix": "cpp_numeric__midpoint",
        "body": [
            "// std::midpoint - Computes the midpoint of two values (C++20)",
            "// Reference: https://en.cppreference.com/w/cpp/numeric/midpoint",
            "#include <numeric>",
            "#include <iostream>",
            "#include <limits>",
            "",
            "// Integers",
            "int i1 = std::midpoint(10, 20);",
            "std::cout << \"Midpoint(10, 20): \" << i1 << std::endl; // 15",
            "",
            "int i2 = std::midpoint(10, 21);",
            "std::cout << \"Midpoint(10, 21): \" << i2 << std::endl; // 15 (truncates towards zero)",
            "",
            "int i3 = std::midpoint(-10, 20);",
            "std::cout << \"Midpoint(-10, 20): \" << i3 << std::endl; // 5",
            "",
            "int i4 = std::midpoint(-10, -20);",
            "std::cout << \"Midpoint(-10, -20): \" << i4 << std::endl; // -15",
            "",
            "// Floating-point numbers",
            "double d1 = std::midpoint(10.0, 20.0);",
            "std::cout << \"Midpoint(10.0, 20.0): \" << d1 << std::endl; // 15.0",
            "",
            "double d2 = std::midpoint(10.0, 21.0);",
            "std::cout << \"Midpoint(10.0, 21.0): \" << d2 << std::endl; // 15.5",
            "",
            "// Handles overflow for integers safely",
            "// long long max_val = std::numeric_limits<long long>::max();",
            "// long long min_val = std::numeric_limits<long long>::min();",
            "// long long mid_overflow = std::midpoint(max_val - 1, max_val); // No overflow",
            "",
            "// Pointers (midpoint of two pointers to elements in the same array)",
            "int arr[] = {10, 20, 30, 40, 50};",
            "int* p1 = arr;",
            "int* p2 = arr + 4;",
            "int* mid_p = std::midpoint(p1, p2);",
            "std::cout << \"Midpoint of pointers: \" << *mid_p << std::endl; // 30",
            "$0"
        ],
        "description": "Computes the midpoint of two values of the same type. For integers, it performs the calculation in a way that avoids overflow and truncates towards zero. For floating-point types, it computes the average. It also supports computing the midpoint of two pointers within the same array. Time complexity: O(1). Link: https://en.cppreference.com/w/cpp/numeric/midpoint"
    },
    "cpp_numeric__lerp": {
        "prefix": "cpp_numeric__lerp",
        "body": [
            "// std::lerp - Linear interpolation (C++20)",
            "// Reference: https://en.cppreference.com/w/cpp/numeric/lerp",
            "#include <numeric>",
            "#include <iostream>",
            "#include <cmath>",
            "",
            "// Basic linear interpolation",
            "double start = 0.0;",
            "double end = 100.0;",
            "",
            "// t = 0.0 -> returns start",
            "double val0 = std::lerp(start, end, 0.0);",
            "std::cout << \"lerp(0, 100, 0.0): \" << val0 << std::endl; // 0.0",
            "",
            "// t = 0.5 -> returns midpoint",
            "double val0_5 = std::lerp(start, end, 0.5);",
            "std::cout << \"lerp(0, 100, 0.5): \" << val0_5 << std::endl; // 50.0",
            "",
            "// t = 1.0 -> returns end",
            "double val1 = std::lerp(start, end, 1.0);",
            "std::cout << \"lerp(0, 100, 1.0): \" << val1 << std::endl; // 100.0",
            "",
            "// t outside [0, 1] range (extrapolation)",
            "double val_neg = std::lerp(start, end, -0.2);",
            "std::cout << \"lerp(0, 100, -0.2): \" << val_neg << std::endl; // -20.0",
            "",
            "double val_over = std::lerp(start, end, 1.2);",
            "std::cout << \"lerp(0, 100, 1.2): \" << val_over << std::endl; // 120.0",
            "",
            "// Interpolating colors (example with float components)",
            "struct Color { float r, g, b; };",
            "Color c1 = {1.0f, 0.0f, 0.0f}; // Red",
            "Color c2 = {0.0f, 0.0f, 1.0f}; // Blue",
            "",
            "float t = 0.25f;",
            "Color interpolated_color = {",
            "    std::lerp(c1.r, c2.r, t),",
            "    std::lerp(c1.g, c2.g, t),",
            "    std::lerp(c1.b, c2.b, t)",
            "};",
            "std::cout << \"Interpolated color (t=0.25): R=\" << interpolated_color.r",
            "          << \", G=\" << interpolated_color.g << \", B=\" << interpolated_color.b << std::endl;",
            "// Output: R=0.75, G=0, B=0.25",
            "$0"
        ],
        "description": "Performs linear interpolation between two values a and b, using a weight t. The formula is a + t * (b - a). If t is between 0 and 1, the result is between a and b. If t is outside this range, it performs extrapolation. Supports floating-point types. Time complexity: O(1). Link: https://en.cppreference.com/w/cpp/numeric/lerp"
    },
    "cpp_numeric__countl_zero": {
        "prefix": "cpp_numeric__countl_zero",
        "body": [
            "// std::countl_zero - Count leading zero bits (C++20)",
            "// Reference: https://en.cppreference.com/w/cpp/numeric/countl_zero",
            "#include <bit>",
            "#include <iostream>",
            "#include <limits>",
            "",
            "// For unsigned integers",
            "unsigned int u1 = 0b00001010u; // 10 in binary",
            "int zeros1 = std::countl_zero(u1);",
            "// Assuming 32-bit unsigned int, total bits - (log2(10) + 1) = 32 - 4 = 28",
            "std::cout << \"Leading zeros in 0b00001010u (10): \" << zeros1 << std::endl; // 28 (for 32-bit int)",
            "",
            "unsigned int u2 = 0b10000000u; // 128",
            "int zeros2 = std::countl_zero(u2);",
            "std::cout << \"Leading zeros in 0b10000000u (128): \" << zeros2 << std::endl; // 24 (for 32-bit int)",
            "",
            "unsigned int u3 = 0u; // All zeros",
            "int zeros3 = std::countl_zero(u3);",
            "std::cout << \"Leading zeros in 0u: \" << zeros3 << std::endl; // 32 (for 32-bit int)",
            "",
            "unsigned int u4 = std::numeric_limits<unsigned int>::max(); // All ones",
            "int zeros4 = std::countl_zero(u4);",
            "std::cout << \"Leading zeros in all ones: \" << zeros4 << std::endl; // 0",
            "",
            "// For unsigned long long",
            "unsigned long long ull = 0b0001000000000000000000000000000000000000000000000000000000000000ULL;",
            "int zeros_ull = std::countl_zero(ull);",
            "std::cout << \"Leading zeros in large ULL: \" << zeros_ull << std::endl; // 60 (for 64-bit ULL)",
            "$0"
        ],
        "description": "Counts the number of consecutive leading zero bits in the binary representation of an unsigned integer. If the value is zero, it returns the total number of bits in the type. Useful for bit manipulation and optimization. Time complexity: O(1) (typically implemented as a single CPU instruction). Link: https://en.cppreference.com/w/cpp/numeric/countl_zero"
    },
    "cpp_numeric__countl_one": {
        "prefix": "cpp_numeric__countl_one",
        "body": [
            "// std::countl_one - Count leading one bits (C++20)",
            "// Reference: https://en.cppreference.com/w/cpp/numeric/countl_one",
            "#include <bit>",
            "#include <iostream>",
            "#include <limits>",
            "",
            "// For unsigned integers",
            "unsigned int u1 = 0b11110101u; // Example value",
            "int ones1 = std::countl_one(u1);",
            "// Assuming 32-bit unsigned int, and u1 is 0b0000...11110101",
            "// This counts leading 1s, so if it's 0b0000... then it's 0.",
            "// To get actual leading ones, you'd typically invert the number first or use a mask.",
            "// Let's use an example where leading bits are actually 1s.",
            "unsigned int u2 = 0xFFFFFFFFu; // All ones (for 32-bit)",
            "int ones2 = std::countl_one(u2);",
            "std::cout << \"Leading ones in all ones: \" << ones2 << std::endl; // 32 (for 32-bit int)",
            "",
            "unsigned int u3 = 0xFFF00000u; // 12 leading ones (for 32-bit)",
            "int ones3 = std::countl_one(u3);",
            "std::cout << \"Leading ones in 0xFFF00000u: \" << ones3 << std::endl; // 12 (for 32-bit int)",
            "",
            "unsigned int u4 = 0u; // All zeros",
            "int ones4 = std::countl_one(u4);",
            "std::cout << \"Leading ones in 0u: \" << ones4 << std::endl; // 0",
            "",
            "unsigned int u5 = 0x7FFFFFFFu; // Max int with leading zero",
            "int ones5 = std::countl_one(u5);",
            "std::cout << \"Leading ones in 0x7FFFFFFFu: \" << ones5 << std::endl; // 0",
            "$0"
        ],
        "description": "Counts the number of consecutive leading one bits in the binary representation of an unsigned integer. If the value is all zeros, it returns zero. Useful for bit manipulation. Time complexity: O(1) (typically implemented as a single CPU instruction). Link: https://en.cppreference.com/w/cpp/numeric/countl_one"
    },
    "cpp_numeric__countr_zero": {
        "prefix": "cpp_numeric__countr_zero",
        "body": [
            "// std::countr_zero - Count trailing zero bits (C++20)",
            "// Reference: https://en.cppreference.com/w/cpp/numeric/countr_zero",
            "#include <bit>",
            "#include <iostream>",
            "#include <limits>",
            "",
            "// For unsigned integers",
            "unsigned int u1 = 0b10100000u; // Example value",
            "int zeros1 = std::countr_zero(u1);",
            "std::cout << \"Trailing zeros in 0b10100000u: \" << zeros1 << std::endl; // 5",
            "",
            "unsigned int u2 = 0b00000001u; // 1",
            "int zeros2 = std::countr_zero(u2);",
            "std::cout << \"Trailing zeros in 0b00000001u: \" << zeros2 << std::endl; // 0",
            "",
            "unsigned int u3 = 0u; // All zeros",
            "int zeros3 = std::countr_zero(u3);",
            "std::cout << \"Trailing zeros in 0u: \" << zeros3 << std::endl; // 32 (for 32-bit int)",
            "",
            "unsigned int u4 = std::numeric_limits<unsigned int>::max(); // All ones",
            "int zeros4 = std::countr_zero(u4);",
            "std::cout << \"Trailing zeros in all ones: \" << zeros4 << std::endl; // 0",
            "",
            "// For unsigned long long",
            "unsigned long long ull = 0b1010000000000000000000000000000000000000000000000000000000000000ULL;",
            "int zeros_ull = std::countr_zero(ull);",
            "std::cout << \"Trailing zeros in large ULL: \" << zeros_ull << std::endl; // 60 (for 64-bit ULL)",
            "$0"
        ],
        "description": "Counts the number of consecutive trailing zero bits in the binary representation of an unsigned integer. If the value is zero, it returns the total number of bits in the type. Useful for bit manipulation and optimization. Time complexity: O(1) (typically implemented as a single CPU instruction). Link: https://en.cppreference.com/w/cpp/numeric/countr_zero"
    },
    "cpp_numeric__countr_one": {
        "prefix": "cpp_numeric__countr_one",
        "body": [
            "// std::countr_one - Count trailing one bits (C++20)",
            "// Reference: https://en.cppreference.com/w/cpp/numeric/countr_one",
            "#include <bit>",
            "#include <iostream>",
            "#include <limits>",
            "",
            "// For unsigned integers",
            "unsigned int u1 = 0b01011111u; // Example value",
            "int ones1 = std::countr_one(u1);",
            "std::cout << \"Trailing ones in 0b01011111u: \" << ones1 << std::endl; // 5",
            "",
            "unsigned int u2 = 0b11111111u; // All ones",
            "int ones2 = std::countr_one(u2);",
            "std::cout << \"Trailing ones in all ones: \" << ones2 << std::endl; // 32 (for 32-bit int)",
            "",
            "unsigned int u3 = 0b10000000u; // Single leading one",
            "int ones3 = std::countr_one(u3);",
            "std::cout << \"Trailing ones in 0b10000000u: \" << ones3 << std::endl; // 0",
            "",
            "unsigned int u4 = 0u; // All zeros",
            "int ones4 = std::countr_one(u4);",
            "std::cout << \"Trailing ones in 0u: \" << ones4 << std::endl; // 0",
            "$0"
        ],
        "description": "Counts the number of consecutive trailing one bits in the binary representation of an unsigned integer. If the value is all zeros, it returns zero. Useful for bit manipulation. Time complexity: O(1) (typically implemented as a single CPU instruction). Link: https://en.cppreference.com/w/cpp/numeric/countr_one"
    },
    "cpp_numeric__popcount": {
        "prefix": "cpp_numeric__popcount",
        "body": [
            "// std::popcount - Count set bits (population count) (C++20)",
            "// Reference: https://en.cppreference.com/w/cpp/numeric/popcount",
            "#include <bit>",
            "#include <iostream>",
            "",
            "// For unsigned integers",
            "unsigned int u1 = 0b00001010u; // 10 (binary: 1010), popcount = 2",
            "int count1 = std::popcount(u1);",
            "std::cout << \"Popcount of 10 (0b1010): \" << count1 << std::endl; // 2",
            "",
            "unsigned int u2 = 0b11111111u; // 255 (binary: 11111111), popcount = 8",
            "int count2 = std::popcount(u2);",
            "std::cout << \"Popcount of 255 (0b11111111): \" << count2 << std::endl; // 8",
            "",
            "unsigned int u3 = 0u; // 0, popcount = 0",
            "int count3 = std::popcount(u3);",
            "std::cout << \"Popcount of 0: \" << count3 << std::endl; // 0",
            "",
            "unsigned int u4 = 1u << 31; // Highest bit set (for 32-bit unsigned int)",
            "int count4 = std::popcount(u4);",
            "std::cout << \"Popcount of (1 << 31): \" << count4 << std::endl; // 1",
            "",
            "// For unsigned long long",
            "unsigned long long ull = 0b1101010110101011ULL;",
            "int count_ull = std::popcount(ull);",
            "std::cout << \"Popcount of 0b1101010110101011ULL: \" << count_ull << std::endl; // 10",
            "$0"
        ],
        "description": "Counts the number of set (1) bits in the binary representation of an unsigned integer. Also known as Hamming weight. Useful for various bit manipulation tasks and algorithms. Time complexity: O(1) (typically implemented as a single CPU instruction). Link: https://en.cppreference.com/w/cpp/numeric/popcount"
    },
    "cpp_14__generic_lambdas": {
        "prefix": "cpp_14__generic_lambdas",
        "body": [
            "// C++14: Generic lambdas with auto parameters",
            "",
            "// Generic lambda - works with any type",
            "auto generic_add = [](auto a, auto b) {",
            "    return a + b;",
            "};",
            "",
            "// Usage with different types",
            "std::cout << generic_add(5, 3) << std::endl;        // int",
            "std::cout << generic_add(5.5, 3.2) << std::endl;    // double",
            "std::cout << generic_add(std::string(\"Hello \"), std::string(\"World\")) << std::endl;",
            "",
            "// Generic lambda with multiple parameters",
            "auto print_pair = [](auto first, auto second) {",
            "    std::cout << \"First: \" << first << \", Second: \" << second << std::endl;",
            "};",
            "",
            "// Variadic generic lambda",
            "auto print_all = [](auto... args) {",
            "    ((std::cout << args << \" \"), ...); // C++17 fold expression",
            "    std::cout << std::endl;",
            "};",
            "",
            "// Generic lambda in STL algorithms",
            "std::vector<int> vec = {1, 2, 3, 4, 5};",
            "std::transform(vec.begin(), vec.end(), vec.begin(),",
            "    [](auto x) { return x * x; });",
            "$0"
        ],
        "description": "C++14 generic lambdas with auto parameters"
    },
    "cpp_14__lambda_init_capture": {
        "prefix": "cpp_14__lambda_init_capture",
        "body": [
            "// C++14: Lambda init capture (generalized lambda capture)",
            "",
            "// Move capture",
            "auto ptr = std::make_unique<int>(42);",
            "auto lambda1 = [p = std::move(ptr)]() {",
            "    std::cout << *p << std::endl;",
            "};",
            "",
            "// Initialize with expression",
            "auto lambda2 = [value = 10 * 2]() {",
            "    return value;",
            "};",
            "",
            "// Capture with different name",
            "int x = 5;",
            "auto lambda3 = [&r = x]() {",
            "    r++; // Modifies x",
            "};",
            "",
            "// Multiple init captures",
            "auto lambda4 = [a = 1, b = 2, c = a + b]() {",
            "    return a + b + c; // Returns 6",
            "};",
            "",
            "// Capture expensive objects by move",
            "std::vector<int> data(1000000);",
            "auto lambda5 = [vec = std::move(data)]() {",
            "    // vec now owns the data",
            "    return vec.size();",
            "};",
            "$0"
        ],
        "description": "C++14 lambda init capture for move semantics and expressions"
    },
    "cpp_14__return_type_deduction": {
        "prefix": "cpp_14__return_type_deduction",
        "body": [
            "// C++14: Return type deduction for functions",
            "",
            "// Auto return type",
            "auto add(int a, int b) {",
            "    return a + b; // Return type deduced as int",
            "}",
            "",
            "// Template with auto return",
            "template<typename T, typename U>",
            "auto multiply(T t, U u) {",
            "    return t * u; // Return type is decltype(t * u)",
            "}",
            "",
            "// Multiple return statements must deduce to same type",
            "auto getValue(bool flag) {",
            "    if (flag)",
            "        return 42;    // int",
            "    else",
            "        return 84;    // int - OK, same type",
            "}",
            "",
            "// Recursive function with auto",
            "auto factorial(int n) -> int { // Still need trailing return for recursion",
            "    if (n <= 1) return 1;",
            "    return n * factorial(n - 1);",
            "}",
            "",
            "// decltype(auto) for exact type deduction",
            "template<typename T>",
            "decltype(auto) forward_value(T&& t) {",
            "    return std::forward<T>(t); // Preserves value category",
            "}",
            "$0"
        ],
        "description": "C++14 return type deduction with auto and decltype(auto)"
    },
    "cpp_14__relaxed_constexpr": {
        "prefix": "cpp_14__relaxed_constexpr",
        "body": [
            "// C++14: Relaxed constexpr restrictions",
            "",
            "// C++14 allows multiple statements, loops, and local variables",
            "constexpr int factorial(int n) {",
            "    int result = 1;",
            "    for (int i = 1; i <= n; ++i) {",
            "        result *= i;",
            "    }",
            "    return result;",
            "}",
            "",
            "// constexpr member functions can modify object",
            "class Point {",
            "    int x, y;",
            "public:",
            "    constexpr Point(int x, int y) : x(x), y(y) {}",
            "    ",
            "    constexpr void move(int dx, int dy) {",
            "        x += dx;  // C++14: Can modify members",
            "        y += dy;",
            "    }",
            "    ",
            "    constexpr int getX() const { return x; }",
            "    constexpr int getY() const { return y; }",
            "};",
            "",
            "// Complex constexpr function",
            "constexpr int fibonacci(int n) {",
            "    if (n <= 1) return n;",
            "    ",
            "    int prev = 0, curr = 1;",
            "    for (int i = 2; i <= n; ++i) {",
            "        int next = prev + curr;",
            "        prev = curr;",
            "        curr = next;",
            "    }",
            "    return curr;",
            "}",
            "",
            "constexpr int fib10 = fibonacci(10); // Computed at compile time",
            "$0"
        ],
        "description": "C++14 relaxed constexpr with loops and multiple statements"
    },
    "cpp_14__variable_templates": {
        "prefix": "cpp_14__variable_templates",
        "body": [
            "// C++14: Variable templates",
            "",
            "// Basic variable template",
            "template<typename T>",
            "constexpr T pi = T(3.1415926535897932385);",
            "",
            "// Usage",
            "float f = pi<float>;",
            "double d = pi<double>;",
            "long double ld = pi<long double>;",
            "",
            "// Variable template with specialization",
            "template<typename T>",
            "constexpr T max_value = std::numeric_limits<T>::max();",
            "",
            "template<>",
            "constexpr int max_value<int> = INT_MAX;",
            "",
            "// Variable template for type traits",
            "template<typename T>",
            "constexpr bool is_pointer_v = std::is_pointer<T>::value;",
            "",
            "// Template variable with template template parameter",
            "template<template<typename> class Trait, typename T>",
            "constexpr bool satisfies_v = Trait<T>::value;",
            "",
            "// Usage",
            "if constexpr (is_pointer_v<int*>) { // C++17 if constexpr",
            "    // Handle pointer",
            "}",
            "$0"
        ],
        "description": "C++14 variable templates"
    },
    "cpp_14__binary_literals": {
        "prefix": "cpp_14__binary_literals",
        "body": [
            "// C++14: Binary literals with 0b or 0B prefix",
            "",
            "// Binary literals",
            "int binary8 = 0b11111111;        // 255",
            "int binary16 = 0b1111111111111111; // 65535",
            "int flags = 0b00001101;          // 13",
            "",
            "// With digit separators (C++14)",
            "int readable_binary = 0b1111'0000'1111'0000; // More readable",
            "int byte_pattern = 0b1010'1010;  // 170 (0xAA)",
            "",
            "// Bit manipulation examples",
            "constexpr int BIT_0 = 0b0000'0001;",
            "constexpr int BIT_1 = 0b0000'0010;",
            "constexpr int BIT_2 = 0b0000'0100;",
            "constexpr int BIT_3 = 0b0000'1000;",
            "",
            "// Check specific bits",
            "int value = 0b1010'1100;",
            "bool bit3_set = value & BIT_3; // true",
            "",
            "// Binary literal in template",
            "template<unsigned N>",
            "struct binary_value {",
            "    static constexpr unsigned value = N;",
            "};",
            "",
            "using eight_bits = binary_value<0b11111111>;",
            "$0"
        ],
        "description": "C++14 binary literals and digit separators"
    },
    "cpp_14__digit_separators": {
        "prefix": "cpp_14__digit_separators",
        "body": [
            "// C++14: Digit separators using single quotes",
            "",
            "// Integer literals with separators",
            "int million = 1'000'000;",
            "long billion = 1'000'000'000L;",
            "long long trillion = 1'000'000'000'000LL;",
            "",
            "// Different bases",
            "int decimal = 123'456'789;",
            "int hex = 0xDEAD'BEEF;",
            "int octal = 0'123'456;",
            "int binary = 0b1010'1100'1110'0001;",
            "",
            "// Floating point",
            "double pi = 3.141'592'653'589'793;",
            "float avogadro = 6.022'140'857e23f;",
            "",
            "// Custom grouping (any position is valid)",
            "int custom = 1'23'456'7890; // Valid but unconventional",
            "",
            "// Useful for bit patterns",
            "unsigned int rgba = 0xFF'FF'FF'FF; // White color, full alpha",
            "unsigned int color = 0x00'FF'00'FF; // Green with full alpha",
            "",
            "// Credit card number representation",
            "long long card_number = 1234'5678'9012'3456LL;",
            "$0"
        ],
        "description": "C++14 digit separators for improved readability"
    },
    "cpp_14__deprecated_attribute": {
        "prefix": "cpp_14__deprecated_attribute",
        "body": [
            "// C++14: [[deprecated]] attribute",
            "",
            "// Deprecate a function",
            "[[deprecated]]",
            "void old_function() {",
            "    std::cout << \"This function is deprecated\\n\";",
            "}",
            "",
            "// Deprecate with custom message",
            "[[deprecated(\"Use new_function() instead\")]]",
            "void legacy_api() {",
            "    // Old implementation",
            "}",
            "",
            "// Deprecate class",
            "[[deprecated(\"Use ModernClass instead\")]]",
            "class OldClass {",
            "public:",
            "    void doSomething() {}",
            "};",
            "",
            "// Deprecate typedef/using",
            "[[deprecated(\"Use std::int32_t\")]]",
            "typedef int old_int_type;",
            "",
            "// Deprecate enum value",
            "enum Status {",
            "    OK,",
            "    ERROR,",
            "    [[deprecated(\"Use ERROR instead\")]] FAIL",
            "};",
            "",
            "// Deprecate template",
            "template<typename T>",
            "[[deprecated(\"Use std::optional<T> instead\")]]",
            "class Maybe {",
            "    // Implementation",
            "};",
            "$0"
        ],
        "description": "C++14 [[deprecated]] attribute for marking obsolete code"
    },
    "cpp_14__make_unique": {
        "prefix": "cpp_14__make_unique",
        "body": [
            "// C++14: std::make_unique for creating unique_ptr",
            "#include <memory>",
            "",
            "// Basic usage",
            "auto ptr1 = std::make_unique<int>(42);",
            "auto ptr2 = std::make_unique<std::string>(\"Hello\");",
            "",
            "// Array version",
            "auto arr_ptr = std::make_unique<int[]>(10); // Array of 10 ints",
            "",
            "// With custom class",
            "class Widget {",
            "    int x, y;",
            "public:",
            "    Widget(int x, int y) : x(x), y(y) {}",
            "};",
            "",
            "auto widget = std::make_unique<Widget>(10, 20);",
            "",
            "// Exception safety",
            "// Bad (C++11): potential leak if second allocation throws",
            "// function(std::unique_ptr<int>(new int(42)), std::unique_ptr<int>(new int(13)));",
            "",
            "// Good (C++14): exception safe",
            "function(std::make_unique<int>(42), std::make_unique<int>(13));",
            "",
            "// In container",
            "std::vector<std::unique_ptr<int>> vec;",
            "vec.push_back(std::make_unique<int>(1));",
            "vec.push_back(std::make_unique<int>(2));",
            "$0"
        ],
        "description": "C++14 std::make_unique for safe unique_ptr creation"
    },
    "cpp_14__exchange": {
        "prefix": "cpp_14__exchange",
        "body": [
            "// C++14: std::exchange utility",
            "#include <utility>",
            "",
            "// Basic usage - replaces old value with new and returns old",
            "int x = 5;",
            "int old_x = std::exchange(x, 10); // x is now 10, old_x is 5",
            "",
            "// Useful in move constructors/assignment",
            "class Resource {",
            "    int* data;",
            "    size_t size;",
            "public:",
            "    // Move constructor",
            "    Resource(Resource&& other) noexcept",
            "        : data(std::exchange(other.data, nullptr)),",
            "          size(std::exchange(other.size, 0)) {}",
            "    ",
            "    // Move assignment",
            "    Resource& operator=(Resource&& other) noexcept {",
            "        if (this != &other) {",
            "            delete[] data;",
            "            data = std::exchange(other.data, nullptr);",
            "            size = std::exchange(other.size, 0);",
            "        }",
            "        return *this;",
            "    }",
            "};",
            "",
            "// Swap implementation using exchange",
            "template<typename T>",
            "void my_swap(T& a, T& b) {",
            "    T temp = std::exchange(a, std::move(b));",
            "    b = std::move(temp);",
            "}",
            "$0"
        ],
        "description": "C++14 std::exchange for replacing values"
    },
    "cpp_14__integer_sequence": {
        "prefix": "cpp_14__integer_sequence",
        "body": [
            "// C++14: std::integer_sequence and helpers",
            "#include <utility>",
            "#include <tuple>",
            "#include <array>",
            "",
            "// Using index_sequence to expand tuple",
            "template<typename Tuple, std::size_t... Is>",
            "void print_tuple_impl(const Tuple& t, std::index_sequence<Is...>) {",
            "    ((std::cout << std::get<Is>(t) << \" \"), ...); // C++17 fold",
            "}",
            "",
            "template<typename... Args>",
            "void print_tuple(const std::tuple<Args...>& t) {",
            "    print_tuple_impl(t, std::index_sequence_for<Args...>{});",
            "}",
            "",
            "// Convert array to tuple",
            "template<typename T, std::size_t N, std::size_t... Is>",
            "auto array_to_tuple_impl(const std::array<T, N>& arr, std::index_sequence<Is...>) {",
            "    return std::make_tuple(arr[Is]...);",
            "}",
            "",
            "template<typename T, std::size_t N>",
            "auto array_to_tuple(const std::array<T, N>& arr) {",
            "    return array_to_tuple_impl(arr, std::make_index_sequence<N>{});",
            "}",
            "",
            "// Apply function to tuple elements",
            "template<typename F, typename Tuple, std::size_t... Is>",
            "auto apply_impl(F&& f, Tuple&& t, std::index_sequence<Is...>) {",
            "    return f(std::get<Is>(std::forward<Tuple>(t))...);",
            "}",
            "",
            "template<typename F, typename Tuple>",
            "auto apply(F&& f, Tuple&& t) {",
            "    return apply_impl(std::forward<F>(f), std::forward<Tuple>(t),",
            "        std::make_index_sequence<std::tuple_size_v<std::decay_t<Tuple>>>{});",
            "}",
            "$0"
        ],
        "description": "C++14 std::integer_sequence for compile-time sequences"
    },
    "cpp_14__chrono_literals": {
        "prefix": "cpp_14__chrono_literals",
        "body": [
            "// C++14: User-defined literals for chrono durations",
            "#include <chrono>",
            "#include <thread>",
            "",
            "using namespace std::chrono_literals;",
            "",
            "// Duration literals",
            "auto one_second = 1s;",
            "auto half_second = 500ms;",
            "auto five_minutes = 5min;",
            "auto two_hours = 2h;",
            "auto one_microsecond = 1us;",
            "auto one_nanosecond = 1ns;",
            "",
            "// Using in sleep",
            "std::this_thread::sleep_for(100ms);",
            "std::this_thread::sleep_for(2s);",
            "",
            "// Complex durations",
            "auto duration = 1h + 30min + 45s;",
            "auto precise_time = 1s + 500ms + 250us;",
            "",
            "// In conditions",
            "auto start = std::chrono::steady_clock::now();",
            "// ... do work ...",
            "auto end = std::chrono::steady_clock::now();",
            "",
            "if (end - start > 1s) {",
            "    std::cout << \"Operation took more than 1 second\\n\";",
            "}",
            "",
            "// Timeout example",
            "std::condition_variable cv;",
            "std::mutex mtx;",
            "std::unique_lock<std::mutex> lock(mtx);",
            "if (cv.wait_for(lock, 5s) == std::cv_status::timeout) {",
            "    std::cout << \"Timeout occurred\\n\";",
            "}",
            "$0"
        ],
        "description": "C++14 chrono user-defined literals"
    },
    "cpp_14__shared_timed_mutex": {
        "prefix": "cpp_14__shared_timed_mutex",
        "body": [
            "// C++14: std::shared_timed_mutex for reader/writer locks",
            "#include <shared_mutex>",
            "#include <thread>",
            "#include <vector>",
            "",
            "class ThreadSafeCounter {",
            "    mutable std::shared_timed_mutex mutex;",
            "    int value = 0;",
            "",
            "public:",
            "    // Multiple threads can read simultaneously",
            "    int get() const {",
            "        std::shared_lock<std::shared_timed_mutex> lock(mutex);",
            "        return value;",
            "    }",
            "    ",
            "    // Only one thread can write",
            "    void increment() {",
            "        std::unique_lock<std::shared_timed_mutex> lock(mutex);",
            "        ++value;",
            "    }",
            "    ",
            "    // Try to get write lock with timeout",
            "    bool try_increment_for(std::chrono::milliseconds timeout) {",
            "        std::unique_lock<std::shared_timed_mutex> lock(mutex, std::defer_lock);",
            "        if (lock.try_lock_for(timeout)) {",
            "            ++value;",
            "            return true;",
            "        }",
            "        return false;",
            "    }",
            "};",
            "",
            "// Usage example",
            "ThreadSafeCounter counter;",
            "",
            "// Multiple reader threads",
            "std::vector<std::thread> readers;",
            "for (int i = 0; i < 5; ++i) {",
            "    readers.emplace_back([&counter]() {",
            "        for (int j = 0; j < 100; ++j) {",
            "            int val = counter.get();",
            "            std::this_thread::yield();",
            "        }",
            "    });",
            "}",
            "$0"
        ],
        "description": "C++14 std::shared_timed_mutex for reader/writer locks"
    },
    "cpp_14__heterogeneous_lookup": {
        "prefix": "cpp_14__heterogeneous_lookup",
        "body": [
            "// C++14: Heterogeneous lookup in associative containers",
            "#include <set>",
            "#include <map>",
            "#include <string>",
            "#include <string_view>",
            "",
            "// Custom comparator with is_transparent",
            "struct StringCompare {",
            "    using is_transparent = void; // Enable heterogeneous lookup",
            "    ",
            "    bool operator()(const std::string& a, const std::string& b) const {",
            "        return a < b;",
            "    }",
            "    ",
            "    bool operator()(const std::string& a, const char* b) const {",
            "        return a < b;",
            "    }",
            "    ",
            "    bool operator()(const char* a, const std::string& b) const {",
            "        return a < b;",
            "    }",
            "    ",
            "    bool operator()(const char* a, const char* b) const {",
            "        return std::strcmp(a, b) < 0;",
            "    }",
            "};",
            "",
            "// Use with set",
            "std::set<std::string, StringCompare> string_set = {",
            "    \"apple\", \"banana\", \"cherry\"",
            "};",
            "",
            "// Can now find with const char* without creating std::string",
            "auto it = string_set.find(\"banana\"); // No temporary std::string created",
            "",
            "// Use with map",
            "std::map<std::string, int, StringCompare> word_count;",
            "word_count[\"hello\"] = 5;",
            "",
            "// Efficient lookup with string literal",
            "if (word_count.find(\"hello\") != word_count.end()) {",
            "    std::cout << \"Found!\\n\";",
            "}",
            "$0"
        ],
        "description": "C++14 heterogeneous lookup in associative containers"
    },
    "cpp_14__quoted": {
        "prefix": "cpp_14__quoted",
        "body": [
            "// C++14: std::quoted for quoted string I/O",
            "#include <iostream>",
            "#include <iomanip>",
            "#include <sstream>",
            "#include <string>",
            "",
            "// Writing quoted strings",
            "std::string text = \"Hello \\\"World\\\" with spaces\";",
            "std::stringstream ss;",
            "",
            "// Without quoted - spaces break the string",
            "ss << text;",
            "std::string word;",
            "ss >> word; // Only gets \"Hello\"",
            "ss.clear();",
            "ss.str(\"\");",
            "",
            "// With quoted - preserves the full string",
            "ss << std::quoted(text);",
            "std::string full_text;",
            "ss >> std::quoted(full_text); // Gets entire string with quotes handled",
            "",
            "std::cout << \"Original: \" << text << std::endl;",
            "std::cout << \"With quoted: \" << std::quoted(text) << std::endl;",
            "",
            "// Custom delimiter and escape",
            "ss.str(\"\");",
            "ss << std::quoted(text, '`', '\\\\');",
            "std::cout << \"Custom: \" << ss.str() << std::endl;",
            "",
            "// Useful for CSV-like data",
            "std::vector<std::string> data = {\"Name\", \"John Doe\", \"Address, City\"};",
            "for (const auto& field : data) {",
            "    std::cout << std::quoted(field) << \",\";",
            "}",
            "$0"
        ],
        "description": "C++14 std::quoted for handling quoted strings in I/O"
    },
    "cpp_14__sized_deallocation": {
        "prefix": "cpp_14__sized_deallocation",
        "body": [
            "// C++14: Sized deallocation",
            "#include <new>",
            "#include <cstddef>",
            "#include <iostream>",
            "",
            "// Global sized deallocation (automatically used by delete)",
            "void operator delete(void* ptr, std::size_t size) noexcept {",
            "    std::cout << \"Deallocating \" << size << \" bytes\\n\";",
            "    ::operator delete(ptr);",
            "}",
            "",
            "void operator delete[](void* ptr, std::size_t size) noexcept {",
            "    std::cout << \"Deallocating array of \" << size << \" bytes\\n\";",
            "    ::operator delete[](ptr);",
            "}",
            "",
            "// Class-specific sized deallocation",
            "class Widget {",
            "    int data[100];",
            "public:",
            "    static void operator delete(void* ptr, std::size_t size) noexcept {",
            "        std::cout << \"Widget deallocation: \" << size << \" bytes\\n\";",
            "        ::operator delete(ptr);",
            "    }",
            "};",
            "",
            "// Usage",
            "int* p = new int(42);",
            "delete p; // Calls sized deallocation with sizeof(int)",
            "",
            "Widget* w = new Widget;",
            "delete w; // Calls Widget's sized deallocation",
            "",
            "int* arr = new int[10];",
            "delete[] arr; // Calls array sized deallocation",
            "$0"
        ],
        "description": "C++14 sized deallocation for better memory management"
    },
    "cpp_14__tuple_addressing_by_type": {
        "prefix": "cpp_14__tuple_addressing_by_type",
        "body": [
            "// C++14: Tuple addressing by type",
            "#include <tuple>",
            "#include <string>",
            "#include <iostream>",
            "",
            "// Create tuple with unique types",
            "std::tuple<int, double, std::string> data(42, 3.14, \"hello\");",
            "",
            "// C++11 way - by index",
            "int i = std::get<0>(data);",
            "double d = std::get<1>(data);",
            "std::string s = std::get<2>(data);",
            "",
            "// C++14 way - by type (only works if type is unique)",
            "int i2 = std::get<int>(data);",
            "double d2 = std::get<double>(data);",
            "std::string s2 = std::get<std::string>(data);",
            "",
            "// Modify by type",
            "std::get<int>(data) = 100;",
            "std::get<std::string>(data) = \"world\";",
            "",
            "// Error if type is not unique",
            "// std::tuple<int, int, double> t2(1, 2, 3.14);",
            "// int val = std::get<int>(t2); // Compile error: type not unique",
            "",
            "// Works with tie",
            "int x;",
            "double y;",
            "std::string z;",
            "std::tie(x, y, z) = data;",
            "$0"
        ],
        "description": "C++14 tuple addressing by type for unique types"
    },
    "cpp_14__aggregate_member_initialization": {
        "prefix": "cpp_14__aggregate_member_initialization",
        "body": [
            "// C++14: Aggregate member initialization",
            "",
            "// C++14 allows aggregates to have default member initializers",
            "struct Point {",
            "    int x = 0;  // Default member initializer",
            "    int y = 0;  // Still an aggregate in C++14",
            "};",
            "",
            "// Aggregate initialization still works",
            "Point p1{};        // x=0, y=0 (using defaults)",
            "Point p2{5};       // x=5, y=0 (partial initialization)",
            "Point p3{5, 10};   // x=5, y=10",
            "",
            "// More complex aggregate",
            "struct Config {",
            "    int width = 800;",
            "    int height = 600;",
            "    bool fullscreen = false;",
            "    double scale = 1.0;",
            "};",
            "",
            "// Various initialization styles",
            "Config cfg1{};                    // All defaults",
            "Config cfg2{1920, 1080};          // Custom resolution, other defaults",
            "Config cfg3{1920, 1080, true};    // Custom resolution and fullscreen",
            "Config cfg4{.width=1280, .height=720}; // C++20 designated initializers",
            "$0"
        ],
        "description": "C++14 aggregates with default member initializers"
    },
    "cpp_14__decltype_auto": {
        "prefix": "cpp_14__decltype_auto",
        "body": [
            "// C++14: decltype(auto) for perfect forwarding of return types",
            "",
            "// decltype(auto) deduces the exact type including references",
            "int x = 5;",
            "int& get_x() { return x; }",
            "const int& get_const_x() { return x; }",
            "",
            "// auto would deduce int (loses reference)",
            "auto a = get_x();        // a is int",
            "decltype(auto) b = get_x(); // b is int&",
            "",
            "// Perfect forwarding in generic code",
            "template<typename F, typename... Args>",
            "decltype(auto) forward_call(F&& f, Args&&... args) {",
            "    return std::forward<F>(f)(std::forward<Args>(args)...);",
            "}",
            "",
            "// Preserves const and reference qualifiers",
            "decltype(auto) c = get_const_x(); // c is const int&",
            "decltype(auto) d = (x);           // d is int& (parentheses matter!)",
            "decltype(auto) e = x;             // e is int",
            "",
            "// Generic getter that preserves return type",
            "template<typename Container, typename Index>",
            "decltype(auto) get_element(Container&& c, Index i) {",
            "    return std::forward<Container>(c)[i];",
            "}",
            "",
            "// Works with member access",
            "struct Data {",
            "    int value;",
            "    int& get() { return value; }",
            "    const int& get() const { return value; }",
            "};",
            "",
            "template<typename T>",
            "decltype(auto) access_value(T&& obj) {",
            "    return std::forward<T>(obj).get();",
            "}",
            "$0"
        ],
        "description": "C++14 decltype(auto) for exact type deduction"
    },
    "cpp_14__constexpr_extensions": {
        "prefix": "cpp_14__constexpr_extensions",
        "body": [
            "// C++14: Extended constexpr capabilities",
            "",
            "// C++14 allows non-const constexpr member functions",
            "class Counter {",
            "    int count = 0;",
            "public:",
            "    constexpr int increment() {",
            "        return ++count; // Can modify members in C++14",
            "    }",
            "    constexpr int get() const { return count; }",
            "};",
            "",
            "// constexpr with local variables and mutations",
            "constexpr int complex_calculation(int n) {",
            "    int sum = 0;",
            "    int product = 1;",
            "    ",
            "    for (int i = 1; i <= n; ++i) {",
            "        sum += i;",
            "        product *= i;",
            "        ",
            "        // Can have multiple statements",
            "        if (i % 2 == 0) {",
            "            sum += 1;",
            "        }",
            "    }",
            "    ",
            "    return sum + product;",
            "}",
            "",
            "// constexpr constructors can have function body",
            "class Rectangle {",
            "    double width, height;",
            "public:",
            "    constexpr Rectangle(double w, double h) : width(w), height(h) {",
            "        // Can have statements in constructor body",
            "        if (width < 0) width = 0;",
            "        if (height < 0) height = 0;",
            "    }",
            "    ",
            "    constexpr double area() const { return width * height; }",
            "};",
            "",
            "// Use at compile time",
            "constexpr Rectangle rect(5.0, 3.0);",
            "constexpr double area = rect.area(); // 15.0",
            "$0"
        ],
        "description": "C++14 extended constexpr with mutations and statements"
    },
    "cpp_14__std_cbegin_cend": {
        "prefix": "cpp_14__std_cbegin_cend",
        "body": [
            "// C++14: std::cbegin, std::cend, std::rbegin, std::rend, etc.",
            "#include <iterator>",
            "#include <vector>",
            "#include <array>",
            "",
            "// Works with arrays, containers, and C-arrays",
            "std::vector<int> vec = {1, 2, 3, 4, 5};",
            "int arr[] = {1, 2, 3, 4, 5};",
            "std::array<int, 5> std_arr = {1, 2, 3, 4, 5};",
            "",
            "// Const iterators (C++14)",
            "auto cit1 = std::cbegin(vec);    // vector<int>::const_iterator",
            "auto cit2 = std::cend(vec);",
            "auto cit3 = std::cbegin(arr);    // const int*",
            "auto cit4 = std::cend(arr);",
            "",
            "// Reverse iterators (C++14)",
            "auto rit1 = std::rbegin(vec);    // reverse_iterator",
            "auto rit2 = std::rend(vec);",
            "auto rit3 = std::rbegin(arr);",
            "auto rit4 = std::rend(arr);",
            "",
            "// Const reverse iterators (C++14)",
            "auto crit1 = std::crbegin(vec);  // const_reverse_iterator",
            "auto crit2 = std::crend(vec);",
            "",
            "// Generic code that works with any container",
            "template<typename Container>",
            "void print_reverse(const Container& c) {",
            "    for (auto it = std::crbegin(c); it != std::crend(c); ++it) {",
            "        std::cout << *it << \" \";",
            "    }",
            "}",
            "",
            "// Size and empty (C++17, but often implemented earlier)",
            "auto size1 = std::size(arr);     // 5",
            "auto size2 = std::size(vec);     // 5",
            "bool empty = std::empty(vec);    // false",
            "$0"
        ],
        "description": "C++14 generic begin/end functions"
    },
    "cpp_14__transparent_operator_functors": {
        "prefix": "cpp_14__transparent_operator_functors",
        "body": [
            "// C++14: Transparent operator functors",
            "#include <functional>",
            "#include <algorithm>",
            "#include <vector>",
            "#include <string>",
            "",
            "// C++14 adds specializations with void that deduce types",
            "std::vector<int> numbers = {1, 2, 3, 4, 5};",
            "",
            "// C++11 way - must specify types",
            "// std::transform(numbers.begin(), numbers.end(), numbers.begin(),",
            "//                std::plus<int>());",
            "",
            "// C++14 way - transparent functors with void",
            "std::transform(numbers.begin(), numbers.end(), numbers.begin(),",
            "               std::plus<>()); // Note: no type specified",
            "",
            "// Works with different types",
            "std::vector<double> doubles = {1.1, 2.2, 3.3};",
            "std::vector<int> ints = {1, 2, 3};",
            "std::vector<double> results(3);",
            "",
            "std::transform(doubles.begin(), doubles.end(), ints.begin(),",
            "               results.begin(), std::plus<>()); // Mixed types!",
            "",
            "// All arithmetic operators have transparent versions",
            "std::plus<> add;",
            "std::minus<> subtract;",
            "std::multiplies<> multiply;",
            "std::divides<> divide;",
            "std::modulus<> mod;",
            "std::negate<> neg;",
            "",
            "// Comparison operators too",
            "std::equal_to<> eq;",
            "std::not_equal_to<> neq;",
            "std::greater<> gt;",
            "std::less<> lt;",
            "std::greater_equal<> ge;",
            "std::less_equal<> le;",
            "",
            "// Example: heterogeneous comparison",
            "std::vector<std::string> words = {\"apple\", \"banana\", \"cherry\"};",
            "auto it = std::find_if(words.begin(), words.end(),",
            "    [](const std::string& s) { return std::less<>()(s, \"banana\"); });",
            "$0"
        ],
        "description": "C++14 transparent operator functors"
    },
    "cpp_14__is_final": {
        "prefix": "cpp_14__is_final",
        "body": [
            "// C++14: std::is_final type trait",
            "#include <type_traits>",
            "#include <iostream>",
            "",
            "// Regular class",
            "class Base {",
            "public:",
            "    virtual void foo() {}",
            "};",
            "",
            "// Final class",
            "class Derived final : public Base {",
            "public:",
            "    void foo() override {}",
            "};",
            "",
            "// Cannot inherit from final class",
            "// class MoreDerived : public Derived {}; // Error!",
            "",
            "// Check if class is final",
            "static_assert(!std::is_final<Base>::value, \"Base should not be final\");",
            "static_assert(std::is_final<Derived>::value, \"Derived should be final\");",
            "",
            "// C++17 style with _v suffix",
            "static_assert(!std::is_final_v<Base>);",
            "static_assert(std::is_final_v<Derived>);",
            "",
            "// Template that only accepts non-final classes",
            "template<typename T>",
            "class Wrapper : public T {",
            "    static_assert(!std::is_final<T>::value,",
            "                  \"Cannot wrap final classes\");",
            "};",
            "",
            "// Usage in SFINAE",
            "template<typename T>",
            "typename std::enable_if<!std::is_final<T>::value, bool>::type",
            "can_derive_from() {",
            "    return true;",
            "}",
            "",
            "template<typename T>",
            "typename std::enable_if<std::is_final<T>::value, bool>::type",
            "can_derive_from() {",
            "    return false;",
            "}",
            "$0"
        ],
        "description": "C++14 std::is_final type trait"
    },
    "cpp_14__result_of_SFINAE": {
        "prefix": "cpp_14__result_of_SFINAE",
        "body": [
            "// C++14: std::result_of SFINAE-friendly",
            "#include <type_traits>",
            "#include <utility>",
            "",
            "// C++14 makes std::result_of SFINAE-friendly",
            "// If the expression is invalid, no hard error",
            "",
            "// Function object",
            "struct Callable {",
            "    int operator()(int x) { return x * 2; }",
            "    // No operator() for double",
            "};",
            "",
            "// Check if callable with specific arguments",
            "template<typename F, typename... Args>",
            "using result_of_t = typename std::result_of<F(Args...)>::type;",
            "",
            "// SFINAE-friendly check",
            "template<typename F, typename... Args>",
            "struct is_callable {",
            "private:",
            "    template<typename T>",
            "    static auto test(int) -> decltype(",
            "        std::declval<T>()(std::declval<Args>()...),",
            "        std::true_type{}",
            "    );",
            "    ",
            "    template<typename>",
            "    static std::false_type test(...);",
            "    ",
            "public:",
            "    static constexpr bool value = decltype(test<F>(0))::value;",
            "};",
            "",
            "// Usage",
            "static_assert(is_callable<Callable, int>::value, \"Should be callable with int\");",
            "static_assert(!is_callable<Callable, double>::value, \"Should not be callable with double\");",
            "",
            "// Generic invoke wrapper",
            "template<typename F, typename... Args,",
            "         typename = typename std::enable_if<is_callable<F, Args...>::value>::type>",
            "auto invoke(F&& f, Args&&... args)",
            "    -> typename std::result_of<F(Args...)>::type {",
            "    return std::forward<F>(f)(std::forward<Args>(args)...);",
            "}",
            "$0"
        ],
        "description": "C++14 SFINAE-friendly std::result_of"
    },
    "cpp_14__string_udls": {
        "prefix": "cpp_14__string_udls",
        "body": [
            "// C++14: String user-defined literals",
            "#include <string>",
            "#include <complex>",
            "#include <chrono>",
            "",
            "using namespace std::string_literals;",
            "",
            "// String literal that creates std::string",
            "auto str1 = \"Hello World\"s;  // std::string, not const char*",
            "auto str2 = \"Line 1\\nLine 2\"s;",
            "",
            "// Useful for string concatenation",
            "auto greeting = \"Hello \"s + \"World\"s; // Both are std::string",
            "",
            "// Works with raw string literals",
            "auto raw = R\"(C:\\Users\\Path)\"s; // std::string with raw content",
            "",
            "// Avoids array decay",
            "auto get_string() {",
            "    return \"Returned string\"s; // Returns std::string, not dangling pointer",
            "}",
            "",
            "// Complex number literals (also C++14)",
            "using namespace std::complex_literals;",
            "auto c1 = 1.0 + 2.0i;  // std::complex<double>(1.0, 2.0)",
            "auto c2 = 3.14i;       // std::complex<double>(0, 3.14)",
            "auto c3 = 2if;         // std::complex<float>(0, 2)",
            "auto c4 = 3il;         // std::complex<long double>(0, 3)",
            "",
            "// All standard library UDLs in inline namespaces",
            "using namespace std::literals; // Gets all of them",
            "$0"
        ],
        "description": "C++14 string and complex number UDLs"
    },
    "cpp_14__generic_lambda_captures": {
        "prefix": "cpp_14__generic_lambda_captures",
        "body": [
            "// C++14: Generic lambda captures with init-capture",
            "#include <memory>",
            "#include <vector>",
            "#include <algorithm>",
            "",
            "// Capture by move with new name",
            "std::vector<int> data = {1, 2, 3, 4, 5};",
            "auto process = [vec = std::move(data)](auto func) {",
            "    // data is now empty, vec owns the elements",
            "    for (auto& elem : vec) {",
            "        func(elem);",
            "    }",
            "};",
            "",
            "// Capture with computation",
            "int x = 10, y = 20;",
            "auto compute = [sum = x + y, product = x * y](auto op) {",
            "    return op(sum, product);",
            "};",
            "",
            "// Capture member variables by value",
            "struct Widget {",
            "    int value = 42;",
            "    auto getLambda() {",
            "        return [capturedValue = value](auto multiplier) {",
            "            return capturedValue * multiplier;",
            "        };",
            "    }",
            "};",
            "",
            "// Perfect forwarding in captures",
            "template<typename T>",
            "auto make_lambda(T&& value) {",
            "    return [cap = std::forward<T>(value)](auto func) mutable {",
            "        return func(cap);",
            "    };",
            "}",
            "$0"
        ],
        "description": "C++14 generic lambdas with init-capture"
    },
    "cpp_14__tuple_type_traits": {
        "prefix": "cpp_14__tuple_type_traits",
        "body": [
            "// C++14: Tuple type traits",
            "#include <tuple>",
            "#include <type_traits>",
            "",
            "// tuple_element_t - C++14 alias template",
            "using MyTuple = std::tuple<int, double, std::string>;",
            "using FirstType = std::tuple_element_t<0, MyTuple>;  // int",
            "using SecondType = std::tuple_element_t<1, MyTuple>; // double",
            "using ThirdType = std::tuple_element_t<2, MyTuple>;  // std::string",
            "",
            "// C++11 way for comparison",
            "// using FirstType = typename std::tuple_element<0, MyTuple>::type;",
            "",
            "// Works with pairs too",
            "using MyPair = std::pair<int, std::string>;",
            "using PairFirst = std::tuple_element_t<0, MyPair>;   // int",
            "using PairSecond = std::tuple_element_t<1, MyPair>;  // std::string",
            "",
            "// Generic function using tuple_element_t",
            "template<std::size_t I, typename Tuple>",
            "auto get_element_copy(const Tuple& t) -> std::tuple_element_t<I, Tuple> {",
            "    return std::get<I>(t);",
            "}",
            "",
            "// tuple_size_v is C++17, but pattern shown for completeness",
            "template<typename Tuple>",
            "constexpr std::size_t tuple_size_v = std::tuple_size<Tuple>::value;",
            "$0"
        ],
        "description": "C++14 tuple type traits and alias templates"
    },
    "cpp_14__enable_if_t": {
        "prefix": "cpp_14__enable_if_t",
        "body": [
            "// C++14: Type trait alias templates (_t suffix)",
            "#include <type_traits>",
            "",
            "// C++14 provides alias templates for type traits",
            "",
            "// enable_if_t - cleaner SFINAE",
            "template<typename T>",
            "std::enable_if_t<std::is_integral<T>::value, T>",
            "increment(T value) {",
            "    return value + 1;",
            "}",
            "",
            "// C++11 way for comparison",
            "// typename std::enable_if<std::is_integral<T>::value, T>::type",
            "",
            "// conditional_t",
            "template<typename T>",
            "using storage_type = std::conditional_t<",
            "    sizeof(T) <= sizeof(void*),",
            "    T,",
            "    T*",
            ">;",
            "",
            "// decay_t",
            "template<typename T>",
            "void process(T&& value) {",
            "    using DecayedType = std::decay_t<T>;",
            "    DecayedType copy = std::forward<T>(value);",
            "}",
            "",
            "// remove_reference_t, remove_const_t, etc.",
            "template<typename T>",
            "using bare_type = std::remove_cv_t<std::remove_reference_t<T>>;",
            "",
            "// common_type_t",
            "template<typename T, typename U>",
            "auto max(T a, U b) -> std::common_type_t<T, U> {",
            "    return a > b ? a : b;",
            "}",
            "",
            "// All type traits have _t versions in C++14",
            "using Integer = std::make_signed_t<unsigned int>;",
            "using Unsigned = std::make_unsigned_t<int>;",
            "using Array = std::remove_extent_t<int[10]>;",
            "$0"
        ],
        "description": "C++14 type trait alias templates"
    },
    "cpp_17__structured_bindings": {
        "prefix": "cpp_17__structured_bindings",
        "body": [
            "// C++17: Structured bindings",
            "#include <tuple>",
            "#include <map>",
            "",
            "// With std::pair/tuple",
            "std::pair<int, std::string> p = {42, \"hello\"};",
            "auto [id, name] = p;",
            "",
            "// With std::tuple",
            "std::tuple<int, double, std::string> t{1, 3.14, \"world\"};",
            "auto [x, y, z] = t;",
            "",
            "// With structs",
            "struct Point { int x, y; };",
            "Point pt{10, 20};",
            "auto [px, py] = pt;",
            "",
            "// In range-based for with maps",
            "std::map<std::string, int> m = {{\"a\", 1}, {\"b\", 2}};",
            "for (const auto& [key, value] : m) {",
            "    std::cout << key << \": \" << value << std::endl;",
            "}",
            "$0"
        ],
        "description": "C++17 structured bindings"
    },
    "cpp_17__if_constexpr": {
        "prefix": "cpp_17__if_constexpr",
        "body": [
            "// C++17: if constexpr",
            "#include <type_traits>",
            "",
            "template<typename T>",
            "auto process(T value) {",
            "    if constexpr (std::is_integral_v<T>) {",
            "        return value + 1;",
            "    } else if constexpr (std::is_floating_point_v<T>) {",
            "        return value * 2.0;",
            "    } else {",
            "        return value;",
            "    }",
            "}",
            "$0"
        ],
        "description": "C++17 if constexpr"
    },
    "cpp_17__fold_expressions": {
        "prefix": "cpp_17__fold_expressions",
        "body": [
            "// C++17: Fold expressions",
            "",
            "template<typename... Args>",
            "auto sum(Args... args) {",
            "    return (... + args); // Left fold",
            "}",
            "",
            "template<typename... Args>",
            "void print(Args... args) {",
            "    ((std::cout << args << \" \"), ...);",
            "}",
            "$0"
        ],
        "description": "C++17 fold expressions"
    },
    "cpp_17__optional": {
        "prefix": "cpp_17__optional",
        "body": [
            "// C++17: std::optional",
            "#include <optional>",
            "",
            "std::optional<int> divide(int a, int b) {",
            "    if (b == 0) return std::nullopt;",
            "    return a / b;",
            "}",
            "",
            "auto result = divide(10, 2);",
            "if (result) {",
            "    std::cout << \"Result: \" << *result << std::endl;",
            "}",
            "std::cout << \"Value or default: \" << result.value_or(-1) << std::endl;",
            "$0"
        ],
        "description": "C++17 std::optional"
    },
    "cpp_17__variant": {
        "prefix": "cpp_17__variant",
        "body": [
            "// C++17: std::variant",
            "#include <variant>",
            "",
            "std::variant<int, double, std::string> v = \"hello\";",
            "",
            "// Visit pattern",
            "std::visit([](auto&& arg) {",
            "    using T = std::decay_t<decltype(arg)>;",
            "    if constexpr (std::is_same_v<T, int>)",
            "        std::cout << \"int: \" << arg << std::endl;",
            "    else if constexpr (std::is_same_v<T, double>)",
            "        std::cout << \"double: \" << arg << std::endl;",
            "    else",
            "        std::cout << \"string: \" << arg << std::endl;",
            "}, v);",
            "$0"
        ],
        "description": "C++17 std::variant"
    },
    "cpp_17__string_view": {
        "prefix": "cpp_17__string_view",
        "body": [
            "// C++17: std::string_view",
            "#include <string_view>",
            "",
            "void process(std::string_view sv) {",
            "    std::cout << sv << \" (len=\" << sv.length() << \")\" << std::endl;",
            "}",
            "",
            "process(\"literal\");",
            "std::string str = \"string\";",
            "process(str);",
            "process(std::string_view(str.data(), 3)); // \"str\"",
            "$0"
        ],
        "description": "C++17 std::string_view"
    },
    "cpp_17__filesystem": {
        "prefix": "cpp_17__filesystem",
        "body": [
            "// C++17: std::filesystem",
            "#include <filesystem>",
            "namespace fs = std::filesystem;",
            "",
            "fs::path p = \"path/to/file.txt\";",
            "std::cout << \"Exists: \" << fs::exists(p) << std::endl;",
            "std::cout << \"Filename: \" << p.filename() << std::endl;",
            "std::cout << \"Extension: \" << p.extension() << std::endl;",
            "",
            "// Iterate directory",
            "for (const auto& entry : fs::directory_iterator(\".\")) {",
            "    std::cout << entry.path() << std::endl;",
            "}",
            "$0"
        ],
        "description": "C++17 std::filesystem"
    },
    "cpp_17__init_if": {
        "prefix": "cpp_17__init_if",
        "body": [
            "// C++17: if/switch with initializer",
            "",
            "// if with initializer",
            "if (auto it = map.find(key); it != map.end()) {",
            "    use(it->second);",
            "}",
            "",
            "// Useful with locks",
            "if (std::lock_guard lock(mutex); condition) {",
            "    // locked scope",
            "}",
            "$0"
        ],
        "description": "C++17 if with initializer"
    },
    "cpp_17__inline_variables": {
        "prefix": "cpp_17__inline_variables",
        "body": [
            "// C++17: Inline variables",
            "",
            "// In header file:",
            "class Config {",
            "public:",
            "    inline static int max_connections = 100;",
            "    inline static const std::string version = \"1.0\";",
            "};",
            "",
            "// Can be defined in header, ODR-safe",
            "inline constexpr int global_constant = 42;",
            "$0"
        ],
        "description": "C++17 inline variables"
    },
    "cpp_17__nested_namespaces": {
        "prefix": "cpp_17__nested_namespaces",
        "body": [
            "// C++17: Nested namespace definition",
            "",
            "// Old way (C++14 and before)",
            "namespace A {",
            "namespace B {",
            "namespace C {",
            "    void func() {}",
            "}}}",
            "",
            "// New way (C++17)",
            "namespace A::B::C {",
            "    void func() {}",
            "}",
            "$0"
        ],
        "description": "C++17 nested namespaces"
    },
    "cpp_17__class_template_deduction": {
        "prefix": "cpp_17__class_template_deduction",
        "body": [
            "// C++17: Class template argument deduction (CTAD)",
            "",
            "// Before C++17",
            "std::pair<int, double> p1(1, 2.3);",
            "std::vector<int> v1 = {1, 2, 3};",
            "",
            "// C++17 CTAD",
            "std::pair p2(1, 2.3);           // deduced as pair<int, double>",
            "std::vector v2 = {1, 2, 3};     // deduced as vector<int>",
            "std::lock_guard lg(mutex);      // deduced template argument",
            "",
            "// Custom deduction guide",
            "template<typename T>",
            "struct Container {",
            "    Container(T t) {}",
            "};",
            "Container c = 5; // deduced as Container<int>",
            "$0"
        ],
        "description": "C++17 class template argument deduction"
    },
    "cpp_17__constexpr_lambda": {
        "prefix": "cpp_17__constexpr_lambda",
        "body": [
            "// C++17: constexpr lambda",
            "",
            "// Implicitly constexpr",
            "auto square = [](int n) { return n * n; };",
            "constexpr int result = square(5);",
            "",
            "// Explicitly constexpr",
            "auto factorial = [](int n) constexpr -> int {",
            "    return n <= 1 ? 1 : n * factorial(n - 1);",
            "};",
            "constexpr int fact5 = factorial(5);",
            "$0"
        ],
        "description": "C++17 constexpr lambda"
    },
    "cpp_17__attributes": {
        "prefix": "cpp_17__attributes",
        "body": [
            "// C++17: New attributes",
            "",
            "// [[nodiscard]] - warn if return value ignored",
            "[[nodiscard]] int important_result() { return 42; }",
            "",
            "// [[maybe_unused]] - suppress unused warnings",
            "[[maybe_unused]] void debug_function() {}",
            "",
            "// [[fallthrough]] - intentional switch fallthrough",
            "switch (x) {",
            "case 1:",
            "    do_something();",
            "    [[fallthrough]];",
            "case 2:",
            "    do_something_else();",
            "    break;",
            "}",
            "$0"
        ],
        "description": "C++17 attributes"
    },
    "cpp_17__parallel_algorithms": {
        "prefix": "cpp_17__parallel_algorithms",
        "body": [
            "// C++17: Parallel algorithms",
            "#include <algorithm>",
            "#include <execution>",
            "#include <vector>",
            "",
            "std::vector<int> v = {3, 1, 4, 1, 5, 9};",
            "",
            "// Sequential (default)",
            "std::sort(v.begin(), v.end());",
            "",
            "// Parallel",
            "std::sort(std::execution::par, v.begin(), v.end());",
            "",
            "// Parallel unsequenced",
            "std::sort(std::execution::par_unseq, v.begin(), v.end());",
            "",
            "// Works with many algorithms",
            "auto sum = std::reduce(std::execution::par,",
            "                      v.begin(), v.end(), 0);",
            "$0"
        ],
        "description": "C++17 parallel algorithms"
    },
    "cpp_17__guaranteed_copy_elision": {
        "prefix": "cpp_17__guaranteed_copy_elision",
        "body": [
            "// C++17: Guaranteed copy elision",
            "",
            "struct Heavy {",
            "    Heavy() { std::cout << \"Default\\n\"; }",
            "    Heavy(const Heavy&) { std::cout << \"Copy\\n\"; }",
            "    Heavy(Heavy&&) { std::cout << \"Move\\n\"; }",
            "};",
            "",
            "Heavy make_heavy() { return Heavy{}; }",
            "",
            "// C++17 guarantees no copy/move here",
            "Heavy h = make_heavy(); // Only \"Default\" printed",
            "",
            "// Direct initialization from temporary",
            "Heavy h2 = Heavy{}; // Only \"Default\" printed",
            "$0"
        ],
        "description": "C++17 guaranteed copy elision"
    },
    "cpp_17__std_any": {
        "prefix": "cpp_17__std_any",
        "body": [
            "// C++17: std::any",
            "#include <any>",
            "#include <typeinfo>",
            "",
            "std::any a = 1;",
            "std::cout << a.type().name() << \": \" << std::any_cast<int>(a) << std::endl;",
            "",
            "a = 3.14;",
            "std::cout << a.type().name() << \": \" << std::any_cast<double>(a) << std::endl;",
            "",
            "a = std::string(\"hello\");",
            "auto s = std::any_cast<std::string>(a);",
            "",
            "// Check if contains value",
            "if (a.has_value()) {",
            "    // Safe cast with pointer",
            "    if (auto* ptr = std::any_cast<std::string>(&a)) {",
            "        std::cout << *ptr << std::endl;",
            "    }",
            "}",
            "$0"
        ],
        "description": "C++17 std::any"
    },
    "cpp_17__std_byte": {
        "prefix": "cpp_17__std_byte",
        "body": [
            "// C++17: std::byte",
            "#include <cstddef>",
            "",
            "std::byte b{42};",
            "std::byte b2{0b11110000};",
            "",
            "// Bitwise operations",
            "b = b | std::byte{0x0F};",
            "b = b & std::byte{0xF0};",
            "b = b ^ std::byte{0xFF};",
            "b = ~b;",
            "",
            "// Convert to/from integer",
            "auto value = std::to_integer<int>(b);",
            "std::byte b3{static_cast<std::byte>(255)};",
            "",
            "// Array of bytes",
            "std::byte data[4] = {",
            "    std::byte{0x12}, std::byte{0x34},",
            "    std::byte{0x56}, std::byte{0x78}",
            "};",
            "$0"
        ],
        "description": "C++17 std::byte"
    },
    "cpp_17__deduction_guides": {
        "prefix": "cpp_17__deduction_guides",
        "body": [
            "// C++17: Deduction guides",
            "",
            "template<typename T>",
            "class MyContainer {",
            "    T* data;",
            "    std::size_t size;",
            "public:",
            "    MyContainer(T* ptr, std::size_t s) : data(ptr), size(s) {}",
            "};",
            "",
            "// Deduction guide",
            "template<typename T>",
            "MyContainer(T*, std::size_t) -> MyContainer<T>;",
            "",
            "// Usage",
            "int arr[] = {1, 2, 3};",
            "MyContainer c(arr, 3); // Deduced as MyContainer<int>",
            "",
            "// Iterator deduction guide example",
            "template<typename Iter>",
            "MyContainer(Iter, Iter) -> MyContainer<",
            "    typename std::iterator_traits<Iter>::value_type>;",
            "$0"
        ],
        "description": "C++17 deduction guides"
    },
    "cpp_17__std_invoke": {
        "prefix": "cpp_17__std_invoke",
        "body": [
            "// C++17: std::invoke",
            "#include <functional>",
            "",
            "// Regular function",
            "int add(int a, int b) { return a + b; }",
            "",
            "// Member function",
            "struct Foo {",
            "    int value = 10;",
            "    int multiply(int x) { return value * x; }",
            "};",
            "",
            "// Works with all callable types",
            "auto result1 = std::invoke(add, 5, 3);",
            "",
            "Foo foo;",
            "auto result2 = std::invoke(&Foo::multiply, foo, 2);",
            "auto result3 = std::invoke(&Foo::value, foo);",
            "",
            "// Lambda",
            "auto lambda = [](int x) { return x * x; };",
            "auto result4 = std::invoke(lambda, 5);",
            "$0"
        ],
        "description": "C++17 std::invoke"
    },
    "cpp_17__std_apply": {
        "prefix": "cpp_17__std_apply",
        "body": [
            "// C++17: std::apply",
            "#include <tuple>",
            "#include <functional>",
            "",
            "// Function to call",
            "int add(int a, int b, int c) {",
            "    return a + b + c;",
            "}",
            "",
            "// Tuple of arguments",
            "std::tuple<int, int, int> args(1, 2, 3);",
            "",
            "// Apply tuple as arguments",
            "auto result = std::apply(add, args); // result = 6",
            "",
            "// With lambda",
            "auto t = std::make_tuple(\"Hello\", \" \", \"World\");",
            "auto concat = std::apply(",
            "    [](const auto&... args) {",
            "        return (args + ...);",
            "    }, t);",
            "$0"
        ],
        "description": "C++17 std::apply"
    },
    "cpp_17__std_make_from_tuple": {
        "prefix": "cpp_17__std_make_from_tuple",
        "body": [
            "// C++17: std::make_from_tuple",
            "#include <tuple>",
            "",
            "struct Point {",
            "    int x, y, z;",
            "    Point(int x, int y, int z) : x(x), y(y), z(z) {}",
            "};",
            "",
            "// Create object from tuple",
            "auto t = std::make_tuple(10, 20, 30);",
            "auto point = std::make_from_tuple<Point>(t);",
            "",
            "// Works with any constructor",
            "auto str_tuple = std::make_tuple(5, 'A');",
            "auto str = std::make_from_tuple<std::string>(str_tuple);",
            "$0"
        ],
        "description": "C++17 std::make_from_tuple"
    },
    "cpp_17__has_include": {
        "prefix": "cpp_17__has_include",
        "body": [
            "// C++17: __has_include",
            "",
            "#if __has_include(<optional>)",
            "    #include <optional>",
            "    #define HAS_OPTIONAL 1",
            "#else",
            "    #define HAS_OPTIONAL 0",
            "#endif",
            "",
            "#if __has_include(<filesystem>)",
            "    #include <filesystem>",
            "    namespace fs = std::filesystem;",
            "#elif __has_include(<experimental/filesystem>)",
            "    #include <experimental/filesystem>",
            "    namespace fs = std::experimental::filesystem;",
            "#endif",
            "$0"
        ],
        "description": "C++17 __has_include"
    },
    "cpp_17__hex_float_literals": {
        "prefix": "cpp_17__hex_float_literals",
        "body": [
            "// C++17: Hexadecimal floating-point literals",
            "",
            "// Format: 0x<hex-digits>.<hex-digits>p<exponent>",
            "double d1 = 0x1.2p3;    // 1.125 * 2^3 = 9.0",
            "double d2 = 0x1p-2;     // 1.0 * 2^-2 = 0.25",
            "double d3 = 0x1.8p0;    // 1.5",
            "double d4 = 0xA.Bp10;   // 10.6875 * 2^10 = 10944.0",
            "",
            "// Useful for exact representation",
            "float exact_tenth = 0x1.999999999999Ap-4; // Exactly 0.1",
            "$0"
        ],
        "description": "C++17 hexadecimal floating-point literals"
    },
    "cpp_17__u8_char_literals": {
        "prefix": "cpp_17__u8_char_literals",
        "body": [
            "// C++17: u8 character literals",
            "",
            "// UTF-8 character literal",
            "char utf8_char = u8'x';",
            "",
            "// UTF-8 string literal",
            "const char* utf8_str = u8\"Hello, \u4e16\u754c\";",
            "",
            "// Note: In C++20, u8 literals have type char8_t",
            "// In C++17, they have type char",
            "",
            "// Check character value",
            "static_assert(u8'A' == 65);",
            "$0"
        ],
        "description": "C++17 u8 character literals"
    },
    "cpp_17__switch_with_initializer": {
        "prefix": "cpp_17__switch_with_initializer",
        "body": [
            "// C++17: switch with initializer",
            "",
            "// Switch with initializer",
            "switch (auto val = get_value(); val) {",
            "case 1:",
            "    handle_one(val);",
            "    break;",
            "case 2:",
            "    handle_two(val);",
            "    break;",
            "default:",
            "    handle_default(val);",
            "}",
            "",
            "// Useful with enums",
            "switch (Status s = get_status(); s) {",
            "case Status::OK:",
            "    return process(s);",
            "case Status::ERROR:",
            "    return handle_error(s);",
            "}",
            "$0"
        ],
        "description": "C++17 switch with initializer"
    },
    "cpp_17__scoped_lock": {
        "prefix": "cpp_17__scoped_lock",
        "body": [
            "// C++17: std::scoped_lock",
            "#include <mutex>",
            "",
            "std::mutex m1, m2, m3;",
            "",
            "// Lock multiple mutexes without deadlock",
            "{",
            "    std::scoped_lock lock(m1, m2, m3);",
            "    // All mutexes locked",
            "} // All mutexes unlocked",
            "",
            "// Single mutex (similar to lock_guard)",
            "{",
            "    std::scoped_lock lock(m1);",
            "    // Critical section",
            "}",
            "",
            "// Empty lock (no-op)",
            "std::scoped_lock lock{}; // Valid, does nothing",
            "$0"
        ],
        "description": "C++17 std::scoped_lock"
    },
    "cpp_17__shared_mutex": {
        "prefix": "cpp_17__shared_mutex",
        "body": [
            "// C++17: std::shared_mutex",
            "#include <shared_mutex>",
            "#include <mutex>",
            "",
            "class ThreadSafeCounter {",
            "    mutable std::shared_mutex mutex_;",
            "    int value_ = 0;",
            "public:",
            "    // Multiple readers",
            "    int get() const {",
            "        std::shared_lock lock(mutex_);",
            "        return value_;",
            "    }",
            "",
            "    // Single writer",
            "    void increment() {",
            "        std::unique_lock lock(mutex_);",
            "        ++value_;",
            "    }",
            "",
            "    // Try to acquire read lock",
            "    std::optional<int> try_get() const {",
            "        std::shared_lock lock(mutex_, std::try_to_lock);",
            "        if (lock) return value_;",
            "        return std::nullopt;",
            "    }",
            "};",
            "$0"
        ],
        "description": "C++17 std::shared_mutex"
    },
    "cpp_17__std_sample": {
        "prefix": "cpp_17__std_sample",
        "body": [
            "// C++17: std::sample",
            "#include <algorithm>",
            "#include <random>",
            "#include <iterator>",
            "",
            "std::vector<int> population = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};",
            "std::vector<int> sample(5);",
            "",
            "std::random_device rd;",
            "std::mt19937 gen(rd());",
            "",
            "// Sample 5 random elements",
            "std::sample(population.begin(), population.end(),",
            "            sample.begin(), 5, gen);",
            "",
            "// Sample to output iterator",
            "std::sample(population.begin(), population.end(),",
            "            std::ostream_iterator<int>(std::cout, \" \"),",
            "            3, gen);",
            "$0"
        ],
        "description": "C++17 std::sample"
    },
    "cpp_17__std_clamp": {
        "prefix": "cpp_17__std_clamp",
        "body": [
            "// C++17: std::clamp",
            "#include <algorithm>",
            "",
            "// Clamp value between min and max",
            "int value = 15;",
            "int clamped = std::clamp(value, 0, 10); // Returns 10",
            "",
            "// Works with any comparable type",
            "double d = 2.5;",
            "double clamped_d = std::clamp(d, 0.0, 1.0); // Returns 1.0",
            "",
            "// Custom comparator",
            "auto comp = [](const auto& a, const auto& b) {",
            "    return std::abs(a) < std::abs(b);",
            "};",
            "int result = std::clamp(-15, -10, 10, comp);",
            "$0"
        ],
        "description": "C++17 std::clamp"
    },
    "cpp_17__std_gcd_lcm": {
        "prefix": "cpp_17__std_gcd_lcm",
        "body": [
            "// C++17: std::gcd and std::lcm",
            "#include <numeric>",
            "",
            "// Greatest Common Divisor",
            "int a = 48, b = 18;",
            "int gcd_result = std::gcd(a, b); // 6",
            "",
            "// Least Common Multiple",
            "int lcm_result = std::lcm(a, b); // 144",
            "",
            "// Works with different integral types",
            "long long x = 12LL;",
            "int y = 8;",
            "auto gcd_xy = std::gcd(x, y); // 4",
            "",
            "// Useful for fractions",
            "struct Fraction {",
            "    int num, den;",
            "    void reduce() {",
            "        int g = std::gcd(num, den);",
            "        num /= g; den /= g;",
            "    }",
            "};",
            "$0"
        ],
        "description": "C++17 std::gcd and std::lcm"
    },
    "cpp_17__std_as_const": {
        "prefix": "cpp_17__std_as_const",
        "body": [
            "// C++17: std::as_const",
            "#include <utility>",
            "",
            "std::vector<int> v = {1, 2, 3};",
            "",
            "// Get const reference to avoid copying",
            "const auto& cv = std::as_const(v);",
            "",
            "// Useful for calling const overloads",
            "class Widget {",
            "public:",
            "    void process() { std::cout << \"non-const\\n\"; }",
            "    void process() const { std::cout << \"const\\n\"; }",
            "};",
            "",
            "Widget w;",
            "w.process();                    // calls non-const",
            "std::as_const(w).process();     // calls const",
            "$0"
        ],
        "description": "C++17 std::as_const"
    },
    "cpp_17__std_size_empty_data": {
        "prefix": "cpp_17__std_size_empty_data",
        "body": [
            "// C++17: std::size, std::empty, std::data",
            "#include <iterator>",
            "",
            "// Works with arrays and containers",
            "int arr[] = {1, 2, 3, 4, 5};",
            "auto arr_size = std::size(arr);        // 5",
            "auto arr_empty = std::empty(arr);      // false",
            "auto arr_data = std::data(arr);        // pointer to first element",
            "",
            "std::vector<int> vec = {1, 2, 3};",
            "auto vec_size = std::size(vec);        // 3",
            "auto vec_empty = std::empty(vec);      // false",
            "auto vec_data = std::data(vec);        // pointer to first element",
            "",
            "// Safer than sizeof(arr)/sizeof(arr[0])",
            "for (std::size_t i = 0; i < std::size(arr); ++i) {",
            "    std::cout << arr[i] << \" \";",
            "}",
            "$0"
        ],
        "description": "C++17 std::size, std::empty, std::data"
    },
    "cpp_17__std_launder": {
        "prefix": "cpp_17__std_launder",
        "body": [
            "// C++17: std::launder",
            "#include <new>",
            "",
            "// Used for accessing object through pointer after placement new",
            "struct X {",
            "    const int n;",
            "    X(int n) : n(n) {}",
            "};",
            "",
            "alignas(X) std::byte storage[sizeof(X)];",
            "",
            "// Create object",
            "X* p = new(&storage) X{42};",
            "",
            "// Destroy and create new object",
            "p->~X();",
            "new(&storage) X{13};",
            "",
            "// Need launder to access through old pointer",
            "int n = std::launder(p)->n; // OK, n = 13",
            "$0"
        ],
        "description": "C++17 std::launder"
    },
    "cpp_17__template_auto": {
        "prefix": "cpp_17__template_auto",
        "body": [
            "// C++17: Template parameter deduction with auto",
            "",
            "// Non-type template parameter with auto",
            "template<auto N>",
            "struct constant {",
            "    static constexpr auto value = N;",
            "};",
            "",
            "// Can deduce the type",
            "constant<5> c1;        // N is int",
            "constant<'A'> c2;      // N is char",
            "constant<2.5> c3;      // Error: floating point not allowed",
            "",
            "// Multiple auto parameters",
            "template<auto... Values>",
            "struct value_list {};",
            "",
            "value_list<1, 'a', true> values;",
            "$0"
        ],
        "description": "C++17 template auto"
    },
    "cpp_17__aggregate_initialization": {
        "prefix": "cpp_17__aggregate_initialization",
        "body": [
            "// C++17: Extended aggregate initialization",
            "",
            "// Base classes in aggregates",
            "struct Base {",
            "    int x;",
            "};",
            "",
            "struct Derived : Base {",
            "    int y;",
            "};",
            "",
            "// C++17 allows this",
            "Derived d{{1}, 2}; // Base::x = 1, Derived::y = 2",
            "",
            "// Designated initializers (C++20, but worth noting)",
            "struct Point3D {",
            "    int x = 0;",
            "    int y = 0;",
            "    int z = 0;",
            "};",
            "",
            "// C++17 style",
            "Point3D p1{1, 2, 3};",
            "Point3D p2{1, 2};     // z = 0 (default)",
            "$0"
        ],
        "description": "C++17 extended aggregate initialization"
    },
    "cpp_17__type_traits_helpers": {
        "prefix": "cpp_17__type_traits_helpers",
        "body": [
            "// C++17: Type traits helper variables",
            "#include <type_traits>",
            "",
            "// C++14 way",
            "std::is_integral<int>::value;",
            "std::is_same<int, int>::value;",
            "",
            "// C++17 way with _v suffix",
            "std::is_integral_v<int>;",
            "std::is_same_v<int, int>;",
            "std::is_pointer_v<int*>;",
            "std::is_const_v<const int>;",
            "",
            "// Conjunction, disjunction, negation",
            "template<typename T>",
            "constexpr bool is_string_like = std::disjunction_v<",
            "    std::is_same<T, std::string>,",
            "    std::is_same<T, std::string_view>,",
            "    std::is_same<T, const char*>",
            ">;",
            "$0"
        ],
        "description": "C++17 type traits helpers"
    },
    "cpp_design_pattern__creational__abstract_factory": {
        "prefix": "cpp_design_pattern__creational__abstract_factory",
        "description": "Implements the Abstract Factory pattern (Creational)",
        "body": [
            "class ${1:AbstractProductA} {",
            "public:",
            "    virtual void use() = 0;",
            "    virtual ~${1:AbstractProductA}() = default;",
            "};",
            "",
            "class ${2:AbstractProductB} {",
            "public:",
            "    virtual void interact() = 0;",
            "    virtual ~${2:AbstractProductB}() = default;",
            "};",
            "",
            "class ${3:ConcreteProductA1} : public ${1:AbstractProductA} {",
            "public:",
            "    void use() override { /* Implementation */ }",
            "};",
            "",
            "class ${4:ConcreteProductB1} : public ${2:AbstractProductB} {",
            "public:",
            "    void interact() override { /* Implementation */ }",
            "};",
            "",
            "class ${5:AbstractFactory} {",
            "public:",
            "    virtual ${1:AbstractProductA}* createProductA() = 0;",
            "    virtual ${2:AbstractProductB}* createProductB() = 0;",
            "    virtual ~${5:AbstractFactory}() = default;",
            "};",
            "",
            "class ${6:ConcreteFactory1} : public ${5:AbstractFactory} {",
            "public:",
            "    ${1:AbstractProductA}* createProductA() override { return new ${3:ConcreteProductA1}; }",
            "    ${2:AbstractProductB}* createProductB() override { return new ${4:ConcreteProductB1}; }",
            "};"
        ]
    },
    "cpp_design_pattern__creational__builder": {
        "prefix": "cpp_design_pattern__creational__builder",
        "description": "Implements the Builder pattern (Creational)",
        "body": [
            "class ${1:Product} {",
            "public:",
            "    void addPart(const std::string& part) { /* Add part */ }",
            "};",
            "",
            "class ${2:Builder} {",
            "public:",
            "    virtual void buildPartA() = 0;",
            "    virtual void buildPartB() = 0;",
            "    virtual ${1:Product}* getResult() = 0;",
            "    virtual ~${2:Builder}() = default;",
            "};",
            "",
            "class ${3:ConcreteBuilder} : public ${2:Builder} {",
            "private:",
            "    ${1:Product}* product = new ${1:Product};",
            "public:",
            "    void buildPartA() override { product->addPart(\"PartA\"); }",
            "    void buildPartB() override { product->addPart(\"PartB\"); }",
            "    ${1:Product}* getResult() override { return product; }",
            "};",
            "",
            "class ${4:Director} {",
            "public:",
            "    void construct(${2:Builder}* builder) {",
            "        builder->buildPartA();",
            "        builder->buildPartB();",
            "    }",
            "};"
        ]
    },
    "cpp_design_pattern__creational__factory_method": {
        "prefix": "cpp_design_pattern__creational__factory_method",
        "description": "Implements the Factory Method pattern (Creational)",
        "body": [
            "class ${1:Product} {",
            "public:",
            "    virtual void use() = 0;",
            "    virtual ~${1:Product}() = default;",
            "};",
            "",
            "class ${2:ConcreteProduct} : public ${1:Product} {",
            "public:",
            "    void use() override { /* Implementation */ }",
            "};",
            "",
            "class ${3:Creator} {",
            "public:",
            "    virtual ${1:Product}* factoryMethod() = 0;",
            "    virtual ~${3:Creator}() = default;",
            "};",
            "",
            "class ${4:ConcreteCreator} : public ${3:Creator} {",
            "public:",
            "    ${1:Product}* factoryMethod() override { return new ${2:ConcreteProduct}; }",
            "};"
        ]
    },
    "cpp_design_pattern__creational__prototype": {
        "prefix": "cpp_design_pattern__creational__prototype",
        "description": "Implements the Prototype pattern (Creational)",
        "body": [
            "class ${1:Prototype} {",
            "public:",
            "    virtual ${1:Prototype}* clone() const = 0;",
            "    virtual void use() = 0;",
            "    virtual ~${1:Prototype}() = default;",
            "};",
            "",
            "class ${2:ConcretePrototype} : public ${1:Prototype} {",
            "private:",
            "    int data;",
            "public:",
            "    ${2:ConcretePrototype}(int d) : data(d) {}",
            "    ${1:Prototype}* clone() const override { return new ${2:ConcretePrototype}(data); }",
            "    void use() override { /* Implementation */ }",
            "};"
        ]
    },
    "cpp_design_pattern__creational__singleton": {
        "prefix": "cpp_design_pattern__creational__singleton",
        "description": "Implements a thread-safe Singleton pattern (Creational)",
        "body": [
            "class ${1:Singleton} {",
            "public:",
            "    static ${1:Singleton}& getInstance() {",
            "        static ${1:Singleton} instance;",
            "        return instance;",
            "    }",
            "",
            "    ${1:Singleton}(${1:Singleton} const&) = delete;",
            "    void operator=(${1:Singleton} const&) = delete;",
            "",
            "private:",
            "    ${1:Singleton}() { /* Initialize */ }",
            "    ${0}",
            "};"
        ]
    },
    "cpp_design_pattern__structural__adapter": {
        "prefix": "cpp_design_pattern__structural__adapter",
        "description": "Implements the Adapter pattern (Structural)",
        "body": [
            "class ${1:Target} {",
            "public:",
            "    virtual void request() const = 0;",
            "    virtual ~${1:Target}() = default;",
            "};",
            "",
            "class ${2:Adaptee} {",
            "public:",
            "    void specificRequest() const { /* Implementation */ }",
            "};",
            "",
            "class ${3:Adapter} : public ${1:Target} {",
            "private:",
            "    ${2:Adaptee}* adaptee;",
            "public:",
            "    ${3:Adapter}(${2:Adaptee}* a) : adaptee(a) {}",
            "    void request() const override { adaptee->specificRequest(); }",
            "};"
        ]
    },
    "cpp_design_pattern__structural__bridge": {
        "prefix": "cpp_design_pattern__structural__bridge",
        "description": "Implements the Bridge pattern (Structural)",
        "body": [
            "class ${1:Implementor} {",
            "public:",
            "    virtual void operationImpl() = 0;",
            "    virtual ~${1:Implementor}() = default;",
            "};",
            "",
            "class ${2:ConcreteImplementor} : public ${1:Implementor} {",
            "public:",
            "    void operationImpl() override { /* Implementation */ }",
            "};",
            "",
            "class ${3:Abstraction} {",
            "protected:",
            "    ${1:Implementor}* implementor;",
            "public:",
            "    ${3:Abstraction}(${1:Implementor}* impl) : implementor(impl) {}",
            "    virtual void operation() { implementor->operationImpl(); }",
            "    virtual ~${3:Abstraction}() = default;",
            "};"
        ]
    },
    "cpp_design_pattern__structural__composite": {
        "prefix": "cpp_design_pattern__structural__composite",
        "description": "Implements the Composite pattern (Structural)",
        "body": [
            "#include <vector>",
            "",
            "class ${1:Component} {",
            "public:",
            "    virtual void operation() = 0;",
            "    virtual ~${1:Component}() = default;",
            "};",
            "",
            "class ${2:Leaf} : public ${1:Component} {",
            "public:",
            "    void operation() override { /* Leaf operation */ }",
            "};",
            "",
            "class ${3:Composite} : public ${1:Component} {",
            "private:",
            "    std::vector<${1:Component}*> children;",
            "public:",
            "    void add(${1:Component}* component) { children.push_back(component); }",
            "    void operation() override {",
            "        for (auto* child : children) child->operation();",
            "    }",
            "};"
        ]
    },
    "cpp_design_pattern__structural__decorator": {
        "prefix": "cpp_design_pattern__structural__decorator",
        "description": "Implements the Decorator pattern (Structural)",
        "body": [
            "class ${1:Component} {",
            "public:",
            "    virtual void operation() const = 0;",
            "    virtual ~${1:Component}() = default;",
            "};",
            "",
            "class ${2:ConcreteComponent} : public ${1:Component} {",
            "public:",
            "    void operation() const override { /* Core functionality */ }",
            "};",
            "",
            "class ${3:Decorator} : public ${1:Component} {",
            "protected:",
            "    ${1:Component}* component;",
            "public:",
            "    ${3:Decorator}(${1:Component}* comp) : component(comp) {}",
            "    void operation() const override { component->operation(); /* Add behavior */ }",
            "};"
        ]
    },
    "cpp_design_pattern__structural__facade": {
        "prefix": "cpp_design_pattern__structural__facade",
        "description": "Implements the Facade pattern (Structural)",
        "body": [
            "class ${1:Subsystem1} {",
            "public:",
            "    void operation1() const { /* Subsystem1 logic */ }",
            "};",
            "",
            "class ${2:Subsystem2} {",
            "public:",
            "    void operation2() const { /* Subsystem2 logic */ }",
            "};",
            "",
            "class ${3:Facade} {",
            "private:",
            "    ${1:Subsystem1} subsystem1;",
            "    ${2:Subsystem2} subsystem2;",
            "public:",
            "    void operation() {",
            "        subsystem1.operation1();",
            "        subsystem2.operation2();",
            "    }",
            "};"
        ]
    },
    "cpp_design_pattern__structural__flyweight": {
        "prefix": "cpp_design_pattern__structural__flyweight",
        "description": "Implements the Flyweight pattern (Structural)",
        "body": [
            "#include <unordered_map>",
            "",
            "class ${1:Flyweight} {",
            "public:",
            "    virtual void operation(int extrinsicState) = 0;",
            "    virtual ~${1:Flyweight}() = default;",
            "};",
            "",
            "class ${2:ConcreteFlyweight} : public ${1:Flyweight} {",
            "private:",
            "    int intrinsicState;",
            "public:",
            "    ${2:ConcreteFlyweight}(int state) : intrinsicState(state) {}",
            "    void operation(int extrinsicState) override { /* Use intrinsic/extrinsic state */ }",
            "};",
            "",
            "class ${3:FlyweightFactory} {",
            "private:",
            "    std::unordered_map<int, ${1:Flyweight}*> flyweights;",
            "public:",
            "    ${1:Flyweight}* getFlyweight(int key) {",
            "        if (flyweights.find(key) == flyweights.end()) {",
            "            flyweights[key] = new ${2:ConcreteFlyweight}(key);",
            "        }",
            "        return flyweights[key];",
            "    }",
            "};"
        ]
    },
    "cpp_design_pattern__structural__proxy": {
        "prefix": "cpp_design_pattern__structural__proxy",
        "description": "Implements the Proxy pattern (Structural)",
        "body": [
            "class ${1:Subject} {",
            "public:",
            "    virtual void request() = 0;",
            "    virtual ~${1:Subject}() = default;",
            "};",
            "",
            "class ${2:RealSubject} : public ${1:Subject} {",
            "public:",
            "    void request() override { /* Real implementation */ }",
            "};",
            "",
            "class ${3:Proxy} : public ${1:Subject} {",
            "private:",
            "    ${2:RealSubject}* realSubject = nullptr;",
            "public:",
            "    void request() override {",
            "        if (!realSubject) realSubject = new ${2:RealSubject};",
            "        realSubject->request();",
            "    }",
            "};"
        ]
    },
    "cpp_design_pattern__behavioral__chain_of_responsibility": {
        "prefix": "cpp_design_pattern__behavioral__chain_of_responsibility",
        "description": "Implements the Chain of Responsibility pattern (Behavioral)",
        "body": [
            "class ${1:Handler} {",
            "public:",
            "    virtual void setNext(${1:Handler}* next) = 0;",
            "    virtual void handleRequest(int request) = 0;",
            "    virtual ~${1:Handler}() = default;",
            "};",
            "",
            "class ${2:ConcreteHandler} : public ${1:Handler} {",
            "private:",
            "    ${1:Handler}* nextHandler = nullptr;",
            "public:",
            "    void setNext(${1:Handler}* next) override { nextHandler = next; }",
            "    void handleRequest(int request) override {",
            "        if (/* condition */) { /* Handle */ }",
            "        else if (nextHandler) nextHandler->handleRequest(request);",
            "    }",
            "};"
        ]
    },
    "cpp_design_pattern__behavioral__command": {
        "prefix": "cpp_design_pattern__behavioral__command",
        "description": "Implements the Command pattern (Behavioral)",
        "body": [
            "class ${1:Command} {",
            "public:",
            "    virtual void execute() = 0;",
            "    virtual ~${1:Command}() = default;",
            "};",
            "",
            "class ${2:Receiver} {",
            "public:",
            "    void action() { /* Implementation */ }",
            "};",
            "",
            "class ${3:ConcreteCommand} : public ${1:Command} {",
            "private:",
            "    ${2:Receiver}* receiver;",
            "public:",
            "    ${3:ConcreteCommand}(${2:Receiver}* r) : receiver(r) {}",
            "    void execute() override { receiver->action(); }",
            "};",
            "",
            "class ${4:Invoker} {",
            "private:",
            "    ${1:Command}* command;",
            "public:",
            "    void setCommand(${1:Command}* cmd) { command = cmd; }",
            "    void executeCommand() { command->execute(); }",
            "};"
        ]
    },
    "cpp_design_pattern__behavioral__interpreter": {
        "prefix": "cpp_design_pattern__behavioral__interpreter",
        "description": "Implements the Interpreter pattern (Behavioral)",
        "body": [
            "class ${1:Expression} {",
            "public:",
            "    virtual int interpret() = 0;",
            "    virtual ~${1:Expression}() = default;",
            "};",
            "",
            "class ${2:TerminalExpression} : public ${1:Expression} {",
            "private:",
            "    int value;",
            "public:",
            "    ${2:TerminalExpression}(int val) : value(val) {}",
            "    int interpret() override { return value; }",
            "};",
            "",
            "class ${3:NonTerminalExpression} : public ${1:Expression} {",
            "private:",
            "    ${1:Expression}* left;",
            "    ${1:Expression}* right;",
            "public:",
            "    ${3:NonTerminalExpression}(${1:Expression}* l, ${1:Expression}* r) : left(l), right(r) {}",
            "    int interpret() override { return left->interpret() + right->interpret(); }",
            "};"
        ]
    },
    "cpp_design_pattern__behavioral__iterator": {
        "prefix": "cpp_design_pattern__behavioral__iterator",
        "description": "Implements the Iterator pattern (Behavioral)",
        "body": [
            "#include <vector>",
            "",
            "class ${1:Iterator} {",
            "public:",
            "    virtual bool hasNext() = 0;",
            "    virtual int next() = 0;",
            "    virtual ~${1:Iterator}() = default;",
            "};",
            "",
            "class ${2:Aggregate} {",
            "public:",
            "    virtual ${1:Iterator}* createIterator() = 0;",
            "    virtual ~${2:Aggregate}() = default;",
            "};",
            "",
            "class ${3:ConcreteAggregate} : public ${2:Aggregate} {",
            "private:",
            "    std::vector<int> items;",
            "public:",
            "    ${1:Iterator}* createIterator() override;",
            "    void add(int item) { items.push_back(item); }",
            "};",
            "",
            "class ${4:ConcreteIterator} : public ${1:Iterator} {",
            "private:",
            "    ${3:ConcreteAggregate}* aggregate;",
            "    size_t index = 0;",
            "public:",
            "    ${4:ConcreteIterator}(${3:ConcreteAggregate}* agg) : aggregate(agg) {}",
            "    bool hasNext() override { return index < aggregate->items.size(); }",
            "    int next() override { return aggregate->items[index++]; }",
            "};"
        ]
    },
    "cpp_design_pattern__behavioral__mediator": {
        "prefix": "cpp_design_pattern__behavioral__mediator",
        "description": "Implements the Mediator pattern (Behavioral)",
        "body": [
            "class ${1:Mediator} {",
            "public:",
            "    virtual void notify(class ${2:Colleague}* sender, const std::string& event) = 0;",
            "    virtual ~${1:Mediator}() = default;",
            "};",
            "",
            "class ${2:Colleague} {",
            "protected:",
            "    ${1:Mediator}* mediator;",
            "public:",
            "    ${2:Colleague}(${1:Mediator}* m) : mediator(m) {}",
            "};",
            "",
            "class ${3:ConcreteColleague} : public ${2:Colleague} {",
            "public:",
            "    ${3:ConcreteColleague}(${1:Mediator}* m) : ${2:Colleague}(m) {}",
            "    void send(const std::string& event) { mediator->notify(this, event); }",
            "    void receive(const std::string& event) { /* Handle event */ }",
            "};",
            "",
            "class ${4:ConcreteMediator} : public ${1:Mediator} {",
            "private:",
            "    ${3:ConcreteColleague}* colleague1;",
            "    ${3:ConcreteColleague}* colleague2;",
            "public:",
            "    void setColleagues(${3:ConcreteColleague}* c1, ${3:ConcreteColleague}* c2) {",
            "        colleague1 = c1; colleague2 = c2;",
            "    }",
            "    void notify(${2:Colleague}* sender, const std::string& event) override {",
            "        if (sender == colleague1) colleague2->receive(event);",
            "        else colleague1->receive(event);",
            "    }",
            "};"
        ]
    },
    "cpp_design_pattern__behavioral__memento": {
        "prefix": "cpp_design_pattern__behavioral__memento",
        "description": "Implements the Memento pattern (Behavioral)",
        "body": [
            "class ${1:Memento} {",
            "private:",
            "    std::string state;",
            "public:",
            "    ${1:Memento}(const std::string& s) : state(s) {}",
            "    std::string getState() const { return state; }",
            "};",
            "",
            "class ${2:Originator} {",
            "private:",
            "    std::string state;",
            "public:",
            "    void setState(const std::string& s) { state = s; }",
            "    ${1:Memento}* createMemento() { return new ${1:Memento}(state); }",
            "    void restore(${1:Memento}* memento) { state = memento->getState(); }",
            "};",
            "",
            "class ${3:Caretaker} {",
            "private:",
            "    ${1:Memento}* memento;",
            "public:",
            "    void save(${1:Memento}* m) { memento = m; }",
            "    ${1:Memento}* getMemento() { return memento; }",
            "};"
        ]
    },
    "cpp_design_pattern__behavioral__observer": {
        "prefix": "cpp_design_pattern__behavioral__observer",
        "description": "Implements the Observer pattern (Behavioral)",
        "body": [
            "#include <vector>",
            "",
            "class ${1:Observer} {",
            "public:",
            "    virtual void update() = 0;",
            "    virtual ~${1:Observer}() = default;",
            "};",
            "",
            "class ${2:Subject} {",
            "private:",
            "    std::vector<${1:Observer}*> observers;",
            "public:",
            "    void attach(${1:Observer}* observer) { observers.push_back(observer); }",
            "    void detach(${1:Observer}* observer) { /* Remove observer */ }",
            "    void notify() { for (auto* obs : observers) obs->update(); }",
            "};"
        ]
    },
    "cpp_design_pattern__behavioral__state": {
        "prefix": "cpp_design_pattern__behavioral__state",
        "description": "Implements the State pattern (Behavioral)",
        "body": [
            "class ${1:State} {",
            "public:",
            "    virtual void handle(class ${2:Context}* context) = 0;",
            "    virtual ~${1:State}() = default;",
            "};",
            "",
            "class ${2:Context} {",
            "private:",
            "    ${1:State}* state;",
            "public:",
            "    ${2:Context}(${1:State}* s) : state(s) {}",
            "    void setState(${1:State}* s) { state = s; }",
            "    void request() { state->handle(this); }",
            "};",
            "",
            "class ${3:ConcreteState} : public ${1:State} {",
            "public:",
            "    void handle(${2:Context}* context) override { /* Transition logic */ }",
            "};"
        ]
    },
    "cpp_design_pattern__behavioral__strategy": {
        "prefix": "cpp_design_pattern__behavioral__strategy",
        "description": "Implements the Strategy pattern (Behavioral)",
        "body": [
            "class ${1:Strategy} {",
            "public:",
            "    virtual void execute() = 0;",
            "    virtual ~${1:Strategy}() = default;",
            "};",
            "",
            "class ${2:ConcreteStrategy} : public ${1:Strategy} {",
            "public:",
            "    void execute() override { /* Implementation */ }",
            "};",
            "",
            "class ${3:Context} {",
            "private:",
            "    ${1:Strategy}* strategy;",
            "public:",
            "    ${3:Context}(${1:Strategy}* s) : strategy(s) {}",
            "    void setStrategy(${1:Strategy}* s) { strategy = s; }",
            "    void executeStrategy() { strategy->execute(); }",
            "};"
        ]
    },
    "cpp_design_pattern__behavioral__template_method": {
        "prefix": "cpp_design_pattern__behavioral__template_method",
        "description": "Implements the Template Method pattern (Behavioral)",
        "body": [
            "class ${1:AbstractClass} {",
            "public:",
            "    void templateMethod() {",
            "        step1();",
            "        step2();",
            "    }",
            "protected:",
            "    virtual void step1() = 0;",
            "    virtual void step2() = 0;",
            "    virtual ~${1:AbstractClass}() = default;",
            "};",
            "",
            "class ${2:ConcreteClass} : public ${1:AbstractClass} {",
            "protected:",
            "    void step1() override { /* Implementation */ }",
            "    void step2() override { /* Implementation */ }",
            "};"
        ]
    },
    "cpp_design_pattern__behavioral__visitor": {
        "prefix": "cpp_design_pattern__behavioral__visitor",
        "description": "Implements the Visitor pattern (Behavioral)",
        "body": [
            "class ${1:Visitor} {",
            "public:",
            "    virtual void visit(class ${2:ElementA}* element) = 0;",
            "    virtual void visit(class ${3:ElementB}* element) = 0;",
            "    virtual ~${1:Visitor}() = default;",
            "};",
            "",
            "class ${4:Element} {",
            "public:",
            "    virtual void accept(${1:Visitor}* visitor) = 0;",
            "    virtual ~${4:Element}() = default;",
            "};",
            "",
            "class ${2:ElementA} : public ${4:Element} {",
            "public:",
            "    void accept(${1:Visitor}* visitor) override { visitor->visit(this); }",
            "};",
            "",
            "class ${3:ElementB} : public ${4:Element} {",
            "public:",
            "    void accept(${1:Visitor}* visitor) override { visitor->visit(this); }",
            "};"
        ]
    },
    "cpp_concurrency__std_thread": {
        "prefix": "cpp_concurrency__std_thread",
        "body": [
            "// C++ Concurrency: std::thread basics",
            "// std::thread is the fundamental building block for concurrency in C++.",
            "// It represents a single thread of execution.",
            "// Reference: https://en.cppreference.com/w/cpp/thread/thread",
            "#include <iostream>",
            "#include <thread>",
            "#include <chrono>",
            "#include <vector>",
            "#include <functional>",
            "",
            "// Function to be executed by a thread",
            "void task_function(int id) {",
            "    std::cout << \"Task \" << id << \" running on thread \" << std::this_thread::get_id() << std::endl;",
            "    std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Simulate work",
            "    std::cout << \"Task \" << id << \" finished.\" << std::endl;",
            "}",
            "",
            "// Class with an overloaded operator() (functor) to be executed by a thread",
            "class TaskObject {",
            "public:",
            "    void operator()(int id) const { // operator() must be const if passed by value",
            "        std::cout << \"Task object \" << id << \" running on thread \" << std::this_thread::get_id() << std::endl;",
            "        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Simulate work",
            "        std::cout << \"Task object \" << id << \" finished.\" << std::endl;",
            "    }",
            "};",
            "",
            "int main() {",
            "    std::cout << \"Main thread ID: \" << std::this_thread::get_id() << \"\\n\\n\";",
            "",
            "    // 1. Launching a thread with a regular function",
            "    // Arguments are passed by value by default.",
            "    std::thread t1(task_function, 1);",
            "    std::cout << \"t1 launched.\\n\";",
            "",
            "    // 2. Launching a thread with a lambda expression",
            "    // Lambdas are often convenient for short, inline tasks.",
            "    std::thread t2([](int id) {",
            "        std::cout << \"Lambda task \" << id << \" running on thread \" << std::this_thread::get_id() << std::endl;",
            "        std::this_thread::sleep_for(std::chrono::milliseconds(100));",
            "        std::cout << \"Lambda task \" << id << \" finished.\" << std::endl;",
            "    }, 2);",
            "    std::cout << \"t2 launched.\\n\";",
            "",
            "    // 3. Launching a thread with a function object (functor)",
            "    // If the functor has state, a copy is made for the thread.",
            "    TaskObject to;",
            "    std::thread t3(to, 3);",
            "    std::cout << \"t3 launched.\\n\";",
            "",
            "    // 4. Passing arguments by reference (requires std::ref)",
            "    int shared_var = 0;",
            "    std::mutex mtx_ref;",
            "    std::thread t4([&](int& val) {",
            "        std::lock_guard<std::mutex> lock(mtx_ref);",
            "        val += 100;",
            "        std::cout << \"Thread \" << std::this_thread::get_id() << \": shared_var updated to \" << val << std::endl;",
            "    }, std::ref(shared_var));",
            "    std::cout << \"t4 launched.\\n\";",
            "",
            "    // Joining threads: The main thread waits for the launched threads to complete.",
            "    // It's crucial to join or detach a thread before its std::thread object is destroyed,",
            "    // otherwise, std::terminate() will be called.",
            "    std::cout << \"\\nJoining threads...\\n\";",
            "    if (t1.joinable()) {",
            "        t1.join();",
            "        std::cout << \"t1 joined.\\n\";",
            "    }",
            "    if (t2.joinable()) {",
            "        t2.join();",
            "        std::cout << \"t2 joined.\\n\";",
            "    }",
            "    if (t3.joinable()) {",
            "        t3.join();",
            "        std::cout << \"t3 joined.\\n\";",
            "    }",
            "    if (t4.joinable()) {",
            "        t4.join();",
            "        std::cout << \"t4 joined.\\n\";",
            "    }",
            "    std::cout << \"Shared variable after t4: \" << shared_var << \"\\n\";",
            "",
            "    // 5. Detaching a thread: The thread runs independently in the background.",
            "    // The std::thread object no longer manages the thread of execution.",
            "    // Be extremely careful with detached threads, as they can outlive the resources they access.",
            "    // Ensure any shared resources are properly managed (e.g., smart pointers, global mutexes).",
            "    std::thread t5(task_function, 5);",
            "    t5.detach();",
            "    std::cout << \"t5 detached. It will run independently.\\n\";",
            "",
            "    // Main thread continues execution and might finish before detached thread.",
            "    std::cout << \"Main thread finished.\\n\";",
            "    return 0;",
            "}",
            "$0"
        ],
        "description": "C++ Concurrency: std::thread basics, launching, joining, detaching, and passing arguments. Reference: https://en.cppreference.com/w/cpp/thread/thread"
    },
    "cpp_concurrency__std_mutex": {
        "prefix": "cpp_concurrency__std_mutex",
        "body": [
            "// C++ Concurrency: Mutexes and Locks",
            "// Mutexes (Mutual Exclusion) are fundamental synchronization primitives used to protect shared data from concurrent access by multiple threads.",
            "// They ensure that only one thread can access a critical section of code at a time, preventing data races.",
            "// Reference: https://en.cppreference.com/w/cpp/thread/mutex",
            "#include <iostream>",
            "#include <thread>",
            "#include <mutex>",
            "#include <vector>",
            "#include <chrono>",
            "#include <numeric>",
            "",
            "// --- std::mutex ---",
            "// The basic mutex type. Provides exclusive ownership.",
            "std::mutex basic_mtx;",
            "int shared_data_basic = 0;",
            "",
            "void increment_basic_data() {",
            "    for (int i = 0; i < 10000; ++i) {",
            "        // Option 1: Manual lock/unlock (prone to errors if exceptions occur or unlock is forgotten)",
            "        // basic_mtx.lock();",
            "        // shared_data_basic++;",
            "        // basic_mtx.unlock();",
            "",
            "        // Option 2: std::lock_guard (RAII - Resource Acquisition Is Initialization)",
            "        // Preferred for simple, block-scoped locks. Automatically locks on construction and unlocks on destruction.",
            "        // Reference: https://en.cppreference.com/w/cpp/thread/lock_guard",
            "        std::lock_guard<std::mutex> lock(basic_mtx);",
            "        shared_data_basic++;",
            "    }",
            "}",
            "",
            "// --- std::unique_lock ---",
            "// More flexible than std::lock_guard. Allows deferred locking, timed locking, recursive locking, and moving ownership.",
            "// Reference: https://en.cppreference.com/w/cpp/thread/unique_lock",
            "void access_shared_data_unique_lock() {",
            "    std::unique_lock<std::mutex> lock(basic_mtx, std::defer_lock); // Create lock object but don't lock yet",
            "    std::cout << \"Thread \" << std::this_thread::get_id() << \": Doing some work before locking...\\n\";",
            "    std::this_thread::sleep_for(std::chrono::milliseconds(50));",
            "",
            "    lock.lock(); // Explicitly lock the mutex",
            "    std::cout << \"Thread \" << std::this_thread::get_id() << \": Unique lock acquired. shared_data_basic = \" << shared_data_basic << std::endl;",
            "    std::this_thread::sleep_for(std::chrono::milliseconds(50));",
            "    lock.unlock(); // Explicitly unlock the mutex (can be relocked)",
            "    std::cout << \"Thread \" << std::this_thread::get_id() << \": Unique lock released. Doing more work...\\n\";",
            "    std::this_thread::sleep_for(std::chrono::milliseconds(50));",
            "",
            "    lock.lock(); // Can relock the mutex",
            "    std::cout << \"Thread \" << std::this_thread::get_id() << \": Unique lock (relocked). shared_data_basic = \" << shared_data_basic << std::endl;",
            "    // Mutex is automatically unlocked when 'lock' goes out of scope.",
            "}",
            "",
            "// --- std::recursive_mutex ---",
            "// A mutex that can be locked multiple times by the *same* thread without causing a deadlock.",
            "// Each lock must be matched by an unlock. Not recommended for general use due to potential for misuse.",
            "// Reference: https://en.cppreference.com/w/cpp/thread/recursive_mutex",
            "std::recursive_mutex recursive_mtx;",
            "int recursive_data = 0;",
            "",
            "void recursive_function(int depth) {",
            "    if (depth > 0) {",
            "        std::lock_guard<std::recursive_mutex> lock(recursive_mtx);",
            "        recursive_data++;",
            "        std::cout << \"Thread \" << std::this_thread::get_id() << \": Recursive lock depth \" << depth << \", data = \" << recursive_data << std::endl;",
            "        recursive_function(depth - 1);",
            "    }",
            "}",
            "",
            "// --- std::timed_mutex ---",
            "// A mutex that supports timed locking (try_lock_for, try_lock_until).",
            "// Useful when a thread needs to attempt to acquire a lock but not block indefinitely.",
            "// Reference: https://en.cppreference.com/w/cpp/thread/timed_mutex",
            "std::timed_mutex timed_mtx;",
            "int timed_data = 0;",
            "",
            "void timed_worker(int id) {",
            "    std::cout << \"Timed Worker \" << id << \": Trying to acquire lock...\\n\";",
            "    if (timed_mtx.try_lock_for(std::chrono::milliseconds(100))) { // Try to lock for 100ms",
            "        std::cout << \"Timed Worker \" << id << \": Acquired lock. Data = \" << ++timed_data << std::endl;",
            "        std::this_thread::sleep_for(std::chrono::milliseconds(200)); // Hold lock for a bit",
            "        timed_mtx.unlock();",
            "        std::cout << \"Timed Worker \" << id << \": Released lock.\\n\";",
            "    } else {",
            "        std::cout << \"Timed Worker \" << id << \": Could not acquire lock in time.\\n\";",
            "    }",
            "}",
            "",
            "// --- std::scoped_lock (C++17) ---",
            "// A variadic lock guard that can lock multiple mutexes at once, preventing deadlocks.",
            "// It uses a deadlock-avoidance algorithm (e.g., std::lock).",
            "// Reference: https://en.cppreference.com/w/cpp/thread/scoped_lock",
            "std::mutex mtxA, mtxB;",
            "int resourceA = 0;",
            "int resourceB = 0;",
            "",
            "void deadlock_free_worker(int id) {",
            "    std::cout << \"Scoped Lock Worker \" << id << \": Trying to lock both mutexes...\\n\";",
            "    // Locks mtxA and mtxB in a deadlock-safe manner.",
            "    std::scoped_lock lock(mtxA, mtxB); ",
            "    resourceA++;",
            "    resourceB++;",
            "    std::cout << \"Scoped Lock Worker \" << id << \": Acquired both locks. A=\" << resourceA << \", B=\" << resourceB << std::endl;",
            "    std::this_thread::sleep_for(std::chrono::milliseconds(150));",
            "} // Locks are automatically released on scope exit",
            "",
            "int main() {",
            "    std::cout << \"--- std::mutex and std::lock_guard example ---\\n\";",
            "    std::vector<std::thread> threads_basic;",
            "    for (int i = 0; i < 10; ++i) {",
            "        threads_basic.emplace_back(increment_basic_data);",
            "    }",
            "    for (auto& t : threads_basic) { t.join(); }",
            "    std::cout << \"Final shared_data_basic (should be 100000): \" << shared_data_basic << \"\\n\\n\";",
            "",
            "    std::cout << \"--- std::unique_lock example ---\\n\";",
            "    std::thread t_unique_lock(access_shared_data_unique_lock);",
            "    t_unique_lock.join();",
            "    std::cout << \"\\n\";",
            "",
            "    std::cout << \"--- std::recursive_mutex example ---\\n\";",
            "    std::thread t_recursive(recursive_function, 3);",
            "    t_recursive.join();",
            "    std::cout << \"Final recursive_data: \" << recursive_data << \"\\n\\n\";",
            "",
            "    std::cout << \"--- std::timed_mutex example ---\\n\";",
            "    std::vector<std::thread> threads_timed;",
            "    for (int i = 0; i < 3; ++i) {",
            "        threads_timed.emplace_back(timed_worker, i + 1);",
            "    }",
            "    for (auto& t : threads_timed) { t.join(); }",
            "    std::cout << \"Final timed_data: \" << timed_data << \"\\n\\n\";",
            "",
            "    std::cout << \"--- std::scoped_lock example (C++17) ---\\n\";",
            "    std::vector<std::thread> threads_scoped;",
            "    for (int i = 0; i < 3; ++i) {",
            "        threads_scoped.emplace_back(deadlock_free_worker, i + 1);",
            "    }",
            "    for (auto& t : threads_scoped) { t.join(); }",
            "    std::cout << \"Final resourceA: \" << resourceA << \", Final resourceB: \" << resourceB << \"\\n\\n\";",
            "",
            "    std::cout << \"Main thread finished.\\n\";",
            "    return 0;",
            "}",
            "$0"
        ],
        "description": "C++ Concurrency: Mutexes and Locks (std::mutex, std::lock_guard, std::unique_lock, std::recursive_mutex, std::timed_mutex, std::scoped_lock). References: https://en.cppreference.com/w/cpp/thread/mutex, https://en.cppreference.com/w/cpp/thread/lock_guard, https://en.cppreference.com/w/cpp/thread/unique_lock, https://en.cppreference.com/w/cpp/thread/recursive_mutex, https://en.cppreference.com/w/cpp/thread/timed_mutex, https://en.cppreference.com/w/cpp/thread/scoped_lock"
    },
    "cpp_concurrency__std_condition_variable": {
        "prefix": "cpp_concurrency__std_condition_variable",
        "body": [
            "// C++ Concurrency: std::condition_variable (Producer-Consumer Pattern)",
            "// std::condition_variable allows threads to wait until a certain condition is met.",
            "// It's typically used with a std::mutex and a predicate to avoid spurious wakeups.",
            "// Reference: https://en.cppreference.com/w/cpp/thread/condition_variable",
            "#include <iostream>",
            "#include <thread>",
            "#include <mutex>",
            "#include <condition_variable>",
            "#include <queue>",
            "#include <string>",
            "#include <chrono>",
            "",
            "std::mutex mtx_cv;",
            "std::condition_variable cv;",
            "std::queue<std::string> data_queue;",
            "bool finished_producing = false;",
            "",
            "void producer() {",
            "    std::cout << \"Producer: Starting...\\n\";",
            "    for (int i = 0; i < 5; ++i) {",
            "        std::string data = \"data_\" + std::to_string(i);",
            "        {",
            "            std::lock_guard<std::mutex> lock(mtx_cv); // Lock to protect the queue",
            "            data_queue.push(data);",
            "            std::cout << \"Producer produced: \" << data << std::endl;",
            "        }",
            "        cv.notify_one(); // Notify one waiting consumer that data is available",
            "        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Simulate work",
            "    }",
            "    {",
            "        std::lock_guard<std::mutex> lock(mtx_cv);",
            "        finished_producing = true; // Signal that production is finished",
            "        std::cout << \"Producer: Finished producing.\\n\";",
            "    }",
            "    cv.notify_all(); // Notify all consumers to check the finished flag",
            "}",
            "",
            "void consumer(int id) {",
            "    std::cout << \"Consumer \" << id << \": Starting...\\n\";",
            "    while (true) {",
            "        std::unique_lock<std::mutex> lock(mtx_cv);",
            "        // Wait until data is available OR production is finished.",
            "        // The lambda predicate prevents spurious wakeups and re-checks the condition.",
            "        cv.wait(lock, [&]{ return finished_producing || !data_queue.empty(); });",
            "",
            "        // If production is finished AND queue is empty, exit.",
            "        if (finished_producing && data_queue.empty()) {",
            "            std::cout << \"Consumer \" << id << \": No more data, exiting.\\n\";",
            "            break;",
            "        }",
            "",
            "        // Process data from the queue",
            "        std::string data = data_queue.front();",
            "        data_queue.pop();",
            "        std::cout << \"Consumer \" << id << \" consumed: \" << data << std::endl;",
            "        lock.unlock(); // Unlock early if processing takes time and doesn't need the lock",
            "        std::this_thread::sleep_for(std::chrono::milliseconds(150)); // Simulate work",
            "    }",
            "}",
            "",
            "int main() {",
            "    std::thread prod_thread(producer);",
            "    std::thread cons_thread1(consumer, 1);",
            "    std::thread cons_thread2(consumer, 2);",
            "",
            "    prod_thread.join();",
            "    cons_thread1.join();",
            "    cons_thread2.join();",
            "",
            "    std::cout << \"\\nProducer-Consumer example finished.\" << std::endl;",
            "    return 0;",
            "}",
            "$0"
        ],
        "description": "C++ Concurrency: std::condition_variable for producer-consumer pattern. Reference: https://en.cppreference.com/w/cpp/thread/condition_variable"
    },
    "cpp_concurrency__std_future_promise": {
        "prefix": "cpp_concurrency__std_future_promise",
        "body": [
            "// C++ Concurrency: std::future and std::promise",
            "// std::promise allows setting a value or an exception that can be retrieved by a std::future object.",
            "// std::future provides a mechanism to access the result of an asynchronous operation.",
            "// They are used for one-time communication of a result from one thread to another.",
            "// Reference: https://en.cppreference.com/w/cpp/thread/promise",
            "// Reference: https://en.cppreference.com/w/cpp/thread/future",
            "#include <iostream>",
            "#include <thread>",
            "#include <future>",
            "#include <chrono>",
            "#include <stdexcept>",
            "",
            "// Function that sets a value in a promise",
            "void calculate_sum(std::promise<int>&& promise_obj, int a, int b) {",
            "    std::cout << \"Thread \" << std::this_thread::get_id() << \": Calculating sum...\\n\";",
            "    std::this_thread::sleep_for(std::chrono::seconds(1)); // Simulate long computation",
            "    int sum = a + b;",
            "    promise_obj.set_value(sum); // Fulfills the promise, making the value available via future",
            "    std::cout << \"Thread \" << std::this_thread::get_id() << \": Promise set value: \" << sum << std::endl;",
            "}",
            "",
            "// Function that sets an exception in a promise",
            "void calculate_division(std::promise<double>&& promise_obj, double numerator, double denominator) {",
            "    try {",
            "        if (denominator == 0) {",
            "            throw std::runtime_error(\"Division by zero!\");",
            "        }",
            "        std::this_thread::sleep_for(std::chrono::milliseconds(500));",
            "        promise_obj.set_value(numerator / denominator);",
            "    } catch (...) {",
            "        // Catch any exception and store it in the promise",
            "        promise_obj.set_exception(std::current_exception());",
            "    }",
            "}",
            "",
            "int main() {",
            "    std::cout << \"--- std::promise and std::future for value retrieval ---\\n\";",
            "    // Create a promise and get its associated future",
            "    std::promise<int> promise_sum;",
            "    std::future<int> future_sum = promise_sum.get_future();",
            "",
            "    // Launch a thread to perform the calculation and set the promise",
            "    std::thread t_sum(calculate_sum, std::move(promise_sum), 10, 20);",
            "",
            "    std::cout << \"Main thread waiting for sum result...\\n\";",
            "    // Get the result from the future. This call blocks until the promise is fulfilled.",
            "    int result_sum = future_sum.get();",
            "    std::cout << \"Main thread: Result from future (sum): \" << result_sum << std::endl;",
            "",
            "    t_sum.join();",
            "",
            "    std::cout << \"\\n--- std::promise and std::future for exception handling ---\\n\";",
            "    std::promise<double> promise_div;",
            "    std::future<double> future_div = promise_div.get_future();",
            "",
            "    // Launch a thread with a task that might throw an exception",
            "    std::thread t_div(calculate_division, std::move(promise_div), 10.0, 0.0); // This will cause division by zero",
            "",
            "    std::cout << \"Main thread waiting for division result...\\n\";",
            "    try {",
            "        double result_div = future_div.get(); // This will rethrow the exception set in the promise",
            "        std::cout << \"Main thread: Result from future (division): \" << result_div << std::endl;",
            "    } catch (const std::exception& e) {",
            "        std::cerr << \"Main thread: Caught exception from future: \" << e.what() << std::endl;",
            "    }",
            "",
            "    t_div.join();",
            "",
            "    std::cout << \"\\nMain thread finished.\\n\";",
            "    return 0;",
            "}",
            "$0"
        ],
        "description": "C++ Concurrency: std::future and std::promise for asynchronous results and exception handling. References: https://en.cppreference.com/w/cpp/thread/promise, https://en.cppreference.com/w/cpp/thread/future"
    },
    "cpp_concurrency__std_async": {
        "prefix": "cpp_concurrency__std_async",
        "body": [
            "// C++ Concurrency: std::async",
            "// std::async is a high-level utility for launching asynchronous tasks.",
            "// It returns a std::future that will eventually hold the result of the task.",
            "// It can choose to run the task on a new thread (std::launch::async) or defer it (std::launch::deferred).",
            "// Reference: https://en.cppreference.com/w/cpp/thread/async",
            "#include <iostream>",
            "#include <future>",
            "#include <chrono>",
            "#include <thread>",
            "",
            "// Function to be executed asynchronously",
            "int calculate_product(int a, int b) {",
            "    std::cout << \"  [Task] Calculating product in thread: \" << std::this_thread::get_id() << std::endl;",
            "    std::this_thread::sleep_for(std::chrono::seconds(1)); // Simulate work",
            "    return a * b;",
            "}",
            "",
            "int main() {",
            "    std::cout << \"Main thread ID: \" << std::this_thread::get_id() << \"\\n\\n\";",
            "",
            "    // 1. Launching a task with std::launch::async (guarantees a new thread)",
            "    std::cout << \"--- std::async with std::launch::async ---\\n\";",
            "    std::future<int> future_product = std::async(std::launch::async, calculate_product, 5, 6);",
            "",
            "    std::cout << \"Main thread doing other work while product is calculated...\\n\";",
            "    std::this_thread::sleep_for(std::chrono::milliseconds(500));",
            "",
            "    // Get the result. This call blocks until the result is ready.",
            "    int result_product = future_product.get();",
            "    std::cout << \"Main thread: Product result: \" << result_product << \"\\n\\n\";",
            "",
            "    // 2. Launching a task with default launch policy (implementation-defined: async or deferred)",
            "    // This is the most common usage. The system decides whether to run it on a new thread or defer.",
            "    std::cout << \"--- std::async with default launch policy ---\\n\";",
            "    std::future<int> future_sum = std::async([](int a, int b) {",
            "        std::cout << \"  [Task] Calculating sum in thread: \" << std::this_thread::get_id() << std::endl;",
            "        std::this_thread::sleep_for(std::chrono::milliseconds(500));",
            "        return a + b;",
            "    }, 10, 15);",
            "",
            "    std::cout << \"Main thread waiting for sum...\\n\";",
            "    std::cout << \"Main thread: Sum result: \" << future_sum.get() << \"\\n\\n\";",
            "",
            "    // 3. Launching a task with std::launch::deferred (task runs on first call to .get() or .wait())",
            "    // The task is executed synchronously on the thread that calls .get() or .wait().",
            "    std::cout << \"--- std::async with std::launch::deferred ---\\n\";",
            "    std::future<int> future_deferred = std::async(std::launch::deferred, []() {",
            "        std::cout << \"  [Task] Deferred task running on thread: \" << std::this_thread::get_id() << std::endl;",
            "        return 100;",
            "    });",
            "",
            "    std::cout << \"Main thread calling get() for deferred task...\\n\";",
            "    std::cout << \"Main thread: Deferred result: \" << future_deferred.get() << \"\\n\\n\";",
            "",
            "    // Important: The destructor of std::future blocks until the associated asynchronous operation completes.",
            "    // This means if you don't call .get() or .wait(), the future's destruction will implicitly join the thread.",
            "    std::cout << \"Main thread finished.\\n\";",
            "    return 0;",
            "}",
            "$0"
        ],
        "description": "C++ Concurrency: std::async for simplified asynchronous task execution with different launch policies. Reference: https://en.cppreference.com/w/cpp/thread/async"
    },
    "cpp_concurrency__std_atomic": {
        "prefix": "cpp_concurrency__std_atomic",
        "body": [
            "// C++ Concurrency: std::atomic for Atomic Operations",
            "// std::atomic provides atomic (indivisible) operations on data, ensuring thread safety without explicit locks.",
            "// This is crucial for low-level synchronization and building lock-free data structures.",
            "// Reference: https://en.cppreference.com/w/cpp/atomic/atomic",
            "#include <iostream>",
            "#include <thread>",
            "#include <atomic>",
            "#include <vector>",
            "#include <chrono>",
            "",
            "// An atomic integer counter",
            "std::atomic<int> atomic_counter(0);",
            "// std::atomic_int atomic_counter(0); // std::atomic_int is an alias for std::atomic<int>",
            "",
            "void increment_atomic_counter() {",
            "    for (int i = 0; i < 100000; ++i) {",
            "        // Atomic increment: equivalent to atomic_counter.fetch_add(1, std::memory_order_seq_cst);",
            "        // This operation is guaranteed to be atomic and sequentially consistent by default.",
            "        atomic_counter++;",
            "    }",
            "}",
            "",
            "int main() {",
            "    std::cout << \"--- std::atomic basic increment example ---\\n\";",
            "    std::vector<std::thread> threads;",
            "    for (int i = 0; i < 10; ++i) {",
            "        threads.emplace_back(increment_atomic_counter);",
            "    }",
            "",
            "    for (auto& t : threads) {",
            "        t.join();",
            "    }",
            "",
            "    // The final value should be exactly 10 * 100000 = 1000000 due to atomicity.",
            "    std::cout << \"Final atomic_counter (should be 1000000): \" << atomic_counter.load() << \"\\n\\n\";",
            "",
            "    std::cout << \"--- Other basic atomic operations ---\\n\";",
            "    std::atomic<bool> flag(false);",
            "",
            "    // store(): Atomically sets the value.",
            "    flag.store(true);",
            "    std::cout << \"Atomic flag after store(true): \" << std::boolalpha << flag.load() << std::endl;",
            "",
            "    // load(): Atomically reads the value.",
            "    bool current_flag = flag.load();",
            "    std::cout << \"Atomic flag after load(): \" << std::boolalpha << current_flag << std::endl;",
            "",
            "    // is_lock_free(): Checks if the atomic operation is implemented without locks (hardware support).",
            "    // True means it's typically faster.",
            "    std::cout << \"std::atomic<int> is lock-free: \" << std::boolalpha << atomic_counter.is_lock_free() << std::endl;",
            "    std::cout << \"std::atomic<bool> is lock-free: \" << std::boolalpha << flag.is_lock_free() << \"\\n\";",
            "",
            "    std::cout << \"\\nMain thread finished.\\n\";",
            "    return 0;",
            "}",
            "$0"
        ],
        "description": "C++ Concurrency: std::atomic for lock-free atomic operations (increment, load, store, is_lock_free). Reference: https://en.cppreference.com/w/cpp/atomic/atomic"
    },
    "cpp_concurrency__thread_local": {
        "prefix": "cpp_concurrency__thread_local",
        "body": [
            "// C++ Concurrency: thread_local Storage Duration Specifier",
            "// The `thread_local` keyword specifies that a variable has thread storage duration.",
            "// This means each thread that accesses the variable gets its own independent copy of it.",
            "// It's useful for avoiding false sharing or when each thread needs its own state.",
            "// Reference: https://en.cppreference.com/w/cpp/language/thread_local",
            "#include <iostream>",
            "#include <thread>",
            "#include <vector>",
            "#include <chrono>",
            "",
            "// Global thread-local variable: each thread will have its own 'thread_specific_data'",
            "thread_local int thread_specific_data = 0;",
            "",
            "void increment_thread_data(int id) {",
            "    // Accessing thread_specific_data modifies only this thread's copy.",
            "    thread_specific_data += id; ",
            "    std::cout << \"Thread \" << std::this_thread::get_id() ",
            "              << \": thread_specific_data = \" << thread_specific_data << std::endl;",
            "    std::this_thread::sleep_for(std::chrono::milliseconds(50));",
            "}",
            "",
            "int main() {",
            "    std::cout << \"Main thread: Initial thread_specific_data = \" << thread_specific_data << std::endl;",
            "",
            "    // Modify main thread's copy",
            "    thread_specific_data = 100;",
            "    std::cout << \"Main thread: Modified thread_specific_data = \" << thread_specific_data << \"\\n\\n\";",
            "",
            "    std::vector<std::thread> threads;",
            "    for (int i = 1; i <= 3; ++i) {",
            "        // Each new thread will get its own copy, initialized to 0.",
            "        threads.emplace_back(increment_thread_data, i * 10);",
            "    }",
            "",
            "    for (auto& t : threads) {",
            "        t.join();",
            "    }",
            "",
            "    // After all threads join, the main thread's copy of thread_specific_data remains unchanged.",
            "    std::cout << \"\\nMain thread after joins: thread_specific_data = \" << thread_specific_data << std::endl;",
            "",
            "    std::cout << \"Main thread finished.\\n\";",
            "    return 0;",
            "}",
            "$0"
        ],
        "description": "C++ Concurrency: thread_local storage for thread-specific data. Reference: https://en.cppreference.com/w/cpp/language/thread_local"
    },
    "cpp_concurrency__std_call_once": {
        "prefix": "cpp_concurrency__std_call_once",
        "body": [
            "// C++ Concurrency: std::call_once and std::once_flag",
            "// std::call_once ensures that a callable object (function, lambda, etc.) is called exactly once,",
            "// even if multiple threads attempt to call it concurrently.",
            "// It's typically used for lazy, thread-safe initialization of global or static resources.",
            "// Reference: https://en.cppreference.com/w/cpp/thread/call_once",
            "#include <iostream>",
            "#include <thread>",
            "#include <mutex>",
            "#include <vector>",
            "#include <chrono>",
            "",
            "// A std::once_flag is used to manage the state of the one-time initialization.",
            "std::once_flag initialization_flag;",
            "",
            "// Resource that needs to be initialized exactly once.",
            "class SingletonResource {",
            "public:",
            "    static SingletonResource& get_instance() {",
            "        // std::call_once ensures this lambda (and thus the constructor) is called only once.",
            "        std::call_once(initialization_flag, []() {",
            "            instance_ptr = new SingletonResource();",
            "            std::cout << \"  [SingletonResource] Initialized by thread: \" << std::this_thread::get_id() << std::endl;",
            "        });",
            "        return *instance_ptr;",
            "    }",
            "",
            "    void do_something() const {",
            "        std::cout << \"  [SingletonResource] Doing something from thread: \" << std::this_thread::get_id() << std::endl;",
            "    }",
            "",
            "private:",
            "    SingletonResource() = default; // Private constructor for Singleton pattern",
            "    ~SingletonResource() = default;",
            "    SingletonResource(const SingletonResource&) = delete;",
            "    SingletonResource& operator=(const SingletonResource&) = delete;",
            "",
            "    static SingletonResource* instance_ptr;",
            "};",
            "",
            "SingletonResource* SingletonResource::instance_ptr = nullptr;",
            "",
            "void worker_function() {",
            "    std::cout << \"Worker thread \" << std::this_thread::get_id() << \" trying to get resource...\" << std::endl;",
            "    SingletonResource::get_instance().do_something();",
            "    std::this_thread::sleep_for(std::chrono::milliseconds(50));",
            "    std::cout << \"Worker thread \" << std::this_thread::get_id() << \" finished resource access.\" << std::endl;",
            "}",
            "",
            "int main() {",
            "    std::cout << \"--- std::call_once example (Singleton Initialization) ---\\n\";",
            "    std::vector<std::thread> threads;",
            "    for (int i = 0; i < 5; ++i) {",
            "        threads.emplace_back(worker_function);",
            "    }",
            "",
            "    for (auto& t : threads) {",
            "        t.join();",
            "    }",
            "",
            "    std::cout << \"\\nAll threads finished. Resource was initialized only once.\\n\";",
            "    return 0;",
            "}",
            "$0"
        ],
        "description": "C++ Concurrency: std::call_once and std::once_flag for one-time initialization (e.g., Singleton pattern). Reference: https://en.cppreference.com/w/cpp/thread/call_once"
    },
    "cpp_concurrency__std_shared_mutex": {
        "prefix": "cpp_concurrency__std_shared_mutex",
        "body": [
            "// C++ Concurrency: std::shared_mutex (C++17) for Reader-Writer Lock",
            "// std::shared_mutex provides a reader-writer lock mechanism.",
            "// Multiple threads can acquire a shared (read) lock concurrently.",
            "// Only one thread can acquire an exclusive (write) lock at a time.",
            "// A write lock blocks all other read and write locks.",
            "// Reference: https://en.cppreference.com/w/cpp/thread/shared_mutex",
            "#include <iostream>",
            "#include <thread>",
            "#include <shared_mutex>",
            "#include <vector>",
            "#include <string>",
            "#include <chrono>",
            "",
            "std::shared_mutex shared_mtx;",
            "int shared_resource = 0;",
            "",
            "void reader(int id) {",
            "    for (int i = 0; i < 3; ++i) {",
            "        // Acquire a shared lock (allows multiple readers concurrently)",
            "        std::shared_lock<std::shared_mutex> lock(shared_mtx); ",
            "        std::cout << \"Reader \" << id << \" reads: \" << shared_resource << std::endl;",
            "        // lock.unlock(); // Can release shared lock early if needed",
            "        std::this_thread::sleep_for(std::chrono::milliseconds(50)); // Simulate reading time",
            "    } // Lock is automatically released when 'lock' goes out of scope",
            "}",
            "",
            "void writer(int id) {",
            "    for (int i = 0; i < 2; ++i) {",
            "        // Acquire an exclusive lock (blocks all other readers and writers)",
            "        std::unique_lock<std::shared_mutex> lock(shared_mtx); ",
            "        shared_resource++;",
            "        std::cout << \"Writer \" << id << \" writes: \" << shared_resource << std::endl;",
            "        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Simulate writing time",
            "    } // Lock is automatically released when 'lock' goes out of scope",
            "}",
            "",
            "int main() {",
            "    std::cout << \"--- std::shared_mutex example ---\\n\";",
            "    std::vector<std::thread> threads;",
            "",
            "    // Create writer threads (fewer writers, as they block more)",
            "    for (int i = 1; i <= 2; ++i) {",
            "        threads.emplace_back(writer, i);",
            "    }",
            "",
            "    // Create reader threads (more readers, as they can run concurrently)",
            "    for (int i = 1; i <= 5; ++i) {",
            "        threads.emplace_back(reader, i);",
            "    }",
            "",
            "    for (auto& t : threads) {",
            "        t.join();",
            "    }",
            "",
            "    std::cout << \"\\nFinal shared_resource value: \" << shared_resource << std::endl;",
            "    std::cout << \"Main thread finished.\\n\";",
            "    return 0;",
            "}",
            "$0"
        ],
        "description": "C++ Concurrency: std::shared_mutex for reader-writer locks (C++17). Reference: https://en.cppreference.com/w/cpp/thread/shared_mutex"
    },
    "cpp_concurrency__std_latch_barrier": {
        "prefix": "cpp_concurrency__std_latch_barrier",
        "body": [
            "// C++ Concurrency: std::latch and std::barrier (C++20)",
            "// These are synchronization primitives for coordinating groups of threads.",
            "// std::latch: A single-use barrier that allows a set of threads to wait until a counter reaches zero.",
            "// Reference: https://en.cppreference.com/w/cpp/thread/latch",
            "// std::barrier: A reusable barrier that allows a set of threads to wait until all threads reach a certain point.",
            "// It can execute a completion function when all threads arrive.",
            "// Reference: https://en.cppreference.com/w/cpp/thread/barrier",
            "#include <iostream>",
            "#include <thread>",
            "#include <vector>",
            "#include <latch>",
            "#include <barrier>",
            "#include <chrono>",
            "#include <functional> // For std::ref",
            "",
            "// Example with std::latch (one-time synchronization)",
            "void worker_latch(int id, std::latch& start_latch, std::latch& end_latch) {",
            "    std::cout << \"Worker \" << id << \": Waiting to start...\\n\";",
            "    start_latch.arrive_and_wait(); // Decrement counter and wait until it's zero",
            "    ",
            "    std::cout << \"Worker \" << id << \" started processing.\\n\";",
            "    std::this_thread::sleep_for(std::chrono::milliseconds(100 + id * 10)); // Simulate work",
            "    std::cout << \"Worker \" << id << \" finished processing.\\n\";",
            "    ",
            "    end_latch.arrive_and_wait(); // Signal completion and wait for others to finish",
            "}",
            "",
            "// Example with std::barrier (reusable synchronization)",
            "void worker_barrier(int id, std::barrier& sync_barrier) {",
            "    for (int i = 0; i < 3; ++i) { // Simulate 3 phases of work",
            "        std::cout << \"Worker \" << id << \" phase \" << i + 1 << \" started.\\n\";",
            "        std::this_thread::sleep_for(std::chrono::milliseconds(50)); // Simulate work in phase",
            "        sync_barrier.arrive_and_wait(); // Synchronize at barrier. All threads wait here.",
            "        std::cout << \"Worker \" << id << \" phase \" << i + 1 << \" finished.\\n\";",
            "    }",
            "}",
            "",
            "int main() {",
            "    std::cout << \"--- std::latch example ---\\n\";",
            "    const int num_latch_workers = 3;",
            "    // Latch for starting: +1 for the main thread to release workers.",
            "    std::latch start_latch(num_latch_workers + 1); ",
            "    // Latch for ending: workers signal their completion.",
            "    std::latch end_latch(num_latch_workers);",
            "    std::vector<std::thread> latch_threads;",
            "",
            "    for (int i = 0; i < num_latch_workers; ++i) {",
            "        latch_threads.emplace_back(worker_latch, i + 1, std::ref(start_latch), std::ref(end_latch));",
            "    }",
            "",
            "    std::cout << \"Main thread preparing workers (latch)...\\n\";",
            "    std::this_thread::sleep_for(std::chrono::milliseconds(200));",
            "    start_latch.arrive_and_wait(); // Main thread signals workers to start",
            "    std::cout << \"Main thread released latch workers.\\n\";",
            "",
            "    end_latch.wait(); // Main thread waits for all workers to finish",
            "    std::cout << \"All latch workers finished.\\n\\n\";",
            "",
            "    for (auto& t : latch_threads) {",
            "        t.join();",
            "    }",
            "",
            "    std::cout << \"--- std::barrier example ---\\n\";",
            "    const int num_barrier_workers = 3;",
            "    // The completion function runs when all threads arrive at the barrier.",
            "    // It's executed by one of the arriving threads (arbitrarily chosen).",
            "    auto on_completion = []() noexcept {",
            "        static int phase = 0;",
            "        std::cout << \"  [Barrier] Phase \" << ++phase << \" completed! All threads synchronized.\\n\";",
            "    };",
            "    std::barrier sync_barrier(num_barrier_workers, on_completion);",
            "    std::vector<std::thread> barrier_threads;",
            "",
            "    for (int i = 0; i < num_barrier_workers; ++i) {",
            "        barrier_threads.emplace_back(worker_barrier, i + 1, std::ref(sync_barrier));",
            "    }",
            "",
            "    for (auto& t : barrier_threads) {",
            "        t.join();",
            "    }",
            "",
            "    std::cout << \"\\nAll barrier workers finished.\\n\";",
            "",
            "    std::cout << \"Main thread finished.\\n\";",
            "    return 0;",
            "}",
            "$0"
        ],
        "description": "C++ Concurrency: std::latch (one-time) and std::barrier (reusable) for thread synchronization (C++20). References: https://en.cppreference.com/w/cpp/thread/latch, https://en.cppreference.com/w/cpp/thread/barrier"
    },
    "cpp_concurrency__std_jthread": {
        "prefix": "cpp_concurrency__std_jthread",
        "body": [
            "// C++ Concurrency: std::jthread (C++20) - Joinable Thread",
            "// std::jthread is a new thread class in C++20 that automatically joins on destruction.",
            "// This prevents common errors like forgetting to call .join() or .detach(),",
            "// which would otherwise terminate the program.",
            "// It also supports cooperative cancellation via a std::stop_token.",
            "#include <iostream>",
            "#include <thread>",
            "#include <chrono>",
            "#include <stop_token>",
            "",
            "void cancellable_task(std::stop_token st) {",
            "    int i = 0;",
            "    while (!st.stop_requested()) {",
            "        std::cout << \"Cancellable task running... \" << i++ << std::endl;",
            "        std::this_thread::sleep_for(std::chrono::milliseconds(200));",
            "    }",
            "    std::cout << \"Cancellable task received stop request and is exiting.\" << std::endl;",
            "}",
            "",
            "void simple_jthread_task() {",
            "    std::cout << \"Simple jthread task running on thread \" << std::this_thread::get_id() << std::endl;",
            "    std::this_thread::sleep_for(std::chrono::seconds(1));",
            "    std::cout << \"Simple jthread task finished.\" << std::endl;",
            "}",
            "",
            "int main() {",
            "    std::cout << \"std::jthread example:\\n\";",
            "",
            "    // 1. Basic std::jthread usage (automatically joins on scope exit)",
            "    {",
            "        std::jthread t1(simple_jthread_task);",
            "        std::cout << \"t1 launched. Main thread continues...\\n\";",
            "    } // t1 goes out of scope here, automatically calls .join()",
            "    std::cout << \"t1 has joined (scope exited).\\n\\n\";",
            "",
            "    // 2. std::jthread with cooperative cancellation",
            "    {",
            "        std::jthread t2(cancellable_task);",
            "        std::cout << \"t2 launched with cancellation support. Main thread waits...\\n\";",
            "        std::this_thread::sleep_for(std::chrono::seconds(1));",
            "        std::cout << \"Main thread requesting stop for t2...\\n\";",
            "        t2.request_stop(); // Request the thread to stop",
            "    } // t2 goes out of scope, automatically calls .join() after stop request",
            "    std::cout << \"t2 has joined (scope exited after stop request).\\n\\n\";",
            "",
            "    // 3. Passing arguments to jthread",
            "    std::jthread t3([](int val) {",
            "        std::cout << \"jthread with argument: \" << val << std::endl;",
            "    }, 42);",
            "    t3.join(); // Can still explicitly join if needed, but not strictly necessary for safety",
            "",
            "    std::cout << \"Main thread finished.\\n\";",
            "    return 0;",
            "}",
            "$0"
        ],
        "description": "C++ Concurrency: std::jthread (C++20) for joinable threads with cooperative cancellation."
    },
    "cpp_concurrency__std_atomic_memory_orders": {
        "prefix": "cpp_concurrency__std_atomic_memory_orders",
        "body": [
            "// C++ Concurrency: std::atomic and Memory Orders",
            "// Memory orders define how atomic operations synchronize memory accesses among threads.",
            "// They control the visibility and ordering of non-atomic operations relative to atomic ones.",
            "// Reference: https://en.cppreference.com/w/cpp/atomic/memory_order",
            "#include <iostream>",
            "#include <thread>",
            "#include <atomic>",
            "#include <vector>",
            "#include <string>",
            "",
            "std::atomic<bool> ready_flag(false);",
            "std::atomic<int> data(0);",
            "",
            "// memory_order_relaxed: No synchronization or ordering constraints.",
            "// Only guarantees atomicity of the operation itself.",
            "void relaxed_producer() {",
            "    data.store(100, std::memory_order_relaxed);",
            "    ready_flag.store(true, std::memory_order_relaxed);",
            "    std::cout << \"Relaxed Producer: data stored, flag set.\\n\";",
            "}",
            "",
            "void relaxed_consumer() {",
            "    while (!ready_flag.load(std::memory_order_relaxed)) {",
            "        std::this_thread::yield();",
            "    }",
            "    // No guarantee that data will be 100 here, as there's no ordering.",
            "    std::cout << \"Relaxed Consumer: data = \" << data.load(std::memory_order_relaxed) << \", flag = \" << ready_flag.load(std::memory_order_relaxed) << \"\\n\";",
            "}",
            "",
            "// memory_order_release: Ensures all writes before this operation are visible to other threads",
            "// that perform an acquire operation on the same atomic variable.",
            "void release_producer() {",
            "    data.store(200, std::memory_order_relaxed); // Can be relaxed, as it's before release",
            "    std::string msg = \"Hello from producer!\";",
            "    // Non-atomic writes before this line are guaranteed to be visible",
            "    // to threads that acquire on ready_flag.",
            "    ready_flag.store(true, std::memory_order_release);",
            "    std::cout << \"Release Producer: data stored, flag set.\\n\";",
            "}",
            "",
            "// memory_order_acquire: Ensures all writes after this operation are visible to other threads",
            "// that performed a release operation on the same atomic variable.",
            "void acquire_consumer() {",
            "    while (!ready_flag.load(std::memory_order_acquire)) { // Acquire operation",
            "        std::this_thread::yield();",
            "    }",
            "    // Guaranteed that data will be 200 here due to acquire-release synchronization.",
            "    std::cout << \"Acquire Consumer: data = \" << data.load(std::memory_order_relaxed) << \", flag = \" << ready_flag.load(std::memory_order_relaxed) << \"\\n\";",
            "}",
            "",
            "// memory_order_acq_rel: Combines acquire and release semantics.",
            "// Used for read-modify-write operations (e.g., fetch_add, compare_exchange).",
            "// It's a release operation for prior writes and an acquire operation for subsequent reads.",
            "std::atomic<int> counter(0);",
            "void acq_rel_worker() {",
            "    for (int i = 0; i < 1000; ++i) {",
            "        // fetch_add with acq_rel ensures that this operation is ordered",
            "        // with respect to other acq_rel or seq_cst operations on 'counter'.",
            "        counter.fetch_add(1, std::memory_order_acq_rel);",
            "    }",
            "}",
            "",
            "// memory_order_seq_cst: Sequential consistency (default for atomics).",
            "// Provides a single total order of all sequentially consistent operations.",
            "// Simplest to reason about, but can be more expensive.",
            "std::atomic<int> x(0), y(0);",
            "int r1, r2;",
            "",
            "void write_x() { x.store(1, std::memory_order_seq_cst); }",
            "void write_y() { y.store(1, std::memory_order_seq_cst); }",
            "void read_xy() { r1 = x.load(std::memory_order_seq_cst); r2 = y.load(std::memory_order_seq_cst); }",
            "",
            "int main() {",
            "    std::cout << \"\\n--- Relaxed Memory Order Example ---\\n\";",
            "    ready_flag.store(false, std::memory_order_relaxed); data.store(0, std::memory_order_relaxed);",
            "    std::thread t_rp(relaxed_producer);",
            "    std::thread t_rc(relaxed_consumer);",
            "    t_rp.join(); t_rc.join();",
            "",
            "    std::cout << \"\\n--- Acquire-Release Memory Order Example ---\\n\";",
            "    ready_flag.store(false, std::memory_order_relaxed); data.store(0, std::memory_order_relaxed);",
            "    std::thread t_rel(release_producer);",
            "    std::thread t_acq(acquire_consumer);",
            "    t_rel.join(); t_acq.join();",
            "",
            "    std::cout << \"\\n--- Acq_Rel Memory Order Example ---\\n\";",
            "    std::vector<std::thread> acq_rel_threads;",
            "    for (int i = 0; i < 10; ++i) {",
            "        acq_rel_threads.emplace_back(acq_rel_worker);",
            "    }",
            "    for (auto& t : acq_rel_threads) {",
            "        t.join();",
            "    }",
            "    std::cout << \"Final counter (acq_rel): \" << counter.load() << \"\\n\";",
            "",
            "    std::cout << \"\\n--- Sequential Consistency Memory Order Example ---\\n\";",
            "    // With seq_cst, (r1=1, r2=0) and (r1=0, r2=1) are possible, but (r1=0, r2=0) is not if both writes happen.",
            "    // (r1=1, r2=1) is also possible.",
            "    // This example demonstrates that seq_cst operations appear to happen in a single global order.",
            "    x.store(0); y.store(0); r1 = 0; r2 = 0;",
            "    std::thread t_wx(write_x);",
            "    std::thread t_wy(write_y);",
            "    std::thread t_rxy(read_xy);",
            "    t_wx.join(); t_wy.join(); t_rxy.join();",
            "    std::cout << \"Seq_cst: r1 = \" << r1 << \", r2 = \" << r2 << \"\\n\";",
            "",
            "    return 0;",
            "}",
            "$0"
        ],
        "description": "C++ Concurrency: std::atomic with various memory orders (relaxed, acquire, release, acq_rel, seq_cst)."
    },
    "cpp_concurrency__std_atomic_operations": {
        "prefix": "cpp_concurrency__std_atomic_operations",
        "body": [
            "// C++ Concurrency: Advanced std::atomic Operations",
            "// Beyond simple load/store, std::atomic provides powerful read-modify-write (RMW) operations.",
            "// These operations are atomic and can be combined with memory orders.",
            "// Reference: https://en.cppreference.com/w/cpp/atomic/atomic",
            "#include <iostream>",
            "#include <thread>",
            "#include <atomic>",
            "#include <vector>",
            "",
            "std::atomic<int> value(10);",
            "",
            "void perform_atomic_ops() {",
            "    // 1. exchange(): Atomically replaces the current value with a new value and returns the old value.",
            "    // Useful for implementing locks or passing ownership.",
            "    int old_val = value.exchange(20);",
            "    std::cout << \"Thread \" << std::this_thread::get_id() << \": exchange - old value = \" << old_val << \", new value = \" << value.load() << std::endl;",
            "",
            "    // 2. compare_exchange_strong() / compare_exchange_weak():",
            "    // Atomically compares the current value with an expected value.",
            "    // If they are equal, it replaces the current value with a desired value.",
            "    // Returns true on success, false on failure.",
            "    // compare_exchange_weak can spuriously fail (return false even if values are equal),",
            "    // but might be faster on some platforms (e.g., for loops).",
            "    // compare_exchange_strong is guaranteed not to spuriously fail.",
            "",
            "    int expected = 20; // Value we expect 'value' to currently hold",
            "    int desired = 30;  // Value we want to set 'value' to if 'expected' matches",
            "",
            "    // Example with compare_exchange_strong",
            "    if (value.compare_exchange_strong(expected, desired)) {",
            "        std::cout << \"Thread \" << std::this_thread::get_id() << \": CAS strong successful. Value is now: \" << value.load() << std::endl;",
            "    } else {",
            "        // 'expected' is updated with the actual current value if CAS fails.",
            "        std::cout << \"Thread \" << std::this_thread::get_id() << \": CAS strong failed. Value was: \" << expected << \", still: \" << value.load() << std::endl;",
            "    }",
            "",
            "    // Example with compare_exchange_weak in a loop (common pattern)",
            "    expected = value.load(); // Get current value",
            "    desired = expected + 10;",
            "    while (!value.compare_exchange_weak(expected, desired)) {",
            "        // Loop until successful. 'expected' is updated on failure.",
            "        desired = expected + 10;",
            "    }",
            "    std::cout << \"Thread \" << std::this_thread::get_id() << \": CAS weak loop successful. Value is now: \" << value.load() << std::endl;",
            "",
            "    // 3. fetch_add(), fetch_sub(), fetch_and(), fetch_or(), fetch_xor():",
            "    // Atomically performs an arithmetic/bitwise operation and returns the value *before* the operation.",
            "    // These are RMW operations.",
            "    int old_val_add = value.fetch_add(5); // value = value + 5; returns old value",
            "    std::cout << \"Thread \" << std::this_thread::get_id() << \": fetch_add - old value = \" << old_val_add << \", new value = \" << value.load() << std::endl;",
            "",
            "    int old_val_sub = value.fetch_sub(3); // value = value - 3; returns old value",
            "    std::cout << \"Thread \" << std::this_thread::get_id() << \": fetch_sub - old value = \" << old_val_sub << \", new value = \" << value.load() << std::endl;",
            "",
            "    // Example with fetch_and (e.g., clearing bits)",
            "    value.store(0b1101); // Set value to 13",
            "    int old_val_and = value.fetch_and(0b1010); // value = value & 0b1010 (13 & 10 = 8)",
            "    std::cout << \"Thread \" << std::this_thread::get_id() << \": fetch_and - old value = \" << old_val_and << \" (0b\" << std::oct << old_val_and << \"), new value = \" << value.load() << \" (0b\" << std::oct << value.load() << \")\" << std::endl;",
            "    std::cout << std::dec; // Reset to decimal output",
            "",
            "    // Example with fetch_or (e.g., setting bits)",
            "    value.store(0b0010); // Set value to 2",
            "    int old_val_or = value.fetch_or(0b1100); // value = value | 0b1100 (2 | 12 = 14)",
            "    std::cout << \"Thread \" << std::this_thread::get_id() << \": fetch_or - old value = \" << old_val_or << \" (0b\" << std::oct << old_val_or << \"), new value = \" << value.load() << \" (0b\" << std::oct << value.load() << \")\" << std::endl;",
            "    std::cout << std::dec; // Reset to decimal output",
            "",
            "    // Example with fetch_xor (e.g., toggling bits)",
            "    value.store(0b1010); // Set value to 10",
            "    int old_val_xor = value.fetch_xor(0b1111); // value = value ^ 0b1111 (10 ^ 15 = 5)",
            "    std::cout << \"Thread \" << std::this_thread::get_id() << \": fetch_xor - old value = \" << old_val_xor << \" (0b\" << std::oct << old_val_xor << \"), new value = \" << value.load() << \" (0b\" << std::oct << value.load() << \")\" << std::endl;",
            "    std::cout << std::dec; // Reset to decimal output",
            "}",
            "",
            "int main() {",
            "    std::vector<std::thread> threads;",
            "    for (int i = 0; i < 2; ++i) {",
            "        threads.emplace_back(perform_atomic_ops);",
            "    }",
            "",
            "    for (auto& t : threads) {",
            "        t.join();",
            "    }",
            "",
            "    std::cout << \"\\nAll atomic operations examples finished.\\n\";",
            "    return 0;",
            "}",
            "$0"
        ],
        "description": "C++ Concurrency: Advanced std::atomic operations (exchange, compare_exchange_strong/weak, fetch_add/sub/and/or/xor)."
    },
    "cpp_concurrency__std_atomic_flag": {
        "prefix": "cpp_concurrency__std_atomic_flag",
        "body": [
            "// C++ Concurrency: std::atomic_flag (Simplest Atomic Type)",
            "// std::atomic_flag is the simplest, most primitive atomic type.",
            "// It's a boolean flag that supports only two operations: test_and_set and clear.",
            "// It's guaranteed to be lock-free.",
            "// Reference: https://en.cppreference.com/w/cpp/atomic/atomic_flag",
            "#include <iostream>",
            "#include <thread>",
            "#include <atomic>",
            "#include <vector>",
            "#include <chrono>",
            "",
            "std::atomic_flag lock_flag = ATOMIC_FLAG_INIT; // Must be initialized with ATOMIC_FLAG_INIT",
            "int shared_resource_flag = 0;",
            "",
            "void increment_with_atomic_flag() {",
            "    for (int i = 0; i < 10000; ++i) {",
            "        // Spin-lock using atomic_flag",
            "        while (lock_flag.test_and_set(std::memory_order_acquire)) {",
            "            // Loop while the flag is set (locked)",
            "            // std::this_thread::yield(); // Optional: yield to other threads to reduce busy-waiting",
            "        }",
            "        // Critical section",
            "        shared_resource_flag++;",
            "        lock_flag.clear(std::memory_order_release); // Release the lock",
            "    }",
            "}",
            "",
            "int main() {",
            "    std::cout << \"--- std::atomic_flag example (Spin-lock) ---\\n\";",
            "    std::vector<std::thread> threads;",
            "    for (int i = 0; i < 10; ++i) {",
            "        threads.emplace_back(increment_with_atomic_flag);",
            "    }",
            "",
            "    for (auto& t : threads) {",
            "        t.join();",
            "    }",
            "",
            "    // The final value should be exactly 10 * 10000 = 100000 due to atomicity.",
            "    std::cout << \"Final shared_resource_flag (should be 100000): \" << shared_resource_flag << \"\\n\";",
            "",
            "    std::cout << \"std::atomic_flag is lock-free: \" << std::boolalpha << lock_flag.is_lock_free() << \"\\n\";",
            "",
            "    std::cout << \"\\nMain thread finished.\\n\";",
            "    return 0;",
            "}",
            "$0"
        ],
        "description": "C++ Concurrency: std::atomic_flag, the simplest atomic type, often used for spin-locks. Reference: https://en.cppreference.com/w/cpp/atomic/atomic_flag"
    },
    "cpp_concurrency__std_stop_token": {
        "prefix": "cpp_concurrency__std_stop_token",
        "body": [
            "// C++ Concurrency: std::stop_token, std::stop_source, std::stop_callback (C++20)",
            "// These classes provide a cooperative cancellation mechanism for threads.",
            "// std::stop_source: Creates and manages stop tokens.",
            "// std::stop_token: Allows checking if a stop has been requested.",
            "// std::stop_callback: Registers a callback to be executed when stop is requested.",
            "// Reference: https://en.cppreference.com/w/cpp/thread/stop_token",
            "// Reference: https://en.cppreference.com/w/cpp/thread/stop_source",
            "// Reference: https://en.cppreference.com/w/cpp/thread/stop_callback",
            "#include <iostream>",
            "#include <thread>",
            "#include <chrono>",
            "#include <stop_token>",
            "#include <vector>",
            "#include <functional>",
            "",
            "void worker_with_stop_token(std::stop_token st) {",
            "    int count = 0;",
            "    while (!st.stop_requested()) {",
            "        std::cout << \"  Worker \" << std::this_thread::get_id() << \": Working... \" << count++ << std::endl;",
            "        std::this_thread::sleep_for(std::chrono::milliseconds(200));",
            "    }",
            "    std::cout << \"  Worker \" << std::this_thread::get_id() << \": Stop requested, exiting.\\n\";",
            "}",
            "",
            "void worker_with_stop_callback(std::stop_token st) {",
            "    // Register a callback that will be invoked when stop is requested.",
            "    // The callback is executed on the thread that calls request_stop().",
            "    std::stop_callback cb(st, []{",
            "        std::cout << \"  [Callback] Stop callback invoked on thread: \" << std::this_thread::get_id() << std::endl;",
            "    });",
            "",
            "    int count = 0;",
            "    while (!st.stop_requested()) {",
            "        std::cout << \"  Worker with callback \" << std::this_thread::get_id() << \": Working... \" << count++ << std::endl;",
            "        std::this_thread::sleep_for(std::chrono::milliseconds(200));",
            "    }",
            "    std::cout << \"  Worker with callback \" << std::this_thread::get_id() << \": Stop requested, exiting.\\n\";",
            "}",
            "",
            "int main() {",
            "    std::cout << \"--- std::stop_token example ---\\n\";",
            "    // std::stop_source manages the stop state and creates stop_tokens.",
            "    std::stop_source stop_src1;",
            "    std::jthread t1(worker_with_stop_token, stop_src1.get_token()); // jthread automatically gets a stop_token",
            "    // Or, for std::thread:",
            "    // std::thread t1(worker_with_stop_token, stop_src1.get_token());",
            "",
            "    std::cout << \"Main thread: Waiting for 1 second before requesting stop for t1...\\n\";",
            "    std::this_thread::sleep_for(std::chrono::seconds(1));",
            "    stop_src1.request_stop(); // Request stop for all associated tokens",
            "    t1.join(); // Wait for t1 to finish",
            "    std::cout << \"t1 finished.\\n\\n\";",
            "",
            "    std::cout << \"--- std::stop_callback example ---\\n\";",
            "    std::stop_source stop_src2;",
            "    std::jthread t2(worker_with_stop_callback, stop_src2.get_token());",
            "",
            "    std::cout << \"Main thread: Waiting for 1 second before requesting stop for t2...\\n\";",
            "    std::this_thread::sleep_for(std::chrono::seconds(1));",
            "    stop_src2.request_stop(); // This will trigger the callback on the main thread (or the thread calling request_stop)",
            "    t2.join();",
            "    std::cout << \"t2 finished.\\n\\n\";",
            "",
            "    std::cout << \"Main thread finished.\\n\";",
            "    return 0;",
            "}",
            "$0"
        ],
        "description": "C++ Concurrency: std::stop_token, std::stop_source, std::stop_callback (C++20) for cooperative thread cancellation. References: https://en.cppreference.com/w/cpp/thread/stop_token, https://en.cppreference.com/w/cpp/thread/stop_source, https://en.cppreference.com/w/cpp/thread/stop_callback"
    },
    "cpp_concurrency__std_semaphore": {
        "prefix": "cpp_concurrency__std_semaphore",
        "body": [
            "// C++ Concurrency: std::counting_semaphore and std::binary_semaphore (C++20)",
            "// Semaphores are synchronization primitives that control access to a common resource.",
            "// They maintain an internal counter, which is decremented by acquire() and incremented by release().",
            "// std::counting_semaphore: A general-purpose semaphore with an arbitrary counter.",
            "// std::binary_semaphore: A semaphore with a counter that is either 0 or 1 (like a mutex).",
            "// Reference: https://en.cppreference.com/w/cpp/thread/counting_semaphore",
            "#include <iostream>",
            "#include <thread>",
            "#include <vector>",
            "#include <semaphore>",
            "#include <chrono>",
            "",
            "// A counting semaphore initialized with 2, allowing 2 threads to access a resource concurrently.",
            "std::counting_semaphore<2> resource_semaphore(2); ",
            "",
            "void worker_counting_semaphore(int id) {",
            "    std::cout << \"Worker \" << id << \": Trying to acquire resource...\\n\";",
            "    resource_semaphore.acquire(); // Decrement counter, blocks if counter is 0",
            "    std::cout << \"Worker \" << id << \": Acquired resource. Working...\\n\";",
            "    std::this_thread::sleep_for(std::chrono::milliseconds(200 + id * 50)); // Simulate work",
            "    std::cout << \"Worker \" << id << \": Releasing resource.\\n\";",
            "    resource_semaphore.release(); // Increment counter",
            "}",
            "",
            "// A binary semaphore (like a mutex, but can be released by a different thread)",
            "std::binary_semaphore binary_sem(1); // Initialized with 1, allowing one access at a time",
            "int shared_binary_resource = 0;",
            "",
            "void worker_binary_semaphore(int id) {",
            "    std::cout << \"Binary Worker \" << id << \": Trying to acquire...\\n\";",
            "    binary_sem.acquire();",
            "    std::cout << \"Binary Worker \" << id << \": Acquired. shared_binary_resource = \" << ++shared_binary_resource << \"\\n\";",
            "    std::this_thread::sleep_for(std::chrono::milliseconds(100));",
            "    binary_sem.release();",
            "    std::cout << \"Binary Worker \" << id << \": Released.\\n\";",
            "}",
            "",
            "int main() {",
            "    std::cout << \"--- std::counting_semaphore example ---\\n\";",
            "    std::vector<std::thread> counting_threads;",
            "    for (int i = 0; i < 5; ++i) {",
            "        counting_threads.emplace_back(worker_counting_semaphore, i + 1);",
            "    }",
            "",
            "    for (auto& t : counting_threads) {",
            "        t.join();",
            "    }",
            "    std::cout << \"All counting semaphore workers finished.\\n\\n\";",
            "",
            "    std::cout << \"--- std::binary_semaphore example ---\\n\";",
            "    std::vector<std::thread> binary_threads;",
            "    for (int i = 0; i < 5; ++i) {",
            "        binary_threads.emplace_back(worker_binary_semaphore, i + 1);",
            "    }",
            "",
            "    for (auto& t : binary_threads) {",
            "        t.join();",
            "    }",
            "    std::cout << \"Final shared_binary_resource (should be 5): \" << shared_binary_resource << \"\\n\";",
            "    std::cout << \"All binary semaphore workers finished.\\n\";",
            "",
            "    std::cout << \"\\nMain thread finished.\\n\";",
            "    return 0;",
            "}",
            "$0"
        ],
        "description": "C++ Concurrency: std::counting_semaphore and std::binary_semaphore (C++20) for resource control. Reference: https://en.cppreference.com/w/cpp/thread/counting_semaphore"
    },
    "cpp_concurrency__thread_pool": {
        "prefix": "cpp_concurrency__thread_pool",
        "body": [
            "// C++ Concurrency: Basic Thread Pool Implementation",
            "// A thread pool manages a collection of worker threads to execute a queue of tasks.",
            "// This pattern helps reduce the overhead of creating and destroying threads for each task,",
            "// and limits the number of concurrent threads.",
            "// Note: This is a simplified example. Production-grade thread pools are more complex.",
            "#include <iostream>",
            "#include <vector>",
            "#include <queue>",
            "#include <thread>",
            "#include <mutex>",
            "#include <condition_variable>",
            "#include <future>",
            "#include <functional>",
            "",
            "class ThreadPool {",
            "public:",
            "    ThreadPool(size_t num_threads) : stop(false) {",
            "        for (size_t i = 0; i < num_threads; ++i) {",
            "            workers.emplace_back([this] {",
            "                for (;;) {",
            "                    std::function<void()> task;",
            "                    {",
            "                        std::unique_lock<std::mutex> lock(this->queue_mutex);",
            "                        this->condition.wait(lock, [this] {",
            "                            return this->stop || !this->tasks.empty();",
            "                        });",
            "                        if (this->stop && this->tasks.empty()) {",
            "                            return;",
            "                        }",
            "                        task = std::move(this->tasks.front());",
            "                        this->tasks.pop();",
            "                    }",
            "                    task();",
            "                }",
            "            });",
            "        }",
            "    }",
            "",
            "    // Add new task to the pool",
            "    template<class F, class... Args>",
            "    auto enqueue(F&& f, Args&&... args) ",
            "        -> std::future<typename std::result_of<F(Args...)>::type>",
            "    {",
            "        using return_type = typename std::result_of<F(Args...)>::type;",
            "",
            "        auto task = std::make_shared<std::packaged_task<return_type()>>(",
            "            std::bind(std::forward<F>(f), std::forward<Args>(args)...)",
            "        );",
            "",
            "        std::future<return_type> res = task->get_future();",
            "        {",
            "            std::unique_lock<std::mutex> lock(queue_mutex);",
            "",
            "            // Don't allow enqueueing after stopping the pool",
            "            if (stop) {",
            "                throw std::runtime_error(\"enqueue on stopped ThreadPool\");",
            "            }",
            "            tasks.emplace([task]() { (*task)(); });",
            "        }",
            "        condition.notify_one();",
            "        return res;",
            "    }",
            "",
            "    ~ThreadPool() {",
            "        {",
            "            std::unique_lock<std::mutex> lock(queue_mutex);",
            "            stop = true;",
            "        }",
            "        condition.notify_all();",
            "        for (std::thread &worker : workers) {",
            "            worker.join();",
            "        }",
            "    }",
            "",
            "private:",
            "    // Need to keep track of threads so we can join them",
            "    std::vector<std::thread> workers;",
            "    // The task queue",
            "    std::queue<std::function<void()>> tasks;",
            "",
            "    // Synchronization",
            "    std::mutex queue_mutex;",
            "    std::condition_variable condition;",
            "    bool stop;",
            "};",
            "",
            "// Example usage:",
            "int main() {",
            "    ThreadPool pool(4); // Create a thread pool with 4 worker threads",
            "",
            "    std::vector<std::future<int>> results;",
            "",
            "    for (int i = 0; i < 8; ++i) {",
            "        results.emplace_back(",
            "            pool.enqueue([i] {",
            "                std::cout << \"hello from task \" << i << \" on thread \" << std::this_thread::get_id() << std::endl;",
            "                std::this_thread::sleep_for(std::chrono::seconds(1));",
            "                std::cout << \"task \" << i << \" finished\" << std::endl;",
            "                return i * i;",
            "            })",
            "        );",
            "    }",
            "",
            "    std::cout << \"Main thread doing other work...\\n\";",
            "    std::this_thread::sleep_for(std::chrono::milliseconds(500));",
            "",
            "    std::cout << \"\\nResults:\\n\";",
            "    for (auto &&result : results) {",
            "        std::cout << result.get() << ' ';",
            "    }",
            "    std::cout << std::endl;",
            "",
            "    std::cout << \"\\nMain thread finished.\\n\";",
            "    return 0;",
            "}",
            "$0"
        ],
        "description": "C++ Concurrency: Basic Thread Pool implementation for managing worker threads and task queues."
    },
    "RAII Principle": {
        "prefix": "cpp_best_practises__raii",
        "body": [
            "// Resource Acquisition Is Initialization (RAII)",
            "// Example: Using std::lock_guard for mutex management",
            "std::mutex mtx;",
            "void func() {",
            "    std::lock_guard<std::mutex> lock(mtx); // Lock acquired",
            "    // Critical section",
            "} // Lock released automatically when lock goes out of scope"
        ],
        "description": "Snippet for RAII principle with std::lock_guard example"
    },
    "Use const Correctly": {
        "prefix": "cpp_best_practises__useconst",
        "body": [
            "// Use const for immutability and clarity",
            "void print_vector(const std::vector<int>& vec) {",
            "    // vec cannot be modified inside this function",
            "    for (int x : vec) {",
            "        std::cout << x << \" \";",
            "    }",
            "    std::cout << std::endl;",
            "}",
            "",
            "class MyClass {",
            "public:",
            "    int getValue() const { // const member function",
            "        return value_;",
            "    }",
            "private:",
            "    int value_;",
            "};"
        ],
        "description": "Snippet for correct usage of const"
    },
    "Prefer Smart Pointers": {
        "prefix": "cpp_best_practises__smartptr",
        "body": [
            "// Prefer smart pointers (std::unique_ptr, std::shared_ptr) over raw pointers",
            "// std::unique_ptr for exclusive ownership",
            "std::unique_ptr<MyObject> obj1 = std::make_unique<MyObject>();",
            "obj1->doSomething();",
            "",
            "// std::shared_ptr for shared ownership",
            "std::shared_ptr<MyObject> obj2 = std::make_shared<MyObject>();",
            "std::shared_ptr<MyObject> obj3 = obj2; // Shared ownership",
            "obj2->doSomethingElse();"
        ],
        "description": "Snippet for preferring smart pointers"
    },
    "Static Polymorphism (CRTP)": {
        "prefix": "cpp_best_practises__crtp",
        "body": [
            "// Static Polymorphism using Curiously Recurring Template Pattern (CRTP)",
            "template <typename Derived>",
            "class Base {",
            "public:",
            "    void interface() {",
            "        // Call the implementation in the derived class",
            "        static_cast<Derived*>(this)->implementation();",
            "    }",
            "    // Common functionality can be defined here",
            "};",
            "",
            "class ConcreteDerived : public Base<ConcreteDerived> {",
            "public:",
            "    void implementation() {",
            "        std::cout << \"ConcreteDerived implementation\" << std::endl;",
            "    }",
            "};",
            "",
            "class AnotherDerived : public Base<AnotherDerived> {",
            "public:",
            "    void implementation() {",
            "        std::cout << \"AnotherDerived implementation\" << std::endl;",
            "    }",
            "};",
            "",
            "// Usage:",
            "// ConcreteDerived d1;",
            "// d1.interface();",
            "// AnotherDerived d2;",
            "// d2.interface();"
        ],
        "description": "Snippet for Static Polymorphism using CRTP"
    },
    "Rule of Zero/Three/Five": {
        "prefix": "cpp_best_practises__ruleof",
        "body": [
            "// Rule of Zero: If you don't define any of the special member functions (destructor, copy constructor, copy assignment, move constructor, move assignment), the compiler generates them for you.",
            "// Rule of Three: If you define any of the destructor, copy constructor, or copy assignment operator, you should define all three.",
            "// Rule of Five: With C++11, if you define any of the destructor, copy constructor, copy assignment operator, move constructor, or move assignment operator, you should define all five.",
            "",
            "class MyResource {",
            "public:",
            "    // Constructor",
            "    MyResource() { /* acquire resource */ }",
            "    // Destructor (Rule of Three/Five)",
            "    ~MyResource() { /* release resource */ }",
            "    // Copy Constructor (Rule of Three/Five)",
            "    MyResource(const MyResource& other) { /* deep copy */ }",
            "    // Copy Assignment Operator (Rule of Three/Five)",
            "    MyResource& operator=(const MyResource& other) { /* deep copy */ return *this; }",
            "    // Move Constructor (Rule of Five)",
            "    MyResource(MyResource&& other) noexcept { /* move resource */ }",
            "    // Move Assignment Operator (Rule of Five)",
            "    MyResource& operator=(MyResource&& other) noexcept { /* move resource */ return *this; }",
            "};"
        ],
        "description": "Snippet for Rule of Zero/Three/Five"
    },
    "Avoid Raw Loops": {
        "prefix": "cpp_best_practises__avoidloops",
        "body": [
            "// Avoid raw loops; prefer standard library algorithms (e.g., std::for_each, std::transform, std::accumulate, std::find, std::sort)",
            "// Bad:",
            "// for (int i = 0; i < vec.size(); ++i) {",
            "//     std::cout << vec[i] << \" \";",
            "// }",
            "// Good:",
            "std::vector<int> numbers = {1, 2, 3, 4, 5};",
            "std::for_each(numbers.begin(), numbers.end(), [](int n) {",
            "    std::cout << n << \" \";",
            "});",
            "std::cout << std::endl;",
            "",
            "// Example: Summing elements",
            "int sum = std::accumulate(numbers.begin(), numbers.end(), 0);",
            "std::cout << \"Sum: \" << sum << std::endl;"
        ],
        "description": "Snippet for avoiding raw loops and preferring algorithms"
    },
    "Use override and final": {
        "prefix": "cpp_best_practises__overridefinal",
        "body": [
            "// Use 'override' to explicitly state that a member function is overriding a virtual function in a base class.",
            "// Use 'final' to prevent a virtual function from being overridden in a derived class, or to prevent a class from being inherited.",
            "",
            "class Base {",
            "public:",
            "    virtual void doSomething() {",
            "        std::cout << \"Base::doSomething\" << std::endl;",
            "    }",
            "    virtual void doSomethingElse() final {",
            "        std::cout << \"Base::doSomethingElse (final)\" << std::endl;",
            "    }",
            "};",
            "",
            "class Derived : public Base {",
            "public:",
            "    void doSomething() override { // Explicitly override",
            "        std::cout << \"Derived::doSomething\" << std::endl;",
            "    }",
            "    // void doSomethingElse() override; // ERROR: cannot override final function",
            "};",
            "",
            "// class FinalClass final { /* ... */ }; // Prevents further inheritance"
        ],
        "description": "Snippet for using override and final keywords"
    },
    "Prefer enum class over plain enum": {
        "prefix": "cpp_best_practises__enumclass",
        "body": [
            "// Prefer 'enum class' (scoped enums) over plain 'enum' for type safety and to avoid name collisions.",
            "// Bad:",
            "// enum Color { RED, GREEN, BLUE };",
            "// enum CarType { SEDAN, SUV, RED }; // Name collision with Color::RED",
            "// Good:",
            "enum class Color { RED, GREEN, BLUE };",
            "enum class CarType { SEDAN, SUV, TRUCK };",
            "",
            "// Usage:",
            "// Color c = Color::RED;",
            "// CarType ct = CarType::SUV;"
        ],
        "description": "Snippet for preferring enum class"
    },
    "Use nullptr instead of NULL or 0": {
        "prefix": "cpp_best_practises__nullptr",
        "body": [
            "// Use 'nullptr' for null pointer constants. It is type-safe and avoids ambiguities.",
            "// Bad:",
            "// int* ptr1 = NULL;",
            "// int* ptr2 = 0;",
            "// Good:",
            "int* ptr3 = nullptr;",
            "",
            "// Example with overloaded functions:",
            "// void func(int);",
            "// void func(char*);",
            "// func(NULL); // Ambiguous, might call func(int)",
            "// func(nullptr); // Clearly calls func(char*)"
        ],
        "description": "Snippet for using nullptr"
    },
    "Prefer std::string_view": {
        "prefix": "cpp_best_practises__stringview",
        "body": [
            "// Prefer std::string_view for string parameters that don't need to own the string (C++17 and later).",
            "// It avoids unnecessary string copies and allocations.",
            "// Bad:",
            "// void print_name(const std::string& name) { std::cout << name << std::endl; }",
            "// Good:",
            "void print_name(std::string_view name) {",
            "    std::cout << name << std::endl;",
            "}",
            "",
            "// Usage:",
            "// std::string s = \"Hello\";",
            "// print_name(s);",
            "// print_name(\"World\");"
        ],
        "description": "Snippet for preferring std::string_view"
    },
    "Const Member Functions": {
        "prefix": "cpp_best_practises__constmember",
        "body": [
            "// Use 'const' for member functions that do not modify the object's state.",
            "// This allows them to be called on const objects and provides better compile-time checking.",
            "class MyClass {",
            "public:",
            "    MyClass(int val) : value_(val) {}",
            "",
            "    int getValue() const { // This function does not modify 'value_'",
            "        return value_;",
            "    }",
            "",
            "    void setValue(int val) { // This function modifies 'value_'",
            "        value_ = val;",
            "    }",
            "",
            "private:",
            "    int value_;",
            "};",
            "",
            "// Usage:",
            "// const MyClass obj(10);",
            "// std::cout << obj.getValue() << std::endl; // OK",
            "// obj.setValue(20); // ERROR: cannot call non-const function on const object"
        ],
        "description": "Snippet for const member functions"
    },
    "Use noexcept": {
        "prefix": "cpp_best_practises__noexcept",
        "body": [
            "// Use 'noexcept' for functions that are guaranteed not to throw exceptions.",
            "// This allows the compiler to generate more optimized code and improves exception safety.",
            "void func_that_does_not_throw() noexcept {",
            "    // This function is guaranteed not to throw",
            "    std::cout << \"This function is noexcept.\" << std::endl;",
            "}",
            "",
            "// Example: Move constructor/assignment should often be noexcept",
            "class MyMovableClass {",
            "public:",
            "    MyMovableClass() = default;",
            "    MyMovableClass(MyMovableClass&& other) noexcept {",
            "        // Move resources, ensure no exceptions",
            "    }",
            "    MyMovableClass& operator=(MyMovableClass&& other) noexcept {",
            "        // Move resources, ensure no exceptions",
            "        return *this;",
            "    }",
            "};"
        ],
        "description": "Snippet for using noexcept"
    },
    "Prefer std::array or std::vector": {
        "prefix": "cpp_best_practises__stdarrayvector",
        "body": [
            "// Prefer std::array or std::vector over C-style arrays for better type safety, bounds checking, and easier memory management.",
            "// std::array for fixed-size arrays:",
            "std::array<int, 5> arr = {1, 2, 3, 4, 5};",
            "std::cout << \"std::array size: \" << arr.size() << std::endl;",
            "",
            "// std::vector for dynamic-size arrays:",
            "std::vector<double> vec = {1.1, 2.2, 3.3};",
            "vec.push_back(4.4);",
            "std::cout << \"std::vector size: \" << vec.size() << std::endl;",
            "",
            "// Accessing elements:",
            "// std::cout << arr[0] << \", \" << vec.at(1) << std::endl;"
        ],
        "description": "Snippet for preferring std::array or std::vector"
    },
    "Use nodiscard": {
        "prefix": "cpp_best_practises__nodiscard",
        "body": [
            "// Use the [[nodiscard]] attribute for functions whose return values should not be ignored.",
            "// This helps prevent common programming errors where a function's result is crucial but not used.",
            "[[nodiscard]] int calculate_sum(int a, int b) {",
            "    return a + b;",
            "}",
            "",
            "// Usage:",
            "// calculate_sum(1, 2); // Compiler warning/error if return value is ignored",
            "// int result = calculate_sum(3, 4); // OK"
        ],
        "description": "Snippet for using nodiscard attribute"
    },
    "Prefer make_unique/make_shared": {
        "prefix": "cpp_best_practises__makepointer",
        "body": [
            "// Prefer std::make_unique and std::make_shared for creating smart pointers.",
            "// They provide exception safety and can be more efficient.",
            "// Bad:",
            "// std::unique_ptr<MyObject> obj1(new MyObject());",
            "// std::shared_ptr<MyObject> obj2(new MyObject());",
            "// Good:",
            "std::unique_ptr<MyObject> obj3 = std::make_unique<MyObject>();",
            "std::shared_ptr<MyObject> obj4 = std::make_shared<MyObject>();",
            "",
            "// For arrays with unique_ptr:",
            "// std::unique_ptr<int[]> arr = std::make_unique<int[]>(10);"
        ],
        "description": "Snippet for preferring make_unique/make_shared"
    },
    "Use explicit for single-argument constructors": {
        "prefix": "cpp_best_practises__explicitctor",
        "body": [
            "// Use 'explicit' for single-argument constructors to prevent unintended implicit conversions.",
            "class MyClass {",
            "public:",
            "    // Bad: Allows implicit conversion from int to MyClass",
            "    // MyClass(int size) : data_(size) {}",
            "",
            "    // Good: Requires explicit conversion",
            "    explicit MyClass(int size) : data_(size) {}",
            "",
            "private:",
            "    std::vector<int> data_;",
            "};",
            "",
            "// Usage:",
            "// MyClass obj1 = 10; // ERROR if constructor is explicit",
            "// MyClass obj2(10); // OK",
            "// MyClass obj3 = static_cast<MyClass>(10); // OK with explicit cast"
        ],
        "description": "Snippet for using explicit for single-argument constructors"
    },
    "C.1: Prefer concrete types over type aliases for parameters": {
        "prefix": "cpp_core_guidelines__c1",
        "body": [
            "// C.1: Prefer concrete types over type aliases for parameters",
            "// Bad:",
            "// using Index = int;",
            "// void f(Index i);",
            "// Good:",
            "void f(int i); // Clearly indicates an integer parameter"
        ],
        "description": "Snippet for C.1: Prefer concrete types over type aliases for parameters"
    },
    "C.2: Use gsl::owner<T*> to indicate ownership": {
        "prefix": "cpp_core_guidelines__c2",
        "body": [
            "// C.2: Use gsl::owner<T*> to indicate ownership",
            "// gsl::owner is part of the Guidelines Support Library (GSL)",
            "// Example: Function taking ownership of a pointer",
            "void take_ownership(gsl::owner<MyObject*> obj) {",
            "    std::unique_ptr<MyObject> p(obj); // Transfer ownership to unique_ptr",
            "    // ... use p ...",
            "} // obj is deleted when p goes out of scope"
        ],
        "description": "Snippet for C.2: Use gsl::owner<T*> to indicate ownership"
    },
    "F.20: For \"out\" parameters, prefer to return a pair or tuple": {
        "prefix": "cpp_core_guidelines__f20",
        "body": [
            "// F.20: For \"out\" parameters, prefer to return a pair or tuple",
            "// Bad:",
            "// void get_values(int& x, int& y);",
            "// Good:",
            "std::pair<int, int> get_values() {",
            "    int x = 10;",
            "    int y = 20;",
            "    return {x, y};",
            "}",
            "",
            "// Usage:",
            "// auto [val1, val2] = get_values();"
        ],
        "description": "Snippet for F.20: For \"out\" parameters, prefer to return a pair or tuple"
    },
    "R.1: Manage resources automatically using RAII": {
        "prefix": "cpp_core_guidelines__r1",
        "body": [
            "// R.1: Manage resources automatically using RAII",
            "// Example: File handling with RAII",
            "class FileHandle {",
            "public:",
            "    FileHandle(const std::string& filename, const std::string& mode) {",
            "        file_ = fopen(filename.c_str(), mode.c_str());",
            "        if (!file_) {",
            "            throw std::runtime_error(\"Failed to open file\");",
            "        }",
            "    }",
            "    ~FileHandle() {",
            "        if (file_) {",
            "            fclose(file_);",
            "        }",
            "    }",
            "    // Disable copy and assignment for unique resource",
            "    FileHandle(const FileHandle&) = delete;",
            "    FileHandle& operator=(const FileHandle&) = delete;",
            "",
            "    // Add move semantics if needed",
            "    FileHandle(FileHandle&& other) noexcept : file_(other.file_) {",
            "        other.file_ = nullptr;",
            "    }",
            "    FileHandle& operator=(FileHandle&& other) noexcept {",
            "        if (this != &other) {",
            "            if (file_) fclose(file_);",
            "            file_ = other.file_;",
            "            other.file_ = nullptr;",
            "        }",
            "        return *this;",
            "    }",
            "",
            "    FILE* get() const { return file_; }",
            "",
            "private:",
            "    FILE* file_;",
            "};",
            "",
            "void process_file(const std::string& filename) {",
            "    try {",
            "        FileHandle fh(filename, \"r\");",
            "        // Use fh.get() to access the file pointer",
            "        char buffer[256];",
            "        while (fgets(buffer, sizeof(buffer), fh.get())) {",
            "            std::cout << buffer;",
            "        }",
            "    } catch (const std::exception& e) {",
            "        std::cerr << \"Error: \" << e.what() << std::endl;",
            "    }",
            "}"
        ],
        "description": "Snippet for R.1: Manage resources automatically using RAII"
    },
    "Boost Math Constants": {
        "prefix": "bm_const",
        "body": [
            "boost::math::constants::pi<double>()"
        ],
        "description": "Insert Boost Math pi constant"
    },
    "Boost Math Gamma Function": {
        "prefix": "bm_gamma",
        "body": [
            "boost::math::tgamma(${1:x})"
        ],
        "description": "Insert Boost Math gamma function"
    },
    "Boost Beast HTTP Get": {
        "prefix": "bb_http_get",
        "body": [
            "namespace http = boost::beast::http;",
            "namespace net = boost::asio;",
            "namespace ip = net::ip;",
            "",
            "net::io_context ioc;",
            "tcp::resolver resolver(ioc);",
            "boost::beast::tcp_stream stream(ioc);",
            "",
            "auto const results = resolver.resolve(\"${1:host}\", \"${2:port}\");",
            "stream.connect(results);",
            "",
            "http::request<http::string_body> req{http::verb::get, \"${3:/}\", ${4:11}};",
            "req.set(http::field::host, \"${1:host}\");",
            "req.set(http::field::user_agent, BOOST_BEAST_VERSION_STRING);",
            "",
            "http::write(stream, req);",
            "",
            "boost::beast::flat_buffer buffer;",
            "http::response<http::string_body> res;",
            "http::read(stream, buffer, res);",
            "",
            "std::cout << res << std::endl;",
            "",
            "boost::system::error_code ec;",
            "stream.socket().shutdown(tcp::socket::shutdown_both, ec);",
            "if(ec && ec != boost::system::errc::not_connected) throw boost::system::system_error{ec};"
        ],
        "description": "Boost Beast HTTP GET request example"
    },
    "FMT Print": {
        "prefix": "fmt_print",
        "body": [
            "fmt::print(\"${1:Hello, {}}\", ${2:\"world\"});"
        ],
        "description": "Insert fmt::print statement"
    },
    "FMT Format": {
        "prefix": "fmt_format",
        "body": [
            "fmt::format(\"${1:The answer is {}.}\", ${2:42});"
        ],
        "description": "Insert fmt::format statement"
    },
    "Nlohmann JSON Include": {
        "prefix": "json_include",
        "body": [
            "#include <nlohmann/json.hpp>"
        ],
        "description": "Include nlohmann/json header"
    },
    "Nlohmann JSON Object": {
        "prefix": "json_object",
        "body": [
            "nlohmann::json ${1:j};",
            "${1:j}[\"${2:key}\"] = ${3:value};"
        ],
        "description": "Create a nlohmann::json object"
    },
    "Nlohmann JSON Parse String": {
        "prefix": "json_parse_string",
        "body": [
            "auto ${1:j} = nlohmann::json::parse(${2:json_string});"
        ],
        "description": "Parse JSON from a string"
    },
    "Qt QApplication": {
        "prefix": "qt_app",
        "body": [
            "#include <QApplication>",
            "#include <QLabel>",
            "",
            "int main(int argc, char *argv[]) {",
            "  QApplication app(argc, argv);",
            "",
            "  QLabel label(\"${1:Hello, Qt!}\");",
            "  label.show();",
            "",
            "  return app.exec();",
            "}"
        ],
        "description": "Basic Qt QApplication setup"
    },
    "Qt QPushButton": {
        "prefix": "qt_button",
        "body": [
            "#include <QPushButton>",
            "",
            "QPushButton *${1:button} = new QPushButton(\"${2:Click Me}\");",
            "${1:button}->show();"
        ],
        "description": "Create a QPushButton"
    }
}