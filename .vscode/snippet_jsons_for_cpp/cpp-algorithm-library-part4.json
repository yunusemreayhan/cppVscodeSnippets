{
  "cpp_algorithm__equal": {
    "prefix": "cpp_algorithm__equal",
    "body": [
      "// std::equal - Compare two ranges for equality",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/equal",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "std::vector<int> v1 = {1, 2, 3, 4, 5};",
      "std::vector<int> v2 = {1, 2, 3, 4, 5};",
      "std::vector<int> v3 = {1, 2, 3, 4, 6};",
      "",
      "// Basic equality check",
      "bool are_equal = std::equal(v1.begin(), v1.end(), v2.begin());",
      "std::cout << \"v1 and v2 are equal: \" << std::boolalpha << are_equal << std::endl; // true",
      "",
      "// Check with different range",
      "bool are_equal2 = std::equal(v1.begin(), v1.end(), v3.begin());",
      "std::cout << \"v1 and v3 are equal: \" << std::boolalpha << are_equal2 << std::endl; // false",
      "",
      "// With custom predicate",
      "auto abs_equal = [](int a, int b) { return std::abs(a) == std::abs(b); };",
      "std::vector<int> v4 = {1, -2, 3, -4, 5};",
      "bool abs_are_equal = std::equal(v1.begin(), v1.end(), v4.begin(), abs_equal);",
      "std::cout << \"v1 and v4 are equal (abs): \" << std::boolalpha << abs_are_equal << std::endl; // true",
      "",
      "// C++14 overload with two pairs of iterators",
      "std::vector<int> v5 = {1, 2, 3};",
      "std::vector<int> v6 = {1, 2, 3};",
      "bool are_equal3 = std::equal(v5.begin(), v5.end(), v6.begin(), v6.end());",
      "std::cout << \"v5 and v6 are equal (two ranges): \" << std::boolalpha << are_equal3 << std::endl; // true",
      "$0"
    ],
    "description": "Compares two ranges for equality. Returns true if all elements in the first range are equal to corresponding elements in the second range. The second range must be at least as long as the first. Supports custom predicates. Time complexity: O(n) comparisons. Link: https://en.cppreference.com/w/cpp/algorithm/equal"
  },
  "cpp_algorithm__mismatch": {
    "prefix": "cpp_algorithm__mismatch",
    "body": [
      "// std::mismatch - Find first position where two ranges differ",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/mismatch",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "std::vector<int> v1 = {1, 2, 3, 4, 5};",
      "std::vector<int> v2 = {1, 2, 3, 6, 5};",
      "std::vector<int> v3 = {1, 2, 3, 4, 5};",
      "",
      "// Find first mismatch",
      "auto pair1 = std::mismatch(v1.begin(), v1.end(), v2.begin());",
      "if (pair1.first != v1.end()) {",
      "    std::cout << \"Mismatch at index \" << std::distance(v1.begin(), pair1.first)",
      "              << \": \" << *pair1.first << \" vs \" << *pair1.second << std::endl; // Mismatch at index 3: 4 vs 6",
      "} else {",
      "    std::cout << \"Ranges v1 and v2 are identical.\" << std::endl;",
      "}",
      "",
      "// No mismatch",
      "auto pair2 = std::mismatch(v1.begin(), v1.end(), v3.begin());",
      "if (pair2.first != v1.end()) {",
      "    std::cout << \"Mismatch at index \" << std::distance(v1.begin(), pair2.first)",
      "              << \": \" << *pair2.first << \" vs \" << *pair2.second << std::endl;",
      "} else {",
      "    std::cout << \"Ranges v1 and v3 are identical.\" << std::endl; // Ranges v1 and v3 are identical.",
      "}",
      "",
      "// With custom predicate",
      "auto abs_compare = [](int a, int b) { return std::abs(a) == std::abs(b); };",
      "std::vector<int> v4 = {1, -2, 3, -4, 5};",
      "auto pair3 = std::mismatch(v1.begin(), v1.end(), v4.begin(), abs_compare);",
      "if (pair3.first != v1.end()) {",
      "    std::cout << \"Mismatch (abs) at index \" << std::distance(v1.begin(), pair3.first)",
      "              << \": \" << *pair3.first << \" vs \" << *pair3.second << std::endl;",
      "} else {",
      "    std::cout << \"Ranges v1 and v4 are identical (abs).\" << std::endl; // Ranges v1 and v4 are identical (abs).",
      "}",
      "",
      "// C++14 overload with two pairs of iterators",
      "std::vector<int> v5 = {1, 2, 3};",
      "std::vector<int> v6 = {1, 2, 4};",
      "auto pair4 = std::mismatch(v5.begin(), v5.end(), v6.begin(), v6.end());",
      "if (pair4.first != v5.end()) {",
      "    std::cout << \"Mismatch (two ranges) at index \" << std::distance(v5.begin(), pair4.first)",
      "              << \": \" << *pair4.first << \" vs \" << *pair4.second << std::endl; // Mismatch (two ranges) at index 2: 3 vs 4",
      "}",
      "$0"
    ],
    "description": "Finds the first position where two ranges differ. Returns a pair of iterators to the first differing elements in each range. If the ranges are identical up to the end of the first range, it returns a pair of iterators to the end of the first range and the corresponding position in the second. Supports custom predicates. Time complexity: O(n) comparisons. Link: https://en.cppreference.com/w/cpp/algorithm/mismatch"
  },
  "cpp_algorithm__is_permutation": {
    "prefix": "cpp_algorithm__is_permutation",
    "body": [
      "// std::is_permutation - Check if one range is a permutation of another",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/is_permutation",
      "#include <algorithm>",
      "#include <vector>",
      "#include <string>",
      "#include <iostream>",
      "",
      "std::vector<int> v1 = {1, 2, 3, 4, 5};",
      "std::vector<int> v2 = {5, 4, 3, 2, 1};",
      "std::vector<int> v3 = {1, 2, 3, 4, 6};",
      "std::vector<int> v4 = {1, 2, 3, 4};",
      "",
      "// Check if v2 is a permutation of v1",
      "bool is_perm = std::is_permutation(v1.begin(), v1.end(), v2.begin());",
      "std::cout << \"v2 is permutation of v1: \" << std::boolalpha << is_perm << std::endl; // true",
      "",
      "// Check with non-permutation",
      "bool is_perm2 = std::is_permutation(v1.begin(), v1.end(), v3.begin());",
      "std::cout << \"v3 is permutation of v1: \" << std::boolalpha << is_perm2 << std::endl; // false",
      "",
      "// Check with different size (false)",
      "bool is_perm3 = std::is_permutation(v1.begin(), v1.end(), v4.begin());",
      "std::cout << \"v4 is permutation of v1: \" << std::boolalpha << is_perm3 << std::endl; // false (sizes differ)",
      "",
      "// With custom predicate",
      "auto abs_equal = [](int a, int b) { return std::abs(a) == std::abs(b); };",
      "std::vector<int> v5 = {1, -2, 3, -4, 5};",
      "std::vector<int> v6 = {5, 4, -3, 2, -1};",
      "bool is_perm_abs = std::is_permutation(v5.begin(), v5.end(), v6.begin(), abs_equal);",
      "std::cout << \"v6 is permutation of v5 (abs): \" << std::boolalpha << is_perm_abs << std::endl; // true",
      "",
      "// C++14 overload with two pairs of iterators",
      "std::string s1 = \"listen\";",
      "std::string s2 = \"silent\";",
      "bool is_perm_str = std::is_permutation(s1.begin(), s1.end(), s2.begin(), s2.end());",
      "std::cout << \"'silent' is permutation of 'listen': \" << std::boolalpha << is_perm_str << std::endl; // true",
      "$0"
    ],
    "description": "Checks if the elements in one range are a permutation of the elements in another range. Both ranges must have the same number of elements. Supports custom predicates. Time complexity: O(N^2) in general, O(N log N) if elements are hashable or sortable. Link: https://en.cppreference.com/w/cpp/algorithm/is_permutation"
  },
  "cpp_algorithm__is_sorted": {
    "prefix": "cpp_algorithm__is_sorted",
    "body": [
      "// std::is_sorted - Check if range is sorted",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/is_sorted",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "std::vector<int> v1 = {1, 2, 3, 4, 5};",
      "std::vector<int> v2 = {1, 3, 2, 4, 5};",
      "std::vector<int> v3 = {5, 4, 3, 2, 1};",
      "",
      "// Check ascending order",
      "bool sorted_asc = std::is_sorted(v1.begin(), v1.end());",
      "std::cout << \"v1 is sorted (asc): \" << std::boolalpha << sorted_asc << std::endl; // true",
      "",
      "bool sorted_asc2 = std::is_sorted(v2.begin(), v2.end());",
      "std::cout << \"v2 is sorted (asc): \" << std::boolalpha << sorted_asc2 << std::endl; // false",
      "",
      "// Check descending order with custom comparator",
      "bool sorted_desc = std::is_sorted(v3.begin(), v3.end(), std::greater<int>());",
      "std::cout << \"v3 is sorted (desc): \" << std::boolalpha << sorted_desc << std::endl; // true",
      "",
      "// Empty or single-element range is always sorted",
      "std::vector<int> empty_v;",
      "bool empty_sorted = std::is_sorted(empty_v.begin(), empty_v.end());",
      "std::cout << \"Empty vector is sorted: \" << std::boolalpha << empty_sorted << std::endl; // true",
      "",
      "std::vector<int> single_v = {42};",
      "bool single_sorted = std::is_sorted(single_v.begin(), single_v.end());",
      "std::cout << \"Single-element vector is sorted: \" << std::boolalpha << single_sorted << std::endl; // true",
      "$0"
    ],
    "description": "Checks if a range is sorted in non-descending order. Returns true if the range is sorted, false otherwise. Supports custom comparison predicates. Time complexity: O(n) comparisons. Link: https://en.cppreference.com/w/cpp/algorithm/is_sorted"
  },
  "cpp_algorithm__is_sorted_until": {
    "prefix": "cpp_algorithm__is_sorted_until",
    "body": [
      "// std::is_sorted_until - Find first unsorted element in range",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/is_sorted_until",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "std::vector<int> v1 = {1, 2, 3, 4, 5, 0, 6};",
      "std::vector<int> v2 = {1, 2, 3, 4, 5};",
      "",
      "// Find first unsorted element (ascending)",
      "auto it1 = std::is_sorted_until(v1.begin(), v1.end());",
      "if (it1 != v1.end()) {",
      "    std::cout << \"v1 is sorted until index \" << std::distance(v1.begin(), it1)",
      "              << \", value: \" << *it1 << std::endl; // v1 is sorted until index 5, value: 0",
      "} else {",
      "    std::cout << \"v1 is fully sorted.\" << std::endl;",
      "}",
      "",
      "// Fully sorted range",
      "auto it2 = std::is_sorted_until(v2.begin(), v2.end());",
      "if (it2 != v2.end()) {",
      "    std::cout << \"v2 is sorted until index \" << std::distance(v2.begin(), it2)",
      "              << \", value: \" << *it2 << std::endl;",
      "} else {",
      "    std::cout << \"v2 is fully sorted.\" << std::endl; // v2 is fully sorted.",
      "}",
      "",
      "// With custom comparator (descending)",
      "std::vector<int> v3 = {5, 4, 3, 1, 2, 0};",
      "auto it3 = std::is_sorted_until(v3.begin(), v3.end(), std::greater<int>());",
      "if (it3 != v3.end()) {",
      "    std::cout << \"v3 is sorted (desc) until index \" << std::distance(v3.begin(), it3)",
      "              << \", value: \" << *it3 << std::endl; // v3 is sorted (desc) until index 3, value: 1",
      "}",
      "$0"
    ],
    "description": "Returns an iterator to the first element in a range that is not sorted according to the specified order. If the entire range is sorted, it returns the end iterator. Supports custom comparison predicates. Time complexity: O(n) comparisons. Link: https://en.cppreference.com/w/cpp/algorithm/is_sorted_until"
  },
  "cpp_algorithm__is_partitioned": {
    "prefix": "cpp_algorithm__is_partitioned",
    "body": [
      "// std::is_partitioned - Check if range is partitioned",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/is_partitioned",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "// Predicate: is even",
      "auto is_even = [](int n) { return n % 2 == 0; };",
      "",
      "std::vector<int> v1 = {2, 4, 6, 1, 3, 5}; // Partitioned: evens then odds",
      "std::vector<int> v2 = {2, 1, 4, 3, 6, 5}; // Not partitioned",
      "std::vector<int> v3 = {1, 3, 5, 2, 4, 6}; // Partitioned: odds then evens (predicate is_even)",
      "",
      "// Check if v1 is partitioned by is_even",
      "bool partitioned1 = std::is_partitioned(v1.begin(), v1.end(), is_even);",
      "std::cout << \"v1 is partitioned by is_even: \" << std::boolalpha << partitioned1 << std::endl; // true",
      "",
      "// Check if v2 is partitioned by is_even",
      "bool partitioned2 = std::is_partitioned(v2.begin(), v2.end(), is_even);",
      "std::cout << \"v2 is partitioned by is_even: \" << std::boolalpha << partitioned2 << std::endl; // false",
      "",
      "// Check if v3 is partitioned by is_even",
      "bool partitioned3 = std::is_partitioned(v3.begin(), v3.end(), is_even);",
      "std::cout << \"v3 is partitioned by is_even: \" << std::boolalpha << partitioned3 << std::endl; // false (elements satisfying predicate are not first)",
      "",
      "// A range with all elements satisfying or none satisfying is partitioned",
      "std::vector<int> v4 = {2, 4, 6};",
      "bool partitioned4 = std::is_partitioned(v4.begin(), v4.end(), is_even);",
      "std::cout << \"v4 is partitioned by is_even: \" << std::boolalpha << partitioned4 << std::endl; // true",
      "",
      "std::vector<int> v5 = {1, 3, 5};",
      "bool partitioned5 = std::is_partitioned(v5.begin(), v5.end(), is_even);",
      "std::cout << \"v5 is partitioned by is_even: \" << std::boolalpha << partitioned5 << std::endl; // true",
      "$0"
    ],
    "description": "Checks if a range is partitioned according to a given predicate. A range is partitioned if all elements for which the predicate is true come before all elements for which the predicate is false. Time complexity: O(n) applications of the predicate. Link: https://en.cppreference.com/w/cpp/algorithm/is_partitioned"
  },
  "cpp_algorithm__shuffle": {
    "prefix": "cpp_algorithm__shuffle",
    "body": [
      "// std::shuffle - Randomly reorder elements in a range (C++11)",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/shuffle",
      "#include <algorithm>",
      "#include <vector>",
      "#include <random>",
      "#include <chrono>",
      "#include <iostream>",
      "",
      "std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};",
      "",
      "// Obtain a random number engine",
      "unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();",
      "std::default_random_engine rng(seed);",
      "",
      "std::cout << \"Original vector: \";",
      "for (int x : v) std::cout << x << \" \";",
      "std::cout << std::endl;",
      "",
      "// Shuffle the vector",
      "std::shuffle(v.begin(), v.end(), rng);",
      "",
      "std::cout << \"Shuffled vector: \";",
      "for (int x : v) std::cout << x << \" \";",
      "std::cout << std::endl;",
      "",
      "// Shuffle again",
      "std::shuffle(v.begin(), v.end(), rng);",
      "",
      "std::cout << \"Shuffled again: \";",
      "for (int x : v) std::cout << x << \" \";",
      "std::cout << std::endl;",
      "",
      "// Example with a deck of cards (represented by integers)",
      "std::vector<int> deck(52);",
      "std::iota(deck.begin(), deck.end(), 1); // Fill with 1 to 52",
      "std::shuffle(deck.begin(), deck.end(), rng);",
      "",
      "// Deal first 5 cards",
      "std::cout << \"First 5 cards: \";",
      "for (int i = 0; i < 5; ++i) std::cout << deck[i] << \" \";",
      "std::cout << std::endl;",
      "$0"
    ],
    "description": "Randomly reorders the elements in a range using a given random number generator. Provides a uniform distribution over all possible permutations. Requires a C++11 compatible random number engine. Time complexity: O(n) swaps. Link: https://en.cppreference.com/w/cpp/algorithm/shuffle"
  },
  "cpp_algorithm__sample": {
    "prefix": "cpp_algorithm__sample",
    "body": [
      "// std::sample - Selects n random elements from a range (C++17)",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/sample",
      "#include <algorithm>",
      "#include <vector>",
      "#include <random>",
      "#include <chrono>",
      "#include <iostream>",
      "",
      "std::vector<int> population = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};",
      "std::vector<int> sample_vec(5); // Destination for 5 random elements",
      "",
      "// Obtain a random number engine",
      "unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();",
      "std::default_random_engine rng(seed);",
      "",
      "std::cout << \"Population: \";",
      "for (int x : population) std::cout << x << \" \";",
      "std::cout << std::endl;",
      "",
      "// Take a random sample of 5 elements",
      "std::sample(population.begin(), population.end(),",
      "            sample_vec.begin(), sample_vec.size(), rng);",
      "",
      "std::cout << \"Sample (5 elements): \";",
      "for (int x : sample_vec) std::cout << x << \" \";",
      "std::cout << std::endl;",
      "",
      "// Take a smaller sample directly to cout",
      "std::cout << \"Sample (3 elements, direct): \";",
      "std::sample(population.begin(), population.end(),",
      "            std::ostream_iterator<int>(std::cout, \" \"), 3, rng);",
      "std::cout << std::endl;",
      "",
      "// Sampling with replacement (not directly supported by std::sample, requires custom logic)",
      "// std::sample performs sampling without replacement.",
      "$0"
    ],
    "description": "Selects n random elements from a given range and copies them to a destination range. The selection is done without replacement. The order of the sampled elements is not guaranteed. Requires a C++11 compatible random number engine. Time complexity: O(N) on average, where N is the size of the input range. Link: https://en.cppreference.com/w/cpp/algorithm/sample"
  },
  "cpp_algorithm__partition_copy": {
    "prefix": "cpp_algorithm__partition_copy",
    "body": [
      "// std::partition_copy - Copy elements to two different ranges based on predicate (C++11)",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/partition_copy",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};",
      "std::vector<int> evens;",
      "std::vector<int> odds;",
      "",
      "// Predicate: is even",
      "auto is_even = [](int n) { return n % 2 == 0; };",
      "",
      "// Resize destination vectors to avoid reallocations (optional but good practice)",
      "evens.reserve(numbers.size());",
      "odds.reserve(numbers.size());",
      "",
      "// Partition and copy",
      "std::partition_copy(numbers.begin(), numbers.end(),",
      "                    std::back_inserter(evens),",
      "                    std::back_inserter(odds),",
      "                    is_even);",
      "",
      "std::cout << \"Original numbers: \";",
      "for (int n : numbers) std::cout << n << \" \";",
      "std::cout << std::endl;",
      "",
      "std::cout << \"Evens: \";",
      "for (int n : evens) std::cout << n << \" \";",
      "std::cout << std::endl; // Evens: 2 4 6 8 10",
      "",
      "std::cout << \"Odds: \";",
      "for (int n : odds) std::cout << n << \" \";",
      "std::cout << std::endl; // Odds: 1 3 5 7 9",
      "",
      "// Example with strings based on length",
      "std::vector<std::string> words = {\"apple\", \"cat\", \"banana\", \"dog\", \"elephant\"};",
      "std::vector<std::string> short_words;",
      "std::vector<std::string> long_words;",
      "",
      "auto is_short = [](const std::string& s) { return s.length() <= 4; };",
      "",
      "std::partition_copy(words.begin(), words.end(),",
      "                    std::back_inserter(short_words),",
      "                    std::back_inserter(long_words),",
      "                    is_short);",
      "",
      "std::cout << \"Short words: \";",
      "for (const std::string& s : short_words) std::cout << s << \" \";",
      "std::cout << std::endl; // Short words: cat dog",
      "",
      "std::cout << \"Long words: \";",
      "for (const std::string& s : long_words) std::cout << s << \" \";",
      "std::cout << std::endl; // Long words: apple banana elephant",
      "$0"
    ],
    "description": "Copies elements from an input range to two different output ranges based on a predicate. Elements for which the predicate is true are copied to the first destination, and elements for which it is false are copied to the second. The relative order of elements within each output range is preserved. Time complexity: O(n) applications of the predicate and copies. Link: https://en.cppreference.com/w/cpp/algorithm/partition_copy"
  }
}
