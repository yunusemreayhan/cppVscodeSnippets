{
  "cpp_14__generic_lambdas": {
    "prefix": "cpp_14__generic_lambdas",
    "body": [
      "// C++14: Generic lambdas with auto parameters",
      "",
      "// Generic lambda - works with any type",
      "auto generic_add = [](auto a, auto b) {",
      "    return a + b;",
      "};",
      "",
      "// Usage with different types",
      "std::cout << generic_add(5, 3) << std::endl;        // int",
      "std::cout << generic_add(5.5, 3.2) << std::endl;    // double",
      "std::cout << generic_add(std::string(\"Hello \"), std::string(\"World\")) << std::endl;",
      "",
      "// Generic lambda with multiple parameters",
      "auto print_pair = [](auto first, auto second) {",
      "    std::cout << \"First: \" << first << \", Second: \" << second << std::endl;",
      "};",
      "",
      "// Variadic generic lambda",
      "auto print_all = [](auto... args) {",
      "    ((std::cout << args << \" \"), ...); // C++17 fold expression",
      "    std::cout << std::endl;",
      "};",
      "",
      "// Generic lambda in STL algorithms",
      "std::vector<int> vec = {1, 2, 3, 4, 5};",
      "std::transform(vec.begin(), vec.end(), vec.begin(),",
      "    [](auto x) { return x * x; });",
      "$0"
    ],
    "description": "C++14 generic lambdas with auto parameters"
  },

  "cpp_14__lambda_init_capture": {
    "prefix": "cpp_14__lambda_init_capture",
    "body": [
      "// C++14: Lambda init capture (generalized lambda capture)",
      "",
      "// Move capture",
      "auto ptr = std::make_unique<int>(42);",
      "auto lambda1 = [p = std::move(ptr)]() {",
      "    std::cout << *p << std::endl;",
      "};",
      "",
      "// Initialize with expression",
      "auto lambda2 = [value = 10 * 2]() {",
      "    return value;",
      "};",
      "",
      "// Capture with different name",
      "int x = 5;",
      "auto lambda3 = [&r = x]() {",
      "    r++; // Modifies x",
      "};",
      "",
      "// Multiple init captures",
      "auto lambda4 = [a = 1, b = 2, c = a + b]() {",
      "    return a + b + c; // Returns 6",
      "};",
      "",
      "// Capture expensive objects by move",
      "std::vector<int> data(1000000);",
      "auto lambda5 = [vec = std::move(data)]() {",
      "    // vec now owns the data",
      "    return vec.size();",
      "};",
      "$0"
    ],
    "description": "C++14 lambda init capture for move semantics and expressions"
  },

  "cpp_14__return_type_deduction": {
    "prefix": "cpp_14__return_type_deduction",
    "body": [
      "// C++14: Return type deduction for functions",
      "",
      "// Auto return type",
      "auto add(int a, int b) {",
      "    return a + b; // Return type deduced as int",
      "}",
      "",
      "// Template with auto return",
      "template<typename T, typename U>",
      "auto multiply(T t, U u) {",
      "    return t * u; // Return type is decltype(t * u)",
      "}",
      "",
      "// Multiple return statements must deduce to same type",
      "auto getValue(bool flag) {",
      "    if (flag)",
      "        return 42;    // int",
      "    else",
      "        return 84;    // int - OK, same type",
      "}",
      "",
      "// Recursive function with auto",
      "auto factorial(int n) -> int { // Still need trailing return for recursion",
      "    if (n <= 1) return 1;",
      "    return n * factorial(n - 1);",
      "}",
      "",
      "// decltype(auto) for exact type deduction",
      "template<typename T>",
      "decltype(auto) forward_value(T&& t) {",
      "    return std::forward<T>(t); // Preserves value category",
      "}",
      "$0"
    ],
    "description": "C++14 return type deduction with auto and decltype(auto)"
  },

  "cpp_14__relaxed_constexpr": {
    "prefix": "cpp_14__relaxed_constexpr",
    "body": [
      "// C++14: Relaxed constexpr restrictions",
      "",
      "// C++14 allows multiple statements, loops, and local variables",
      "constexpr int factorial(int n) {",
      "    int result = 1;",
      "    for (int i = 1; i <= n; ++i) {",
      "        result *= i;",
      "    }",
      "    return result;",
      "}",
      "",
      "// constexpr member functions can modify object",
      "class Point {",
      "    int x, y;",
      "public:",
      "    constexpr Point(int x, int y) : x(x), y(y) {}",
      "    ",
      "    constexpr void move(int dx, int dy) {",
      "        x += dx;  // C++14: Can modify members",
      "        y += dy;",
      "    }",
      "    ",
      "    constexpr int getX() const { return x; }",
      "    constexpr int getY() const { return y; }",
      "};",
      "",
      "// Complex constexpr function",
      "constexpr int fibonacci(int n) {",
      "    if (n <= 1) return n;",
      "    ",
      "    int prev = 0, curr = 1;",
      "    for (int i = 2; i <= n; ++i) {",
      "        int next = prev + curr;",
      "        prev = curr;",
      "        curr = next;",
      "    }",
      "    return curr;",
      "}",
      "",
      "constexpr int fib10 = fibonacci(10); // Computed at compile time",
      "$0"
    ],
    "description": "C++14 relaxed constexpr with loops and multiple statements"
  },

  "cpp_14__variable_templates": {
    "prefix": "cpp_14__variable_templates",
    "body": [
      "// C++14: Variable templates",
      "",
      "// Basic variable template",
      "template<typename T>",
      "constexpr T pi = T(3.1415926535897932385);",
      "",
      "// Usage",
      "float f = pi<float>;",
      "double d = pi<double>;",
      "long double ld = pi<long double>;",
      "",
      "// Variable template with specialization",
      "template<typename T>",
      "constexpr T max_value = std::numeric_limits<T>::max();",
      "",
      "template<>",
      "constexpr int max_value<int> = INT_MAX;",
      "",
      "// Variable template for type traits",
      "template<typename T>",
      "constexpr bool is_pointer_v = std::is_pointer<T>::value;",
      "",
      "// Template variable with template template parameter",
      "template<template<typename> class Trait, typename T>",
      "constexpr bool satisfies_v = Trait<T>::value;",
      "",
      "// Usage",
      "if constexpr (is_pointer_v<int*>) { // C++17 if constexpr",
      "    // Handle pointer",
      "}",
      "$0"
    ],
    "description": "C++14 variable templates"
  },

  "cpp_14__binary_literals": {
    "prefix": "cpp_14__binary_literals",
    "body": [
      "// C++14: Binary literals with 0b or 0B prefix",
      "",
      "// Binary literals",
      "int binary8 = 0b11111111;        // 255",
      "int binary16 = 0b1111111111111111; // 65535",
      "int flags = 0b00001101;          // 13",
      "",
      "// With digit separators (C++14)",
      "int readable_binary = 0b1111'0000'1111'0000; // More readable",
      "int byte_pattern = 0b1010'1010;  // 170 (0xAA)",
      "",
      "// Bit manipulation examples",
      "constexpr int BIT_0 = 0b0000'0001;",
      "constexpr int BIT_1 = 0b0000'0010;",
      "constexpr int BIT_2 = 0b0000'0100;",
      "constexpr int BIT_3 = 0b0000'1000;",
      "",
      "// Check specific bits",
      "int value = 0b1010'1100;",
      "bool bit3_set = value & BIT_3; // true",
      "",
      "// Binary literal in template",
      "template<unsigned N>",
      "struct binary_value {",
      "    static constexpr unsigned value = N;",
      "};",
      "",
      "using eight_bits = binary_value<0b11111111>;",
      "$0"
    ],
    "description": "C++14 binary literals and digit separators"
  },

  "cpp_14__digit_separators": {
    "prefix": "cpp_14__digit_separators",
    "body": [
      "// C++14: Digit separators using single quotes",
      "",
      "// Integer literals with separators",
      "int million = 1'000'000;",
      "long billion = 1'000'000'000L;",
      "long long trillion = 1'000'000'000'000LL;",
      "",
      "// Different bases",
      "int decimal = 123'456'789;",
      "int hex = 0xDEAD'BEEF;",
      "int octal = 0'123'456;",
      "int binary = 0b1010'1100'1110'0001;",
      "",
      "// Floating point",
      "double pi = 3.141'592'653'589'793;",
      "float avogadro = 6.022'140'857e23f;",
      "",
      "// Custom grouping (any position is valid)",
      "int custom = 1'23'456'7890; // Valid but unconventional",
      "",
      "// Useful for bit patterns",
      "unsigned int rgba = 0xFF'FF'FF'FF; // White color, full alpha",
      "unsigned int color = 0x00'FF'00'FF; // Green with full alpha",
      "",
      "// Credit card number representation",
      "long long card_number = 1234'5678'9012'3456LL;",
      "$0"
    ],
    "description": "C++14 digit separators for improved readability"
  },

  "cpp_14__deprecated_attribute": {
    "prefix": "cpp_14__deprecated_attribute",
    "body": [
      "// C++14: [[deprecated]] attribute",
      "",
      "// Deprecate a function",
      "[[deprecated]]",
      "void old_function() {",
      "    std::cout << \"This function is deprecated\\n\";",
      "}",
      "",
      "// Deprecate with custom message",
      "[[deprecated(\"Use new_function() instead\")]]",
      "void legacy_api() {",
      "    // Old implementation",
      "}",
      "",
      "// Deprecate class",
      "[[deprecated(\"Use ModernClass instead\")]]",
      "class OldClass {",
      "public:",
      "    void doSomething() {}",
      "};",
      "",
      "// Deprecate typedef/using",
      "[[deprecated(\"Use std::int32_t\")]]",
      "typedef int old_int_type;",
      "",
      "// Deprecate enum value",
      "enum Status {",
      "    OK,",
      "    ERROR,",
      "    [[deprecated(\"Use ERROR instead\")]] FAIL",
      "};",
      "",
      "// Deprecate template",
      "template<typename T>",
      "[[deprecated(\"Use std::optional<T> instead\")]]",
      "class Maybe {",
      "    // Implementation",
      "};",
      "$0"
    ],
    "description": "C++14 [[deprecated]] attribute for marking obsolete code"
  },

  "cpp_14__make_unique": {
    "prefix": "cpp_14__make_unique",
    "body": [
      "// C++14: std::make_unique for creating unique_ptr",
      "#include <memory>",
      "",
      "// Basic usage",
      "auto ptr1 = std::make_unique<int>(42);",
      "auto ptr2 = std::make_unique<std::string>(\"Hello\");",
      "",
      "// Array version",
      "auto arr_ptr = std::make_unique<int[]>(10); // Array of 10 ints",
      "",
      "// With custom class",
      "class Widget {",
      "    int x, y;",
      "public:",
      "    Widget(int x, int y) : x(x), y(y) {}",
      "};",
      "",
      "auto widget = std::make_unique<Widget>(10, 20);",
      "",
      "// Exception safety",
      "// Bad (C++11): potential leak if second allocation throws",
      "// function(std::unique_ptr<int>(new int(42)), std::unique_ptr<int>(new int(13)));",
      "",
      "// Good (C++14): exception safe",
      "function(std::make_unique<int>(42), std::make_unique<int>(13));",
      "",
      "// In container",
      "std::vector<std::unique_ptr<int>> vec;",
      "vec.push_back(std::make_unique<int>(1));",
      "vec.push_back(std::make_unique<int>(2));",
      "$0"
    ],
    "description": "C++14 std::make_unique for safe unique_ptr creation"
  },

  "cpp_14__exchange": {
    "prefix": "cpp_14__exchange",
    "body": [
      "// C++14: std::exchange utility",
      "#include <utility>",
      "",
      "// Basic usage - replaces old value with new and returns old",
      "int x = 5;",
      "int old_x = std::exchange(x, 10); // x is now 10, old_x is 5",
      "",
      "// Useful in move constructors/assignment",
      "class Resource {",
      "    int* data;",
      "    size_t size;",
      "public:",
      "    // Move constructor",
      "    Resource(Resource&& other) noexcept",
      "        : data(std::exchange(other.data, nullptr)),",
      "          size(std::exchange(other.size, 0)) {}",
      "    ",
      "    // Move assignment",
      "    Resource& operator=(Resource&& other) noexcept {",
      "        if (this != &other) {",
      "            delete[] data;",
      "            data = std::exchange(other.data, nullptr);",
      "            size = std::exchange(other.size, 0);",
      "        }",
      "        return *this;",
      "    }",
      "};",
      "",
      "// Swap implementation using exchange",
      "template<typename T>",
      "void my_swap(T& a, T& b) {",
      "    T temp = std::exchange(a, std::move(b));",
      "    b = std::move(temp);",
      "}",
      "$0"
    ],
    "description": "C++14 std::exchange for replacing values"
  },

  "cpp_14__integer_sequence": {
    "prefix": "cpp_14__integer_sequence",
    "body": [
      "// C++14: std::integer_sequence and helpers",
      "#include <utility>",
      "#include <tuple>",
      "#include <array>",
      "",
      "// Using index_sequence to expand tuple",
      "template<typename Tuple, std::size_t... Is>",
      "void print_tuple_impl(const Tuple& t, std::index_sequence<Is...>) {",
      "    ((std::cout << std::get<Is>(t) << \" \"), ...); // C++17 fold",
      "}",
      "",
      "template<typename... Args>",
      "void print_tuple(const std::tuple<Args...>& t) {",
      "    print_tuple_impl(t, std::index_sequence_for<Args...>{});",
      "}",
      "",
      "// Convert array to tuple",
      "template<typename T, std::size_t N, std::size_t... Is>",
      "auto array_to_tuple_impl(const std::array<T, N>& arr, std::index_sequence<Is...>) {",
      "    return std::make_tuple(arr[Is]...);",
      "}",
      "",
      "template<typename T, std::size_t N>",
      "auto array_to_tuple(const std::array<T, N>& arr) {",
      "    return array_to_tuple_impl(arr, std::make_index_sequence<N>{});",
      "}",
      "",
      "// Apply function to tuple elements",
      "template<typename F, typename Tuple, std::size_t... Is>",
      "auto apply_impl(F&& f, Tuple&& t, std::index_sequence<Is...>) {",
      "    return f(std::get<Is>(std::forward<Tuple>(t))...);",
      "}",
      "",
      "template<typename F, typename Tuple>",
      "auto apply(F&& f, Tuple&& t) {",
      "    return apply_impl(std::forward<F>(f), std::forward<Tuple>(t),",
      "        std::make_index_sequence<std::tuple_size_v<std::decay_t<Tuple>>>{});",
      "}",
      "$0"
    ],
    "description": "C++14 std::integer_sequence for compile-time sequences"
  },

  "cpp_14__chrono_literals": {
    "prefix": "cpp_14__chrono_literals",
    "body": [
      "// C++14: User-defined literals for chrono durations",
      "#include <chrono>",
      "#include <thread>",
      "",
      "using namespace std::chrono_literals;",
      "",
      "// Duration literals",
      "auto one_second = 1s;",
      "auto half_second = 500ms;",
      "auto five_minutes = 5min;",
      "auto two_hours = 2h;",
      "auto one_microsecond = 1us;",
      "auto one_nanosecond = 1ns;",
      "",
      "// Using in sleep",
      "std::this_thread::sleep_for(100ms);",
      "std::this_thread::sleep_for(2s);",
      "",
      "// Complex durations",
      "auto duration = 1h + 30min + 45s;",
      "auto precise_time = 1s + 500ms + 250us;",
      "",
      "// In conditions",
      "auto start = std::chrono::steady_clock::now();",
      "// ... do work ...",
      "auto end = std::chrono::steady_clock::now();",
      "",
      "if (end - start > 1s) {",
      "    std::cout << \"Operation took more than 1 second\\n\";",
      "}",
      "",
      "// Timeout example",
      "std::condition_variable cv;",
      "std::mutex mtx;",
      "std::unique_lock<std::mutex> lock(mtx);",
      "if (cv.wait_for(lock, 5s) == std::cv_status::timeout) {",
      "    std::cout << \"Timeout occurred\\n\";",
      "}",
      "$0"
    ],
    "description": "C++14 chrono user-defined literals"
  },

  "cpp_14__shared_timed_mutex": {
    "prefix": "cpp_14__shared_timed_mutex",
    "body": [
      "// C++14: std::shared_timed_mutex for reader/writer locks",
      "#include <shared_mutex>",
      "#include <thread>",
      "#include <vector>",
      "",
      "class ThreadSafeCounter {",
      "    mutable std::shared_timed_mutex mutex;",
      "    int value = 0;",
      "",
      "public:",
      "    // Multiple threads can read simultaneously",
      "    int get() const {",
      "        std::shared_lock<std::shared_timed_mutex> lock(mutex);",
      "        return value;",
      "    }",
      "    ",
      "    // Only one thread can write",
      "    void increment() {",
      "        std::unique_lock<std::shared_timed_mutex> lock(mutex);",
      "        ++value;",
      "    }",
      "    ",
      "    // Try to get write lock with timeout",
      "    bool try_increment_for(std::chrono::milliseconds timeout) {",
      "        std::unique_lock<std::shared_timed_mutex> lock(mutex, std::defer_lock);",
      "        if (lock.try_lock_for(timeout)) {",
      "            ++value;",
      "            return true;",
      "        }",
      "        return false;",
      "    }",
      "};",
      "",
      "// Usage example",
      "ThreadSafeCounter counter;",
      "",
      "// Multiple reader threads",
      "std::vector<std::thread> readers;",
      "for (int i = 0; i < 5; ++i) {",
      "    readers.emplace_back([&counter]() {",
      "        for (int j = 0; j < 100; ++j) {",
      "            int val = counter.get();",
      "            std::this_thread::yield();",
      "        }",
      "    });",
      "}",
      "$0"
    ],
    "description": "C++14 std::shared_timed_mutex for reader/writer locks"
  },

  "cpp_14__heterogeneous_lookup": {
    "prefix": "cpp_14__heterogeneous_lookup",
    "body": [
      "// C++14: Heterogeneous lookup in associative containers",
      "#include <set>",
      "#include <map>",
      "#include <string>",
      "#include <string_view>",
      "",
      "// Custom comparator with is_transparent",
      "struct StringCompare {",
      "    using is_transparent = void; // Enable heterogeneous lookup",
      "    ",
      "    bool operator()(const std::string& a, const std::string& b) const {",
      "        return a < b;",
      "    }",
      "    ",
      "    bool operator()(const std::string& a, const char* b) const {",
      "        return a < b;",
      "    }",
      "    ",
      "    bool operator()(const char* a, const std::string& b) const {",
      "        return a < b;",
      "    }",
      "    ",
      "    bool operator()(const char* a, const char* b) const {",
      "        return std::strcmp(a, b) < 0;",
      "    }",
      "};",
      "",
      "// Use with set",
      "std::set<std::string, StringCompare> string_set = {",
      "    \"apple\", \"banana\", \"cherry\"",
      "};",
      "",
      "// Can now find with const char* without creating std::string",
      "auto it = string_set.find(\"banana\"); // No temporary std::string created",
      "",
      "// Use with map",
      "std::map<std::string, int, StringCompare> word_count;",
      "word_count[\"hello\"] = 5;",
      "",
      "// Efficient lookup with string literal",
      "if (word_count.find(\"hello\") != word_count.end()) {",
      "    std::cout << \"Found!\\n\";",
      "}",
      "$0"
    ],
    "description": "C++14 heterogeneous lookup in associative containers"
  },

  "cpp_14__quoted": {
    "prefix": "cpp_14__quoted",
    "body": [
      "// C++14: std::quoted for quoted string I/O",
      "#include <iostream>",
      "#include <iomanip>",
      "#include <sstream>",
      "#include <string>",
      "",
      "// Writing quoted strings",
      "std::string text = \"Hello \\\"World\\\" with spaces\";",
      "std::stringstream ss;",
      "",
      "// Without quoted - spaces break the string",
      "ss << text;",
      "std::string word;",
      "ss >> word; // Only gets \"Hello\"",
      "ss.clear();",
      "ss.str(\"\");",
      "",
      "// With quoted - preserves the full string",
      "ss << std::quoted(text);",
      "std::string full_text;",
      "ss >> std::quoted(full_text); // Gets entire string with quotes handled",
      "",
      "std::cout << \"Original: \" << text << std::endl;",
      "std::cout << \"With quoted: \" << std::quoted(text) << std::endl;",
      "",
      "// Custom delimiter and escape",
      "ss.str(\"\");",
      "ss << std::quoted(text, '`', '\\\\');",
      "std::cout << \"Custom: \" << ss.str() << std::endl;",
      "",
      "// Useful for CSV-like data",
      "std::vector<std::string> data = {\"Name\", \"John Doe\", \"Address, City\"};",
      "for (const auto& field : data) {",
      "    std::cout << std::quoted(field) << \",\";",
      "}",
      "$0"
    ],
    "description": "C++14 std::quoted for handling quoted strings in I/O"
  },

  "cpp_14__sized_deallocation": {
    "prefix": "cpp_14__sized_deallocation",
    "body": [
      "// C++14: Sized deallocation",
      "#include <new>",
      "#include <cstddef>",
      "#include <iostream>",
      "",
      "// Global sized deallocation (automatically used by delete)",
      "void operator delete(void* ptr, std::size_t size) noexcept {",
      "    std::cout << \"Deallocating \" << size << \" bytes\\n\";",
      "    ::operator delete(ptr);",
      "}",
      "",
      "void operator delete[](void* ptr, std::size_t size) noexcept {",
      "    std::cout << \"Deallocating array of \" << size << \" bytes\\n\";",
      "    ::operator delete[](ptr);",
      "}",
      "",
      "// Class-specific sized deallocation",
      "class Widget {",
      "    int data[100];",
      "public:",
      "    static void operator delete(void* ptr, std::size_t size) noexcept {",
      "        std::cout << \"Widget deallocation: \" << size << \" bytes\\n\";",
      "        ::operator delete(ptr);",
      "    }",
      "};",
      "",
      "// Usage",
      "int* p = new int(42);",
      "delete p; // Calls sized deallocation with sizeof(int)",
      "",
      "Widget* w = new Widget;",
      "delete w; // Calls Widget's sized deallocation",
      "",
      "int* arr = new int[10];",
      "delete[] arr; // Calls array sized deallocation",
      "$0"
    ],
    "description": "C++14 sized deallocation for better memory management"
  },

  "cpp_14__tuple_addressing_by_type": {
    "prefix": "cpp_14__tuple_addressing_by_type",
    "body": [
      "// C++14: Tuple addressing by type",
      "#include <tuple>",
      "#include <string>",
      "#include <iostream>",
      "",
      "// Create tuple with unique types",
      "std::tuple<int, double, std::string> data(42, 3.14, \"hello\");",
      "",
      "// C++11 way - by index",
      "int i = std::get<0>(data);",
      "double d = std::get<1>(data);",
      "std::string s = std::get<2>(data);",
      "",
      "// C++14 way - by type (only works if type is unique)",
      "int i2 = std::get<int>(data);",
      "double d2 = std::get<double>(data);",
      "std::string s2 = std::get<std::string>(data);",
      "",
      "// Modify by type",
      "std::get<int>(data) = 100;",
      "std::get<std::string>(data) = \"world\";",
      "",
      "// Error if type is not unique",
      "// std::tuple<int, int, double> t2(1, 2, 3.14);",
      "// int val = std::get<int>(t2); // Compile error: type not unique",
      "",
      "// Works with tie",
      "int x;",
      "double y;",
      "std::string z;",
      "std::tie(x, y, z) = data;",
      "$0"
    ],
    "description": "C++14 tuple addressing by type for unique types"
  },

  "cpp_14__aggregate_member_initialization": {
    "prefix": "cpp_14__aggregate_member_initialization",
    "body": [
      "// C++14: Aggregate member initialization",
      "",
      "// C++14 allows aggregates to have default member initializers",
      "struct Point {",
      "    int x = 0;  // Default member initializer",
      "    int y = 0;  // Still an aggregate in C++14",
      "};",
      "",
      "// Aggregate initialization still works",
      "Point p1{};        // x=0, y=0 (using defaults)",
      "Point p2{5};       // x=5, y=0 (partial initialization)",
      "Point p3{5, 10};   // x=5, y=10",
      "",
      "// More complex aggregate",
      "struct Config {",
      "    int width = 800;",
      "    int height = 600;",
      "    bool fullscreen = false;",
      "    double scale = 1.0;",
      "};",
      "",
      "// Various initialization styles",
      "Config cfg1{};                    // All defaults",
      "Config cfg2{1920, 1080};          // Custom resolution, other defaults",
      "Config cfg3{1920, 1080, true};    // Custom resolution and fullscreen",
      "Config cfg4{.width=1280, .height=720}; // C++20 designated initializers",
      "$0"
    ],
    "description": "C++14 aggregates with default member initializers"
  },

  "cpp_14__decltype_auto": {
    "prefix": "cpp_14__decltype_auto",
    "body": [
      "// C++14: decltype(auto) for perfect forwarding of return types",
      "",
      "// decltype(auto) deduces the exact type including references",
      "int x = 5;",
      "int& get_x() { return x; }",
      "const int& get_const_x() { return x; }",
      "",
      "// auto would deduce int (loses reference)",
      "auto a = get_x();        // a is int",
      "decltype(auto) b = get_x(); // b is int&",
      "",
      "// Perfect forwarding in generic code",
      "template<typename F, typename... Args>",
      "decltype(auto) forward_call(F&& f, Args&&... args) {",
      "    return std::forward<F>(f)(std::forward<Args>(args)...);",
      "}",
      "",
      "// Preserves const and reference qualifiers",
      "decltype(auto) c = get_const_x(); // c is const int&",
      "decltype(auto) d = (x);           // d is int& (parentheses matter!)",
      "decltype(auto) e = x;             // e is int",
      "",
      "// Generic getter that preserves return type",
      "template<typename Container, typename Index>",
      "decltype(auto) get_element(Container&& c, Index i) {",
      "    return std::forward<Container>(c)[i];",
      "}",
      "",
      "// Works with member access",
      "struct Data {",
      "    int value;",
      "    int& get() { return value; }",
      "    const int& get() const { return value; }",
      "};",
      "",
      "template<typename T>",
      "decltype(auto) access_value(T&& obj) {",
      "    return std::forward<T>(obj).get();",
      "}",
      "$0"
    ],
    "description": "C++14 decltype(auto) for exact type deduction"
  },

  "cpp_14__constexpr_extensions": {
    "prefix": "cpp_14__constexpr_extensions",
    "body": [
      "// C++14: Extended constexpr capabilities",
      "",
      "// C++14 allows non-const constexpr member functions",
      "class Counter {",
      "    int count = 0;",
      "public:",
      "    constexpr int increment() {",
      "        return ++count; // Can modify members in C++14",
      "    }",
      "    constexpr int get() const { return count; }",
      "};",
      "",
      "// constexpr with local variables and mutations",
      "constexpr int complex_calculation(int n) {",
      "    int sum = 0;",
      "    int product = 1;",
      "    ",
      "    for (int i = 1; i <= n; ++i) {",
      "        sum += i;",
      "        product *= i;",
      "        ",
      "        // Can have multiple statements",
      "        if (i % 2 == 0) {",
      "            sum += 1;",
      "        }",
      "    }",
      "    ",
      "    return sum + product;",
      "}",
      "",
      "// constexpr constructors can have function body",
      "class Rectangle {",
      "    double width, height;",
      "public:",
      "    constexpr Rectangle(double w, double h) : width(w), height(h) {",
      "        // Can have statements in constructor body",
      "        if (width < 0) width = 0;",
      "        if (height < 0) height = 0;",
      "    }",
      "    ",
      "    constexpr double area() const { return width * height; }",
      "};",
      "",
      "// Use at compile time",
      "constexpr Rectangle rect(5.0, 3.0);",
      "constexpr double area = rect.area(); // 15.0",
      "$0"
    ],
    "description": "C++14 extended constexpr with mutations and statements"
  },

  "cpp_14__std_cbegin_cend": {
    "prefix": "cpp_14__std_cbegin_cend",
    "body": [
      "// C++14: std::cbegin, std::cend, std::rbegin, std::rend, etc.",
      "#include <iterator>",
      "#include <vector>",
      "#include <array>",
      "",
      "// Works with arrays, containers, and C-arrays",
      "std::vector<int> vec = {1, 2, 3, 4, 5};",
      "int arr[] = {1, 2, 3, 4, 5};",
      "std::array<int, 5> std_arr = {1, 2, 3, 4, 5};",
      "",
      "// Const iterators (C++14)",
      "auto cit1 = std::cbegin(vec);    // vector<int>::const_iterator",
      "auto cit2 = std::cend(vec);",
      "auto cit3 = std::cbegin(arr);    // const int*",
      "auto cit4 = std::cend(arr);",
      "",
      "// Reverse iterators (C++14)",
      "auto rit1 = std::rbegin(vec);    // reverse_iterator",
      "auto rit2 = std::rend(vec);",
      "auto rit3 = std::rbegin(arr);",
      "auto rit4 = std::rend(arr);",
      "",
      "// Const reverse iterators (C++14)",
      "auto crit1 = std::crbegin(vec);  // const_reverse_iterator",
      "auto crit2 = std::crend(vec);",
      "",
      "// Generic code that works with any container",
      "template<typename Container>",
      "void print_reverse(const Container& c) {",
      "    for (auto it = std::crbegin(c); it != std::crend(c); ++it) {",
      "        std::cout << *it << \" \";",
      "    }",
      "}",
      "",
      "// Size and empty (C++17, but often implemented earlier)",
      "auto size1 = std::size(arr);     // 5",
      "auto size2 = std::size(vec);     // 5",
      "bool empty = std::empty(vec);    // false",
      "$0"
    ],
    "description": "C++14 generic begin/end functions"
  },

  "cpp_14__transparent_operator_functors": {
    "prefix": "cpp_14__transparent_operator_functors",
    "body": [
      "// C++14: Transparent operator functors",
      "#include <functional>",
      "#include <algorithm>",
      "#include <vector>",
      "#include <string>",
      "",
      "// C++14 adds specializations with void that deduce types",
      "std::vector<int> numbers = {1, 2, 3, 4, 5};",
      "",
      "// C++11 way - must specify types",
      "// std::transform(numbers.begin(), numbers.end(), numbers.begin(),",
      "//                std::plus<int>());",
      "",
      "// C++14 way - transparent functors with void",
      "std::transform(numbers.begin(), numbers.end(), numbers.begin(),",
      "               std::plus<>()); // Note: no type specified",
      "",
      "// Works with different types",
      "std::vector<double> doubles = {1.1, 2.2, 3.3};",
      "std::vector<int> ints = {1, 2, 3};",
      "std::vector<double> results(3);",
      "",
      "std::transform(doubles.begin(), doubles.end(), ints.begin(),",
      "               results.begin(), std::plus<>()); // Mixed types!",
      "",
      "// All arithmetic operators have transparent versions",
      "std::plus<> add;",
      "std::minus<> subtract;",
      "std::multiplies<> multiply;",
      "std::divides<> divide;",
      "std::modulus<> mod;",
      "std::negate<> neg;",
      "",
      "// Comparison operators too",
      "std::equal_to<> eq;",
      "std::not_equal_to<> neq;",
      "std::greater<> gt;",
      "std::less<> lt;",
      "std::greater_equal<> ge;",
      "std::less_equal<> le;",
      "",
      "// Example: heterogeneous comparison",
      "std::vector<std::string> words = {\"apple\", \"banana\", \"cherry\"};",
      "auto it = std::find_if(words.begin(), words.end(),",
      "    [](const std::string& s) { return std::less<>()(s, \"banana\"); });",
      "$0"
    ],
    "description": "C++14 transparent operator functors"
  },

  "cpp_14__is_final": {
    "prefix": "cpp_14__is_final",
    "body": [
      "// C++14: std::is_final type trait",
      "#include <type_traits>",
      "#include <iostream>",
      "",
      "// Regular class",
      "class Base {",
      "public:",
      "    virtual void foo() {}",
      "};",
      "",
      "// Final class",
      "class Derived final : public Base {",
      "public:",
      "    void foo() override {}",
      "};",
      "",
      "// Cannot inherit from final class",
      "// class MoreDerived : public Derived {}; // Error!",
      "",
      "// Check if class is final",
      "static_assert(!std::is_final<Base>::value, \"Base should not be final\");",
      "static_assert(std::is_final<Derived>::value, \"Derived should be final\");",
      "",
      "// C++17 style with _v suffix",
      "static_assert(!std::is_final_v<Base>);",
      "static_assert(std::is_final_v<Derived>);",
      "",
      "// Template that only accepts non-final classes",
      "template<typename T>",
      "class Wrapper : public T {",
      "    static_assert(!std::is_final<T>::value,",
      "                  \"Cannot wrap final classes\");",
      "};",
      "",
      "// Usage in SFINAE",
      "template<typename T>",
      "typename std::enable_if<!std::is_final<T>::value, bool>::type",
      "can_derive_from() {",
      "    return true;",
      "}",
      "",
      "template<typename T>",
      "typename std::enable_if<std::is_final<T>::value, bool>::type",
      "can_derive_from() {",
      "    return false;",
      "}",
      "$0"
    ],
    "description": "C++14 std::is_final type trait"
  },

  "cpp_14__result_of_SFINAE": {
    "prefix": "cpp_14__result_of_SFINAE",
    "body": [
      "// C++14: std::result_of SFINAE-friendly",
      "#include <type_traits>",
      "#include <utility>",
      "",
      "// C++14 makes std::result_of SFINAE-friendly",
      "// If the expression is invalid, no hard error",
      "",
      "// Function object",
      "struct Callable {",
      "    int operator()(int x) { return x * 2; }",
      "    // No operator() for double",
      "};",
      "",
      "// Check if callable with specific arguments",
      "template<typename F, typename... Args>",
      "using result_of_t = typename std::result_of<F(Args...)>::type;",
      "",
      "// SFINAE-friendly check",
      "template<typename F, typename... Args>",
      "struct is_callable {",
      "private:",
      "    template<typename T>",
      "    static auto test(int) -> decltype(",
      "        std::declval<T>()(std::declval<Args>()...),",
      "        std::true_type{}",
      "    );",
      "    ",
      "    template<typename>",
      "    static std::false_type test(...);",
      "    ",
      "public:",
      "    static constexpr bool value = decltype(test<F>(0))::value;",
      "};",
      "",
      "// Usage",
      "static_assert(is_callable<Callable, int>::value, \"Should be callable with int\");",
      "static_assert(!is_callable<Callable, double>::value, \"Should not be callable with double\");",
      "",
      "// Generic invoke wrapper",
      "template<typename F, typename... Args,",
      "         typename = typename std::enable_if<is_callable<F, Args...>::value>::type>",
      "auto invoke(F&& f, Args&&... args)",
      "    -> typename std::result_of<F(Args...)>::type {",
      "    return std::forward<F>(f)(std::forward<Args>(args)...);",
      "}",
      "$0"
    ],
    "description": "C++14 SFINAE-friendly std::result_of"
  },

  "cpp_14__string_udls": {
    "prefix": "cpp_14__string_udls",
    "body": [
      "// C++14: String user-defined literals",
      "#include <string>",
      "#include <complex>",
      "#include <chrono>",
      "",
      "using namespace std::string_literals;",
      "",
      "// String literal that creates std::string",
      "auto str1 = \"Hello World\"s;  // std::string, not const char*",
      "auto str2 = \"Line 1\\nLine 2\"s;",
      "",
      "// Useful for string concatenation",
      "auto greeting = \"Hello \"s + \"World\"s; // Both are std::string",
      "",
      "// Works with raw string literals",
      "auto raw = R\"(C:\\Users\\Path)\"s; // std::string with raw content",
      "",
      "// Avoids array decay",
      "auto get_string() {",
      "    return \"Returned string\"s; // Returns std::string, not dangling pointer",
      "}",
      "",
      "// Complex number literals (also C++14)",
      "using namespace std::complex_literals;",
      "auto c1 = 1.0 + 2.0i;  // std::complex<double>(1.0, 2.0)",
      "auto c2 = 3.14i;       // std::complex<double>(0, 3.14)",
      "auto c3 = 2if;         // std::complex<float>(0, 2)",
      "auto c4 = 3il;         // std::complex<long double>(0, 3)",
      "",
      "// All standard library UDLs in inline namespaces",
      "using namespace std::literals; // Gets all of them",
      "$0"
    ],
    "description": "C++14 string and complex number UDLs"
  },

  "cpp_14__generic_lambda_captures": {
    "prefix": "cpp_14__generic_lambda_captures",
    "body": [
      "// C++14: Generic lambda captures with init-capture",
      "#include <memory>",
      "#include <vector>",
      "#include <algorithm>",
      "",
      "// Capture by move with new name",
      "std::vector<int> data = {1, 2, 3, 4, 5};",
      "auto process = [vec = std::move(data)](auto func) {",
      "    // data is now empty, vec owns the elements",
      "    for (auto& elem : vec) {",
      "        func(elem);",
      "    }",
      "};",
      "",
      "// Capture with computation",
      "int x = 10, y = 20;",
      "auto compute = [sum = x + y, product = x * y](auto op) {",
      "    return op(sum, product);",
      "};",
      "",
      "// Capture member variables by value",
      "struct Widget {",
      "    int value = 42;",
      "    auto getLambda() {",
      "        return [capturedValue = value](auto multiplier) {",
      "            return capturedValue * multiplier;",
      "        };",
      "    }",
      "};",
      "",
      "// Perfect forwarding in captures",
      "template<typename T>",
      "auto make_lambda(T&& value) {",
      "    return [cap = std::forward<T>(value)](auto func) mutable {",
      "        return func(cap);",
      "    };",
      "}",
      "$0"
    ],
    "description": "C++14 generic lambdas with init-capture"
  },

  "cpp_14__tuple_type_traits": {
    "prefix": "cpp_14__tuple_type_traits",
    "body": [
      "// C++14: Tuple type traits",
      "#include <tuple>",
      "#include <type_traits>",
      "",
      "// tuple_element_t - C++14 alias template",
      "using MyTuple = std::tuple<int, double, std::string>;",
      "using FirstType = std::tuple_element_t<0, MyTuple>;  // int",
      "using SecondType = std::tuple_element_t<1, MyTuple>; // double",
      "using ThirdType = std::tuple_element_t<2, MyTuple>;  // std::string",
      "",
      "// C++11 way for comparison",
      "// using FirstType = typename std::tuple_element<0, MyTuple>::type;",
      "",
      "// Works with pairs too",
      "using MyPair = std::pair<int, std::string>;",
      "using PairFirst = std::tuple_element_t<0, MyPair>;   // int",
      "using PairSecond = std::tuple_element_t<1, MyPair>;  // std::string",
      "",
      "// Generic function using tuple_element_t",
      "template<std::size_t I, typename Tuple>",
      "auto get_element_copy(const Tuple& t) -> std::tuple_element_t<I, Tuple> {",
      "    return std::get<I>(t);",
      "}",
      "",
      "// tuple_size_v is C++17, but pattern shown for completeness",
      "template<typename Tuple>",
      "constexpr std::size_t tuple_size_v = std::tuple_size<Tuple>::value;",
      "$0"
    ],
    "description": "C++14 tuple type traits and alias templates"
  },

  "cpp_14__enable_if_t": {
    "prefix": "cpp_14__enable_if_t",
    "body": [
      "// C++14: Type trait alias templates (_t suffix)",
      "#include <type_traits>",
      "",
      "// C++14 provides alias templates for type traits",
      "",
      "// enable_if_t - cleaner SFINAE",
      "template<typename T>",
      "std::enable_if_t<std::is_integral<T>::value, T>",
      "increment(T value) {",
      "    return value + 1;",
      "}",
      "",
      "// C++11 way for comparison",
      "// typename std::enable_if<std::is_integral<T>::value, T>::type",
      "",
      "// conditional_t",
      "template<typename T>",
      "using storage_type = std::conditional_t<",
      "    sizeof(T) <= sizeof(void*),",
      "    T,",
      "    T*",
      ">;",
      "",
      "// decay_t",
      "template<typename T>",
      "void process(T&& value) {",
      "    using DecayedType = std::decay_t<T>;",
      "    DecayedType copy = std::forward<T>(value);",
      "}",
      "",
      "// remove_reference_t, remove_const_t, etc.",
      "template<typename T>",
      "using bare_type = std::remove_cv_t<std::remove_reference_t<T>>;",
      "",
      "// common_type_t",
      "template<typename T, typename U>",
      "auto max(T a, U b) -> std::common_type_t<T, U> {",
      "    return a > b ? a : b;",
      "}",
      "",
      "// All type traits have _t versions in C++14",
      "using Integer = std::make_signed_t<unsigned int>;",
      "using Unsigned = std::make_unsigned_t<int>;",
      "using Array = std::remove_extent_t<int[10]>;",
      "$0"
    ],
    "description": "C++14 type trait alias templates"
  }
}
