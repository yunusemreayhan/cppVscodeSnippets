{
  "cpp_11__auto_and_decltype": {
    "prefix": "cpp_11__auto_and_decltype",
    "body": [
      "// C++11: auto and decltype",
      "auto x = 42;                    // int",
      "auto y = 3.14;                  // double",
      "auto str = std::string(\"hello\"); // std::string",
      "",
      "// decltype for type deduction",
      "int a = 5;",
      "decltype(a) b = 10;            // int",
      "decltype((a)) c = a;           // int& (note double parentheses)",
      "decltype(a + b) d = a + b;     // int",
      "",
      "// Trailing return type with decltype",
      "template<typename T, typename U>",
      "auto add(T t, U u) -> decltype(t + u) {",
      "    return t + u;",
      "}",
      "$0"
    ],
    "description": "C++11 auto and decltype for type deduction"
  },

  "cpp_11__range_for": {
    "prefix": "cpp_11__range_for",
    "body": [
      "// C++11: Range-based for loop",
      "std::vector<int> vec = {1, 2, 3, 4, 5};",
      "",
      "// By value",
      "for (int x : vec) {",
      "    std::cout << x << \" \";",
      "}",
      "",
      "// By reference",
      "for (int& x : vec) {",
      "    x *= 2;",
      "}",
      "",
      "// By const reference (preferred for read-only)",
      "for (const auto& x : vec) {",
      "    std::cout << x << \" \";",
      "}",
      "$0"
    ],
    "description": "C++11 range-based for loop"
  },

  "cpp_11__lambda_expressions": {
    "prefix": "cpp_11__lambda_expressions",
    "body": [
      "// C++11: Lambda expressions",
      "",
      "// Basic lambda",
      "auto simple = []() { std::cout << \"Hello Lambda!\\n\"; };",
      "simple();",
      "",
      "// Lambda with parameters and return type",
      "auto add = [](int a, int b) -> int { return a + b; };",
      "std::cout << add(5, 3) << std::endl;",
      "",
      "// Lambda with capture",
      "int x = 10, y = 20;",
      "auto capture_by_value = [x]() { return x * 2; };",
      "auto capture_by_ref = [&x]() { x *= 2; return x; };",
      "auto capture_all_by_value = [=]() { return x + y; };",
      "auto capture_all_by_ref = [&]() { x += 5; y += 5; };",
      "auto capture_mixed = [&x, y]() { x += y; }; // x by ref, y by value",
      "",
      "// Mutable lambda",
      "auto mutable_lambda = [x]() mutable { return ++x; };",
      "",
      "// Lambda with std::function",
      "std::function<int(int, int)> func = [](int a, int b) { return a * b; };",
      "$0"
    ],
    "description": "C++11 lambda expressions"
  },

  "cpp_11__smart_pointers": {
    "prefix": "cpp_11__smart_pointers",
    "body": [
      "// C++11: Smart pointers",
      "#include <memory>",
      "",
      "// unique_ptr - exclusive ownership",
      "std::unique_ptr<int> uptr1(new int(42));",
      "std::unique_ptr<int> uptr2 = std::make_unique<int>(42); // C++14",
      "// uptr2 = uptr1; // Error! Cannot copy",
      "std::unique_ptr<int> uptr3 = std::move(uptr1); // OK, move ownership",
      "",
      "// unique_ptr with custom deleter",
      "auto deleter = [](int* p) { ",
      "    std::cout << \"Custom deleter\\n\"; ",
      "    delete p; ",
      "};",
      "std::unique_ptr<int, decltype(deleter)> uptr4(new int(42), deleter);",
      "",
      "// shared_ptr - shared ownership",
      "std::shared_ptr<int> sptr1(new int(42));",
      "std::shared_ptr<int> sptr2 = std::make_shared<int>(42); // Preferred",
      "std::shared_ptr<int> sptr3 = sptr2; // OK, shared ownership",
      "std::cout << \"Use count: \" << sptr2.use_count() << std::endl;",
      "",
      "// weak_ptr - weak reference",
      "std::weak_ptr<int> wptr = sptr2;",
      "if (auto sptr = wptr.lock()) { // Convert to shared_ptr if still exists",
      "    std::cout << *sptr << std::endl;",
      "}",
      "",
      "// Enable shared_from_this",
      "class Widget : public std::enable_shared_from_this<Widget> {",
      "public:",
      "    std::shared_ptr<Widget> getPtr() {",
      "        return shared_from_this();",
      "    }",
      "};",
      "$0"
    ],
    "description": "C++11 smart pointers (unique_ptr, shared_ptr, weak_ptr)"
  },

  "cpp_11__move_semantics": {
    "prefix": "cpp_11__move_semantics",
    "body": [
      "// C++11: Move semantics and rvalue references",
      "class MyClass {",
      "private:",
      "    int* data;",
      "    size_t size;",
      "",
      "public:",
      "    // Constructor",
      "    MyClass(size_t s) : size(s), data(new int[s]) {",
      "        std::cout << \"Constructor\\n\";",
      "    }",
      "    ",
      "    // Destructor",
      "    ~MyClass() { ",
      "        delete[] data; ",
      "    }",
      "    ",
      "    // Copy constructor",
      "    MyClass(const MyClass& other) : size(other.size), data(new int[size]) {",
      "        std::cout << \"Copy constructor\\n\";",
      "        std::copy(other.data, other.data + size, data);",
      "    }",
      "    ",
      "    // Move constructor",
      "    MyClass(MyClass&& other) noexcept : data(other.data), size(other.size) {",
      "        std::cout << \"Move constructor\\n\";",
      "        other.data = nullptr;",
      "        other.size = 0;",
      "    }",
      "    ",
      "    // Copy assignment",
      "    MyClass& operator=(const MyClass& other) {",
      "        std::cout << \"Copy assignment\\n\";",
      "        if (this != &other) {",
      "            delete[] data;",
      "            size = other.size;",
      "            data = new int[size];",
      "            std::copy(other.data, other.data + size, data);",
      "        }",
      "        return *this;",
      "    }",
      "    ",
      "    // Move assignment",
      "    MyClass& operator=(MyClass&& other) noexcept {",
      "        std::cout << \"Move assignment\\n\";",
      "        if (this != &other) {",
      "            delete[] data;",
      "            data = other.data;",
      "            size = other.size;",
      "            other.data = nullptr;",
      "            other.size = 0;",
      "        }",
      "        return *this;",
      "    }",
      "};",
      "",
      "// Usage",
      "MyClass obj1(100);",
      "MyClass obj2 = std::move(obj1); // Move constructor",
      "MyClass obj3(200);",
      "obj3 = std::move(obj2); // Move assignment",
      "$0"
    ],
    "description": "C++11 move semantics with move constructor and assignment"
  }
}
