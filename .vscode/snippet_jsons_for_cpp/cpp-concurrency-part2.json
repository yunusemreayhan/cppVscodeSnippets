{
  "cpp_concurrency__std_jthread": {
    "prefix": "cpp_concurrency__std_jthread",
    "body": [
      "// C++ Concurrency: std::jthread (C++20) - Joinable Thread",
      "// std::jthread is a new thread class in C++20 that automatically joins on destruction.",
      "// This prevents common errors like forgetting to call .join() or .detach(),",
      "// which would otherwise terminate the program.",
      "// It also supports cooperative cancellation via a std::stop_token.",
      "#include <iostream>",
      "#include <thread>",
      "#include <chrono>",
      "#include <stop_token>",
      "",
      "void cancellable_task(std::stop_token st) {",
      "    int i = 0;",
      "    while (!st.stop_requested()) {",
      "        std::cout << \"Cancellable task running... \" << i++ << std::endl;",
      "        std::this_thread::sleep_for(std::chrono::milliseconds(200));",
      "    }",
      "    std::cout << \"Cancellable task received stop request and is exiting.\" << std::endl;",
      "}",
      "",
      "void simple_jthread_task() {",
      "    std::cout << \"Simple jthread task running on thread \" << std::this_thread::get_id() << std::endl;",
      "    std::this_thread::sleep_for(std::chrono::seconds(1));",
      "    std::cout << \"Simple jthread task finished.\" << std::endl;",
      "}",
      "",
      "int main() {",
      "    std::cout << \"std::jthread example:\\n\";",
      "",
      "    // 1. Basic std::jthread usage (automatically joins on scope exit)",
      "    {",
      "        std::jthread t1(simple_jthread_task);",
      "        std::cout << \"t1 launched. Main thread continues...\\n\";",
      "    } // t1 goes out of scope here, automatically calls .join()",
      "    std::cout << \"t1 has joined (scope exited).\\n\\n\";",
      "",
      "    // 2. std::jthread with cooperative cancellation",
      "    {",
      "        std::jthread t2(cancellable_task);",
      "        std::cout << \"t2 launched with cancellation support. Main thread waits...\\n\";",
      "        std::this_thread::sleep_for(std::chrono::seconds(1));",
      "        std::cout << \"Main thread requesting stop for t2...\\n\";",
      "        t2.request_stop(); // Request the thread to stop",
      "    } // t2 goes out of scope, automatically calls .join() after stop request",
      "    std::cout << \"t2 has joined (scope exited after stop request).\\n\\n\";",
      "",
      "    // 3. Passing arguments to jthread",
      "    std::jthread t3([](int val) {",
      "        std::cout << \"jthread with argument: \" << val << std::endl;",
      "    }, 42);",
      "    t3.join(); // Can still explicitly join if needed, but not strictly necessary for safety",
      "",
      "    std::cout << \"Main thread finished.\\n\";",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ Concurrency: std::jthread (C++20) for joinable threads with cooperative cancellation."
  },

  "cpp_concurrency__std_atomic_memory_orders": {
    "prefix": "cpp_concurrency__std_atomic_memory_orders",
    "body": [
      "// C++ Concurrency: std::atomic and Memory Orders",
      "// Memory orders define how atomic operations synchronize memory accesses among threads.",
      "// They control the visibility and ordering of non-atomic operations relative to atomic ones.",
      "// Reference: https://en.cppreference.com/w/cpp/atomic/memory_order",
      "#include <iostream>",
      "#include <thread>",
      "#include <atomic>",
      "#include <vector>",
      "#include <string>",
      "",
      "std::atomic<bool> ready_flag(false);",
      "std::atomic<int> data(0);",
      "",
      "// memory_order_relaxed: No synchronization or ordering constraints.",
      "// Only guarantees atomicity of the operation itself.",
      "void relaxed_producer() {",
      "    data.store(100, std::memory_order_relaxed);",
      "    ready_flag.store(true, std::memory_order_relaxed);",
      "    std::cout << \"Relaxed Producer: data stored, flag set.\\n\";",
      "}",
      "",
      "void relaxed_consumer() {",
      "    while (!ready_flag.load(std::memory_order_relaxed)) {",
      "        std::this_thread::yield();",
      "    }",
      "    // No guarantee that data will be 100 here, as there's no ordering.",
      "    std::cout << \"Relaxed Consumer: data = \" << data.load(std::memory_order_relaxed) << \", flag = \" << ready_flag.load(std::memory_order_relaxed) << \"\\n\";",
      "}",
      "",
      "// memory_order_release: Ensures all writes before this operation are visible to other threads",
      "// that perform an acquire operation on the same atomic variable.",
      "void release_producer() {",
      "    data.store(200, std::memory_order_relaxed); // Can be relaxed, as it's before release",
      "    std::string msg = \"Hello from producer!\";",
      "    // Non-atomic writes before this line are guaranteed to be visible",
      "    // to threads that acquire on ready_flag.",
      "    ready_flag.store(true, std::memory_order_release);",
      "    std::cout << \"Release Producer: data stored, flag set.\\n\";",
      "}",
      "",
      "// memory_order_acquire: Ensures all writes after this operation are visible to other threads",
      "// that performed a release operation on the same atomic variable.",
      "void acquire_consumer() {",
      "    while (!ready_flag.load(std::memory_order_acquire)) { // Acquire operation",
      "        std::this_thread::yield();",
      "    }",
      "    // Guaranteed that data will be 200 here due to acquire-release synchronization.",
      "    std::cout << \"Acquire Consumer: data = \" << data.load(std::memory_order_relaxed) << \", flag = \" << ready_flag.load(std::memory_order_relaxed) << \"\\n\";",
      "}",
      "",
      "// memory_order_acq_rel: Combines acquire and release semantics.",
      "// Used for read-modify-write operations (e.g., fetch_add, compare_exchange).",
      "// It's a release operation for prior writes and an acquire operation for subsequent reads.",
      "std::atomic<int> counter(0);",
      "void acq_rel_worker() {",
      "    for (int i = 0; i < 1000; ++i) {",
      "        // fetch_add with acq_rel ensures that this operation is ordered",
      "        // with respect to other acq_rel or seq_cst operations on 'counter'.",
      "        counter.fetch_add(1, std::memory_order_acq_rel);",
      "    }",
      "}",
      "",
      "// memory_order_seq_cst: Sequential consistency (default for atomics).",
      "// Provides a single total order of all sequentially consistent operations.",
      "// Simplest to reason about, but can be more expensive.",
      "std::atomic<int> x(0), y(0);",
      "int r1, r2;",
      "",
      "void write_x() { x.store(1, std::memory_order_seq_cst); }",
      "void write_y() { y.store(1, std::memory_order_seq_cst); }",
      "void read_xy() { r1 = x.load(std::memory_order_seq_cst); r2 = y.load(std::memory_order_seq_cst); }",
      "",
      "int main() {",
      "    std::cout << \"\\n--- Relaxed Memory Order Example ---\\n\";",
      "    ready_flag.store(false, std::memory_order_relaxed); data.store(0, std::memory_order_relaxed);",
      "    std::thread t_rp(relaxed_producer);",
      "    std::thread t_rc(relaxed_consumer);",
      "    t_rp.join(); t_rc.join();",
      "",
      "    std::cout << \"\\n--- Acquire-Release Memory Order Example ---\\n\";",
      "    ready_flag.store(false, std::memory_order_relaxed); data.store(0, std::memory_order_relaxed);",
      "    std::thread t_rel(release_producer);",
      "    std::thread t_acq(acquire_consumer);",
      "    t_rel.join(); t_acq.join();",
      "",
      "    std::cout << \"\\n--- Acq_Rel Memory Order Example ---\\n\";",
      "    std::vector<std::thread> acq_rel_threads;",
      "    for (int i = 0; i < 10; ++i) {",
      "        acq_rel_threads.emplace_back(acq_rel_worker);",
      "    }",
      "    for (auto& t : acq_rel_threads) {",
      "        t.join();",
      "    }",
      "    std::cout << \"Final counter (acq_rel): \" << counter.load() << \"\\n\";",
      "",
      "    std::cout << \"\\n--- Sequential Consistency Memory Order Example ---\\n\";",
      "    // With seq_cst, (r1=1, r2=0) and (r1=0, r2=1) are possible, but (r1=0, r2=0) is not if both writes happen.",
      "    // (r1=1, r2=1) is also possible.",
      "    // This example demonstrates that seq_cst operations appear to happen in a single global order.",
      "    x.store(0); y.store(0); r1 = 0; r2 = 0;",
      "    std::thread t_wx(write_x);",
      "    std::thread t_wy(write_y);",
      "    std::thread t_rxy(read_xy);",
      "    t_wx.join(); t_wy.join(); t_rxy.join();",
      "    std::cout << \"Seq_cst: r1 = \" << r1 << \", r2 = \" << r2 << \"\\n\";",
      "",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ Concurrency: std::atomic with various memory orders (relaxed, acquire, release, acq_rel, seq_cst)."
  },

  "cpp_concurrency__std_atomic_operations": {
    "prefix": "cpp_concurrency__std_atomic_operations",
    "body": [
      "// C++ Concurrency: Advanced std::atomic Operations",
      "// Beyond simple load/store, std::atomic provides powerful read-modify-write (RMW) operations.",
      "// These operations are atomic and can be combined with memory orders.",
      "// Reference: https://en.cppreference.com/w/cpp/atomic/atomic",
      "#include <iostream>",
      "#include <thread>",
      "#include <atomic>",
      "#include <vector>",
      "",
      "std::atomic<int> value(10);",
      "",
      "void perform_atomic_ops() {",
      "    // 1. exchange(): Atomically replaces the current value with a new value and returns the old value.",
      "    // Useful for implementing locks or passing ownership.",
      "    int old_val = value.exchange(20);",
      "    std::cout << \"Thread \" << std::this_thread::get_id() << \": exchange - old value = \" << old_val << \", new value = \" << value.load() << std::endl;",
      "",
      "    // 2. compare_exchange_strong() / compare_exchange_weak():",
      "    // Atomically compares the current value with an expected value.",
      "    // If they are equal, it replaces the current value with a desired value.",
      "    // Returns true on success, false on failure.",
      "    // compare_exchange_weak can spuriously fail (return false even if values are equal),",
      "    // but might be faster on some platforms (e.g., for loops).",
      "    // compare_exchange_strong is guaranteed not to spuriously fail.",
      "",
      "    int expected = 20; // Value we expect 'value' to currently hold",
      "    int desired = 30;  // Value we want to set 'value' to if 'expected' matches",
      "",
      "    // Example with compare_exchange_strong",
      "    if (value.compare_exchange_strong(expected, desired)) {",
      "        std::cout << \"Thread \" << std::this_thread::get_id() << \": CAS strong successful. Value is now: \" << value.load() << std::endl;",
      "    } else {",
      "        // 'expected' is updated with the actual current value if CAS fails.",
      "        std::cout << \"Thread \" << std::this_thread::get_id() << \": CAS strong failed. Value was: \" << expected << \", still: \" << value.load() << std::endl;",
      "    }",
      "",
      "    // Example with compare_exchange_weak in a loop (common pattern)",
      "    expected = value.load(); // Get current value",
      "    desired = expected + 10;",
      "    while (!value.compare_exchange_weak(expected, desired)) {",
      "        // Loop until successful. 'expected' is updated on failure.",
      "        desired = expected + 10;",
      "    }",
      "    std::cout << \"Thread \" << std::this_thread::get_id() << \": CAS weak loop successful. Value is now: \" << value.load() << std::endl;",
      "",
      "    // 3. fetch_add(), fetch_sub(), fetch_and(), fetch_or(), fetch_xor():",
      "    // Atomically performs an arithmetic/bitwise operation and returns the value *before* the operation.",
      "    // These are RMW operations.",
      "    int old_val_add = value.fetch_add(5); // value = value + 5; returns old value",
      "    std::cout << \"Thread \" << std::this_thread::get_id() << \": fetch_add - old value = \" << old_val_add << \", new value = \" << value.load() << std::endl;",
      "",
      "    int old_val_sub = value.fetch_sub(3); // value = value - 3; returns old value",
      "    std::cout << \"Thread \" << std::this_thread::get_id() << \": fetch_sub - old value = \" << old_val_sub << \", new value = \" << value.load() << std::endl;",
      "",
      "    // Example with fetch_and (e.g., clearing bits)",
      "    value.store(0b1101); // Set value to 13",
      "    int old_val_and = value.fetch_and(0b1010); // value = value & 0b1010 (13 & 10 = 8)",
      "    std::cout << \"Thread \" << std::this_thread::get_id() << \": fetch_and - old value = \" << old_val_and << \" (0b\" << std::oct << old_val_and << \"), new value = \" << value.load() << \" (0b\" << std::oct << value.load() << \")\" << std::endl;",
      "    std::cout << std::dec; // Reset to decimal output",
      "",
      "    // Example with fetch_or (e.g., setting bits)",
      "    value.store(0b0010); // Set value to 2",
      "    int old_val_or = value.fetch_or(0b1100); // value = value | 0b1100 (2 | 12 = 14)",
      "    std::cout << \"Thread \" << std::this_thread::get_id() << \": fetch_or - old value = \" << old_val_or << \" (0b\" << std::oct << old_val_or << \"), new value = \" << value.load() << \" (0b\" << std::oct << value.load() << \")\" << std::endl;",
      "    std::cout << std::dec; // Reset to decimal output",
      "",
      "    // Example with fetch_xor (e.g., toggling bits)",
      "    value.store(0b1010); // Set value to 10",
      "    int old_val_xor = value.fetch_xor(0b1111); // value = value ^ 0b1111 (10 ^ 15 = 5)",
      "    std::cout << \"Thread \" << std::this_thread::get_id() << \": fetch_xor - old value = \" << old_val_xor << \" (0b\" << std::oct << old_val_xor << \"), new value = \" << value.load() << \" (0b\" << std::oct << value.load() << \")\" << std::endl;",
      "    std::cout << std::dec; // Reset to decimal output",
      "}",
      "",
      "int main() {",
      "    std::vector<std::thread> threads;",
      "    for (int i = 0; i < 2; ++i) {",
      "        threads.emplace_back(perform_atomic_ops);",
      "    }",
      "",
      "    for (auto& t : threads) {",
      "        t.join();",
      "    }",
      "",
      "    std::cout << \"\\nAll atomic operations examples finished.\\n\";",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ Concurrency: Advanced std::atomic operations (exchange, compare_exchange_strong/weak, fetch_add/sub/and/or/xor)."
  }
}
