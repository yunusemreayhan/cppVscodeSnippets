{
  "cpp_algorithm__min_max_operations": {
    "prefix": "cpp_algorithm__min_max_operations",
    "body": [
      "// Min/max operations: min, max, minmax, min_element, max_element, minmax_element",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/min",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "// min/max: Compare two values",
      "int a = 5, b = 10;",
      "std::cout << \"Min: \" << std::min(a, b) << std::endl; // 5",
      "std::cout << \"Max: \" << std::max(a, b) << std::endl; // 10",
      "",
      "// min/max with initializer list",
      "int minimum = std::min({3, 1, 4, 1, 5, 9});",
      "int maximum = std::max({3, 1, 4, 1, 5, 9});",
      "",
      "// minmax: Get both at once (C++11)",
      "auto [min_val, max_val] = std::minmax(a, b);",
      "",
      "// min_element/max_element: Find in range",
      "std::vector<int> vec = {3, 1, 4, 1, 5, 9, 2, 6};",
      "",
      "auto min_it = std::min_element(vec.begin(), vec.end());",
      "auto max_it = std::max_element(vec.begin(), vec.end());",
      "std::cout << \"Min element: \" << *min_it << \" at position \"",
      "          << std::distance(vec.begin(), min_it) << std::endl;",
      "std::cout << \"Max element: \" << *max_it << \" at position \"",
      "          << std::distance(vec.begin(), max_it) << std::endl;",
      "",
      "// minmax_element: Get both iterators at once",
      "auto [min_it2, max_it2] = std::minmax_element(vec.begin(), vec.end());",
      "",
      "// Custom comparison",
      "auto abs_compare = [](int a, int b) { return std::abs(a) < std::abs(b); };",
      "std::vector<int> numbers = {-5, 3, -8, 2, -1};",
      "auto min_abs = std::min_element(numbers.begin(), numbers.end(), abs_compare);",
      "$0"
    ],
    "description": "Min/max operations for finding minimum and maximum values. min/max compare two values or initializer lists. minmax returns both at once. min_element/max_element find extremes in ranges. minmax_element finds both extremes in one pass. All support custom comparison functions. Time complexity: O(1) for value comparisons, O(n) for range operations. Link: https://en.cppreference.com/w/cpp/algorithm/min"
  },

  "cpp_algorithm__clamp": {
    "prefix": "cpp_algorithm__clamp",
    "body": [
      "// std::clamp - Constrain value to range (C++17)",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/clamp",
      "#include <algorithm>",
      "#include <iostream>",
      "",
      "// Basic usage",
      "int value = 15;",
      "int clamped = std::clamp(value, 0, 10);",
      "std::cout << \"Clamped value: \" << clamped << std::endl; // 10",
      "",
      "// Clamp to range",
      "int x = -5;",
      "x = std::clamp(x, 0, 100); // x becomes 0",
      "",
      "int y = 150;",
      "y = std::clamp(y, 0, 100); // y becomes 100",
      "",
      "int z = 50;",
      "z = std::clamp(z, 0, 100); // z remains 50",
      "",
      "// With custom comparison",
      "struct Point { int x, y; };",
      "auto point_compare = [](const Point& a, const Point& b) {",
      "    return a.x < b.x;",
      "};",
      "",
      "Point p = {15, 20};",
      "Point min_p = {0, 0};",
      "Point max_p = {10, 10};",
      "Point clamped_p = std::clamp(p, min_p, max_p, point_compare);",
      "",
      "// Practical example: color component",
      "auto clamp_color = [](int color) {",
      "    return std::clamp(color, 0, 255);",
      "};",
      "$0"
    ],
    "description": "Clamps a value between a minimum and maximum. If v < lo, returns lo. If hi < v, returns hi. Otherwise returns v. The behavior is undefined if lo > hi. Supports custom comparison functions. Time complexity: O(1). Link: https://en.cppreference.com/w/cpp/algorithm/clamp"
  },

  "cpp_algorithm__lexicographical_compare": {
    "prefix": "cpp_algorithm__lexicographical_compare",
    "body": [
      "// std::lexicographical_compare - Compare ranges lexicographically",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/lexicographical_compare",
      "#include <algorithm>",
      "#include <vector>",
      "#include <string>",
      "#include <iostream>",
      "",
      "// Compare vectors",
      "std::vector<int> vec1 = {1, 2, 3, 4};",
      "std::vector<int> vec2 = {1, 2, 4, 3};",
      "",
      "bool is_less = std::lexicographical_compare(",
      "    vec1.begin(), vec1.end(),",
      "    vec2.begin(), vec2.end());",
      "std::cout << \"vec1 < vec2: \" << is_less << std::endl; // true",
      "",
      "// Compare strings character by character",
      "std::string str1 = \"apple\";",
      "std::string str2 = \"application\";",
      "",
      "bool str_less = std::lexicographical_compare(",
      "    str1.begin(), str1.end(),",
      "    str2.begin(), str2.end());",
      "// true because \"apple\" < \"application\"",
      "",
      "// Case-insensitive comparison",
      "auto case_insensitive = [](char a, char b) {",
      "    return std::tolower(a) < std::tolower(b);",
      "};",
      "",
      "std::string s1 = \"Apple\";",
      "std::string s2 = \"apple\";",
      "bool case_less = std::lexicographical_compare(",
      "    s1.begin(), s1.end(),",
      "    s2.begin(), s2.end(),",
      "    case_insensitive);",
      "",
      "// Compare arrays of different sizes",
      "int arr1[] = {1, 2, 3};",
      "int arr2[] = {1, 2, 3, 4};",
      "bool arr_less = std::lexicographical_compare(",
      "    std::begin(arr1), std::end(arr1),",
      "    std::begin(arr2), std::end(arr2));",
      "// true because arr1 is prefix of arr2",
      "$0"
    ],
    "description": "Compares two ranges lexicographically (dictionary order). Returns true if the first range is lexicographically less than the second. Comparison stops at first mismatch or when one range ends. Shorter range is considered less if it's a prefix of the longer. Supports custom comparison. Time complexity: O(min(n1,n2)) comparisons. Link: https://en.cppreference.com/w/cpp/algorithm/lexicographical_compare"
  },

  "cpp_algorithm__next_permutation_prev_permutation": {
    "prefix": "cpp_algorithm__next_permutation_prev_permutation",
    "body": [
      "// std::next_permutation, std::prev_permutation - Generate permutations",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/next_permutation",
      "#include <algorithm>",
      "#include <vector>",
      "#include <string>",
      "#include <iostream>",
      "",
      "// Generate all permutations of a vector",
      "std::vector<int> vec = {1, 2, 3};",
      "",
      "// Must start with sorted sequence for all permutations",
      "std::sort(vec.begin(), vec.end());",
      "",
      "do {",
      "    for (int n : vec) std::cout << n << \" \";",
      "    std::cout << \"\\n\";",
      "} while (std::next_permutation(vec.begin(), vec.end()));",
      "// Output: 1 2 3, 1 3 2, 2 1 3, 2 3 1, 3 1 2, 3 2 1",
      "",
      "// Generate permutations of string",
      "std::string str = \"abc\";",
      "do {",
      "    std::cout << str << \" \";",
      "} while (std::next_permutation(str.begin(), str.end()));",
      "// Output: abc acb bac bca cab cba",
      "",
      "// prev_permutation: Generate in reverse order",
      "std::vector<int> vec2 = {3, 2, 1};",
      "do {",
      "    for (int n : vec2) std::cout << n << \" \";",
      "    std::cout << \"\\n\";",
      "} while (std::prev_permutation(vec2.begin(), vec2.end()));",
      "",
      "// Check if more permutations exist",
      "std::vector<int> last_perm = {3, 2, 1};",
      "bool has_next = std::next_permutation(last_perm.begin(), last_perm.end());",
      "// has_next is false, last_perm becomes {1, 2, 3}",
      "",
      "// Custom comparison",
      "std::vector<int> vec3 = {3, 2, 1};",
      "std::next_permutation(vec3.begin(), vec3.end(), std::greater<int>());",
      "$0"
    ],
    "description": "Transforms range into next/previous lexicographically-ordered permutation. next_permutation generates the next greater permutation. prev_permutation generates the next smaller permutation. Returns false if the sequence is already the last/first permutation, wrapping around to first/last. Commonly used to generate all permutations by starting with sorted sequence. Time complexity: O(n/2) on average. Link: https://en.cppreference.com/w/cpp/algorithm/next_permutation"
  },

  "cpp_algorithm__iota": {
    "prefix": "cpp_algorithm__iota",
    "body": [
      "// std::iota - Fill range with sequentially increasing values",
      "// Reference: https://en.cppreference.com/w/cpp/numeric/iota",
      "#include <numeric>",
      "#include <vector>",
      "#include <iostream>",
      "#include <list>",
      "",
      "// Fill with sequential integers starting from 0",
      "std::vector<int> vec(10);",
      "std::iota(vec.begin(), vec.end(), 0);",
      "// vec: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9",
      "",
      "// Fill starting from different value",
      "std::vector<int> vec2(5);",
      "std::iota(vec2.begin(), vec2.end(), 100);",
      "// vec2: 100, 101, 102, 103, 104",
      "",
      "// Works with other types",
      "std::vector<char> chars(26);",
      "std::iota(chars.begin(), chars.end(), 'a');",
      "// chars: a, b, c, d, ..., z",
      "",
      "// Create index array",
      "std::vector<size_t> indices(vec.size());",
      "std::iota(indices.begin(), indices.end(), 0);",
      "// Useful for sorting indices instead of values",
      "",
      "// With custom incrementable type",
      "struct Counter {",
      "    int value;",
      "    Counter& operator++() { value += 2; return *this; }",
      "    operator int() const { return value; }",
      "};",
      "",
      "std::vector<int> even_numbers(5);",
      "Counter c{0};",
      "std::iota(even_numbers.begin(), even_numbers.end(), c);",
      "// even_numbers: 0, 2, 4, 6, 8",
      "$0"
    ],
    "description": "Fills a range with sequentially increasing values, starting with value and repeatedly incrementing it. Each element is assigned the current value, then value is incremented. Works with any type that supports operator++. Commonly used to create sequences of numbers or indices. Time complexity: O(n) increments and assignments. Link: https://en.cppreference.com/w/cpp/numeric/iota"
  },

  "cpp_algorithm__accumulate": {
    "prefix": "cpp_algorithm__accumulate",
    "body": [
      "// std::accumulate - Fold/reduce operation",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/accumulate",
      "#include <numeric>",
      "#include <vector>",
      "#include <string>",
      "#include <iostream>",
      "#include <functional>",
      "",
      "std::vector<int> vec = {1, 2, 3, 4, 5};",
      "",
      "// Sum all elements",
      "int sum = std::accumulate(vec.begin(), vec.end(), 0);",
      "std::cout << \"Sum: \" << sum << std::endl; // 15",
      "",
      "// Product of all elements",
      "int product = std::accumulate(vec.begin(), vec.end(), 1,",
      "                             std::multiplies<int>());",
      "std::cout << \"Product: \" << product << std::endl; // 120",
      "",
      "// String concatenation",
      "std::vector<std::string> words = {\"Hello\", \" \", \"World\", \"!\"};",
      "std::string sentence = std::accumulate(words.begin(), words.end(),",
      "                                      std::string(\"\"));",
      "// sentence: \"Hello World!\"",
      "",
      "// Custom operation - find max",
      "int max_val = std::accumulate(vec.begin(), vec.end(), vec[0],",
      "                             [](int a, int b) { return std::max(a, b); });",
      "",
      "// Calculate average",
      "double average = std::accumulate(vec.begin(), vec.end(), 0.0) / vec.size();",
      "",
      "// Accumulate with different type",
      "std::vector<int> lengths = {3, 5, 2, 8, 1};",
      "std::string repeated = std::accumulate(lengths.begin(), lengths.end(),",
      "                                      std::string(\"\"),",
      "                                      [](std::string s, int n) { return s + std::string(n, '*'); });",
      "// repeated: \"********\" (if lengths = {3, 5})",
      "$0"
    ],
    "description": "Calculates the sum of a range of values, or applies a custom binary operation. It takes an initial value and iterates through the range, applying the operation to the current accumulated value and each element. Supports custom binary operations. Time complexity: O(n) applications of the binary operation. Link: https://en.cppreference.com/w/cpp/algorithm/accumulate"
  }
}
