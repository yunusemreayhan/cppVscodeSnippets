{
  "cpp_stl__vector_basic_usage": {
    "prefix": "cpp_stl__vector_basic_usage",
    "body": [
      "// C++ STL: std::vector - Dynamic Array",
      "// std::vector is a sequence container that encapsulates dynamic size arrays.",
      "// It provides dynamic resizing and efficient random access to elements.",
      "#include <iostream>",
      "#include <vector>",
      "#include <string>",
      "#include <algorithm>",
      "",
      "int main() {",
      "    // 1. Declaration and Initialization",
      "    std::vector<int> vec1; // Empty vector of integers",
      "    std::vector<int> vec2(5); // Vector with 5 default-constructed elements (0 for int)",
      "    std::vector<int> vec3(5, 10); // Vector with 5 elements, all initialized to 10",
      "    std::vector<int> vec4 = {1, 2, 3, 4, 5}; // Initializer list initialization",
      "",
      "    std::cout << \"vec4 elements: \";",
      "    for (int x : vec4) {",
      "        std::cout << x << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 2. Adding elements",
      "    vec1.push_back(10); // Add element to the end",
      "    vec1.push_back(20);",
      "    vec1.push_back(30);",
      "    std::cout << \"vec1 after push_back: \";",
      "    for (int x : vec1) {",
      "        std::cout << x << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 3. Accessing elements",
      "    std::cout << \"First element of vec1: \" << vec1[0] << std::endl; // No bounds checking",
      "    std::cout << \"Second element of vec1: \" << vec1.at(1) << std::endl; // With bounds checking",
      "    std::cout << \"Last element of vec1: \" << vec1.back() << std::endl;",
      "    std::cout << \"First element of vec1: \" << vec1.front() << std::endl;",
      "",
      "    // 4. Size and Capacity",
      "    std::cout << \"vec1 size: \" << vec1.size() << std::endl; // Number of elements",
      "    std::cout << \"vec1 capacity: \" << vec1.capacity() << std::endl; // Allocated storage",
      "    vec1.reserve(10); // Request a capacity change",
      "    std::cout << \"vec1 capacity after reserve(10): \" << vec1.capacity() << std::endl;",
      "    vec1.shrink_to_fit(); // Reduce capacity to fit size",
      "    std::cout << \"vec1 capacity after shrink_to_fit: \" << vec1.capacity() << std::endl;",
      "",
      "    // 5. Iterators",
      "    std::cout << \"vec4 elements using iterators: \";",
      "    for (auto it = vec4.begin(); it != vec4.end(); ++it) {",
      "        std::cout << *it << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 6. Modifying elements",
      "    vec4[0] = 100;",
      "    std::cout << \"vec4 after modifying first element: \";",
      "    for (int x : vec4) {",
      "        std::cout << x << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 7. Inserting and Erasing elements",
      "    vec4.insert(vec4.begin() + 2, 99); // Insert 99 at index 2",
      "    std::cout << \"vec4 after insert: \";",
      "    for (int x : vec4) {",
      "        std::cout << x << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    vec4.erase(vec4.begin() + 2); // Erase element at index 2",
      "    std::cout << \"vec4 after erase: \";",
      "    for (int x : vec4) {",
      "        std::cout << x << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 8. Clearing the vector",
      "    vec1.clear();",
      "    std::cout << \"vec1 size after clear: \" << vec1.size() << std::endl;",
      "    std::cout << \"vec1 is empty: \" << (vec1.empty() ? \"Yes\" : \"No\") << std::endl;",
      "",
      "    // 9. Resizing",
      "    vec2.resize(7, 50); // Resize to 7 elements, new elements initialized to 50",
      "    std::cout << \"vec2 after resize: \";",
      "    for (int x : vec2) {",
      "        std::cout << x << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 10. Swapping vectors",
      "    std::vector<int> v_a = {1, 2, 3};",
      "    std::vector<int> v_b = {4, 5, 6};",
      "    std::cout << \"Before swap: v_a[0] = \" << v_a[0] << \", v_b[0] = \" << v_b[0] << std::endl;",
      "    v_a.swap(v_b);",
      "    std::cout << \"After swap: v_a[0] = \" << v_a[0] << \", v_b[0] = \" << v_b[0] << std::endl;",
      "",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ STL: Basic usage and common methods for std::vector."
  },
  "cpp_stl__list_basic_usage": {
    "prefix": "cpp_stl__list_basic_usage",
    "body": [
      "// C++ STL: std::list - Doubly Linked List",
      "// std::list is a sequence container that allows constant time insertion and deletion anywhere in the sequence.",
      "// It does not provide direct random access to elements.",
      "#include <iostream>",
      "#include <list>",
      "#include <string>",
      "#include <algorithm>",
      "",
      "int main() {",
      "    // 1. Declaration and Initialization",
      "    std::list<int> list1; // Empty list of integers",
      "    std::list<int> list2 = {10, 20, 30, 40, 50}; // Initializer list initialization",
      "",
      "    std::cout << \"list2 elements: \";",
      "    for (int x : list2) {",
      "        std::cout << x << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 2. Adding elements",
      "    list1.push_back(100); // Add element to the end",
      "    list1.push_front(50); // Add element to the beginning",
      "    list1.push_back(150);",
      "    std::cout << \"list1 after push_back/front: \";",
      "    for (int x : list1) {",
      "        std::cout << x << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 3. Accessing elements (no direct random access like vector)",
      "    // To access an element, you typically iterate or use iterators.",
      "    std::cout << \"First element of list1: \" << list1.front() << std::endl;",
      "    std::cout << \"Last element of list1: \" << list1.back() << std::endl;",
      "",
      "    // 4. Size",
      "    std::cout << \"list1 size: \" << list1.size() << std::endl;",
      "    std::cout << \"list1 is empty: \" << (list1.empty() ? \"Yes\" : \"No\") << std::endl;",
      "",
      "    // 5. Iterators",
      "    std::cout << \"list2 elements using iterators: \";",
      "    for (auto it = list2.begin(); it != list2.end(); ++it) {",
      "        std::cout << *it << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 6. Inserting elements",
      "    auto it = list2.begin();",
      "    std::advance(it, 2); // Move iterator to the 3rd element (index 2)",
      "    list2.insert(it, 99); // Insert 99 before the 3rd element",
      "    std::cout << \"list2 after insert: \";",
      "    for (int x : list2) {",
      "        std::cout << x << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 7. Erasing elements",
      "    list2.erase(it); // Erase the element at the iterator's position (which is now 99)",
      "    std::cout << \"list2 after erase: \";",
      "    for (int x : list2) {",
      "        std::cout << x << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    list2.remove(40); // Remove all occurrences of value 40",
      "    std::cout << \"list2 after remove(40): \";",
      "    for (int x : list2) {",
      "        std::cout << x << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 8. Clearing the list",
      "    list1.clear();",
      "    std::cout << \"list1 size after clear: \" << list1.size() << std::endl;",
      "",
      "    // 9. Splicing lists (transfer elements from one list to another)",
      "    std::list<int> list_a = {1, 2, 3};",
      "    std::list<int> list_b = {4, 5, 6};",
      "    list_a.splice(list_a.end(), list_b); // Move all elements from list_b to end of list_a",
      "    std::cout << \"list_a after splice: \";",
      "    for (int x : list_a) {",
      "        std::cout << x << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "    std::cout << \"list_b size after splice: \" << list_b.size() << std::endl;",
      "",
      "    // 10. Sorting and Unique",
      "    std::list<int> list_sort = {5, 2, 8, 2, 1, 5};",
      "    list_sort.sort();",
      "    std::cout << \"list_sort after sort: \";",
      "    for (int x : list_sort) {",
      "        std::cout << x << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "    list_sort.unique(); // Remove consecutive duplicate elements",
      "    std::cout << \"list_sort after unique: \";",
      "    for (int x : list_sort) {",
      "        std::cout << x << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ STL: Basic usage and common methods for std::list (doubly linked list)."
  },
  "cpp_stl__map_basic_usage": {
    "prefix": "cpp_stl__map_basic_usage",
    "body": [
      "// C++ STL: std::map - Sorted Associative Container",
      "// std::map is an associative container that stores elements formed by a combination of a key value and a mapped value,",
      "// following a specific order. Keys are unique and sorted.",
      "#include <iostream>",
      "#include <map>",
      "#include <string>",
      "",
      "int main() {",
      "    // 1. Declaration and Initialization",
      "    std::map<std::string, int> ages; // Map with string keys and int values",
      "    std::map<int, std::string> students = {",
      "        {101, \"Alice\"},",
      "        {102, \"Bob\"},",
      "        {103, \"Charlie\"}",
      "    };",
      "",
      "    std::cout << \"Students map:\" << std::endl;",
      "    for (const auto& pair : students) {",
      "        std::cout << pair.first << \": \" << pair.second << std::endl;",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 2. Inserting elements",
      "    ages[\"Alice\"] = 30; // Using array-like syntax (inserts if key doesn't exist, updates if it does)",
      "    ages[\"Bob\"] = 25;",
      "    ages.insert({\"Charlie\", 35}); // Using insert with initializer list",
      "    ages.insert(std::make_pair(\"David\", 40)); // Using insert with std::make_pair",
      "",
      "    std::cout << \"Ages map after insertions:\" << std::endl;",
      "    for (const auto& pair : ages) {",
      "        std::cout << pair.first << \": \" << pair.second << std::endl;",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 3. Accessing elements",
      "    std::cout << \"Alice's age: \" << ages[\"Alice\"] << std::endl; // Access using key (inserts if not found)",
      "    try {",
      "        std::cout << \"Bob's age: \" << ages.at(\"Bob\") << std::endl; // Access using at() (throws if not found)",
      "        // std::cout << \"Eve's age: \" << ages.at(\"Eve\") << std::endl; // This would throw std::out_of_range",
      "    } catch (const std::out_of_range& oor) {",
      "        std::cerr << \"Error: \" << oor.what() << std::endl;",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 4. Checking if a key exists (find and count)",
      "    if (ages.count(\"Charlie\")) { // count() returns 1 if key exists, 0 otherwise for std::map",
      "        std::cout << \"Charlie exists in ages map.\" << std::endl;",
      "    }",
      "    if (ages.find(\"David\") != ages.end()) {",
      "        std::cout << \"David exists in ages map.\" << std::endl;",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 5. Iterating through a map (elements are sorted by key)",
      "    std::cout << \"Iterating through ages map (sorted by key):\" << std::endl;",
      "    for (auto it = ages.begin(); it != ages.end(); ++it) {",
      "        std::cout << it->first << \" => \" << it->second << std::endl;",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 6. Erasing elements",
      "    ages.erase(\"Bob\"); // Erase by key",
      "    std::cout << \"Ages map after erasing Bob:\" << std::endl;",
      "    for (const auto& pair : ages) {",
      "        std::cout << pair.first << \": \" << pair.second << std::endl;",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    auto it_erase = ages.find(\"Charlie\");",
      "    if (it_erase != ages.end()) {",
      "        ages.erase(it_erase); // Erase by iterator",
      "    }",
      "    std::cout << \"Ages map after erasing Charlie:\" << std::endl;",
      "    for (const auto& pair : ages) {",
      "        std::cout << pair.first << \": \" << pair.second << std::endl;",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 7. Size and Empty",
      "    std::cout << \"Ages map size: \" << ages.size() << std::endl;",
      "    std::cout << \"Ages map is empty: \" << (ages.empty() ? \"Yes\" : \"No\") << std::endl;",
      "",
      "    // 8. Clearing the map",
      "    ages.clear();",
      "    std::cout << \"Ages map size after clear: \" << ages.size() << std::endl;",
      "",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ STL: Basic usage and common methods for std::map (sorted associative container)."
  },
  "cpp_stl__set_basic_usage": {
    "prefix": "cpp_stl__set_basic_usage",
    "body": [
      "// C++ STL: std::set - Sorted Unique Elements Container",
      "// std::set is an associative container that stores unique elements in a specific sorted order.",
      "// Elements are stored as keys, and no mapped value is associated.",
      "#include <iostream>",
      "#include <set>",
      "#include <string>",
      "#include <algorithm>",
      "",
      "int main() {",
      "    // 1. Declaration and Initialization",
      "    std::set<int> s1; // Empty set of integers",
      "    std::set<std::string> s2 = {\"apple\", \"banana\", \"cherry\", \"apple\"}; // Initializer list (duplicates ignored)",
      "",
      "    std::cout << \"s2 elements (sorted and unique): \";",
      "    for (const std::string& fruit : s2) {",
      "        std::cout << fruit << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 2. Inserting elements",
      "    s1.insert(10);",
      "    s1.insert(5);",
      "    s1.insert(20);",
      "    s1.insert(5); // Duplicate, will be ignored",
      "",
      "    std::cout << \"s1 elements (sorted): \";",
      "    for (int x : s1) {",
      "        std::cout << x << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 3. Checking if an element exists (find and count)",
      "    if (s1.count(10)) { // count() returns 1 if element exists, 0 otherwise for std::set",
      "        std::cout << \"10 exists in s1.\" << std::endl;",
      "    }",
      "    if (s1.find(15) == s1.end()) {",
      "        std::cout << \"15 does not exist in s1.\" << std::endl;",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 4. Iterating through a set (elements are sorted)",
      "    std::cout << \"Iterating through s2 (sorted):\" << std::endl;",
      "    for (auto it = s2.begin(); it != s2.end(); ++it) {",
      "        std::cout << *it << std::endl;",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 5. Erasing elements",
      "    s1.erase(5); // Erase by value",
      "    std::cout << \"s1 after erasing 5: \";",
      "    for (int x : s1) {",
      "        std::cout << x << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    auto it_erase = s1.find(20);",
      "    if (it_erase != s1.end()) {",
      "        s1.erase(it_erase); // Erase by iterator",
      "    }",
      "    std::cout << \"s1 after erasing 20: \";",
      "    for (int x : s1) {",
      "        std::cout << x << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 6. Size and Empty",
      "    std::cout << \"s1 size: \" << s1.size() << std::endl;",
      "    std::cout << \"s1 is empty: \" << (s1.empty() ? \"Yes\" : \"No\") << std::endl;",
      "",
      "    // 7. Clearing the set",
      "    s2.clear();",
      "    std::cout << \"s2 size after clear: \" << s2.size() << std::endl;",
      "",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ STL: Basic usage and common methods for std::set (sorted unique elements container)."
  },
  "cpp_stl__queue_basic_usage": {
    "prefix": "cpp_stl__queue_basic_usage",
    "body": [
      "// C++ STL: std::queue - FIFO Adapter Container",
      "// std::queue is a container adapter that provides a FIFO (first-in, first-out) data structure.",
      "// It is implemented on top of other standard containers (like std::deque or std::list).",
      "#include <iostream>",
      "#include <queue>",
      "#include <string>",
      "",
      "int main() {",
      "    // 1. Declaration and Initialization",
      "    std::queue<int> q1; // Empty queue of integers",
      "    std::queue<std::string> q2;",
      "",
      "    // 2. Adding elements (enqueue)",
      "    q1.push(10);",
      "    q1.push(20);",
      "    q1.push(30);",
      "",
      "    std::cout << \"Elements pushed to q1: 10, 20, 30\" << std::endl;",
      "",
      "    // 3. Accessing the front element",
      "    std::cout << \"Front element of q1: \" << q1.front() << std::endl;",
      "",
      "    // 4. Removing elements (dequeue)",
      "    q1.pop(); // Removes 10",
      "    std::cout << \"Front element of q1 after pop: \" << q1.front() << std::endl;",
      "",
      "    // 5. Size and Empty",
      "    std::cout << \"q1 size: \" << q1.size() << std::endl;",
      "    std::cout << \"q1 is empty: \" << (q1.empty() ? \"Yes\" : \"No\") << std::endl;",
      "",
      "    // 6. Iterating (not directly supported, must dequeue to see elements)",
      "    std::cout << \"Elements in q1 (dequeuing): \";",
      "    while (!q1.empty()) {",
      "        std::cout << q1.front() << \" \";",
      "        q1.pop();",
      "    }",
      "    std::cout << std::endl;",
      "    std::cout << \"q1 size after dequeuing: \" << q1.size() << std::endl;",
      "",
      "    // 7. Using with custom underlying container (e.g., std::list)",
      "    std::queue<double, std::list<double>> q_list;",
      "    q_list.push(1.1);",
      "    q_list.push(2.2);",
      "    std::cout << \"Front of q_list: \" << q_list.front() << std::endl;",
      "",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ STL: Basic usage and common methods for std::queue (FIFO adapter container)."
  },
  "cpp_stl__stack_basic_usage": {
    "prefix": "cpp_stl__stack_basic_usage",
    "body": [
      "// C++ STL: std::stack - LIFO Adapter Container",
      "// std::stack is a container adapter that provides a LIFO (last-in, first-out) data structure.",
      "// It is implemented on top of other standard containers (like std::deque or std::list).",
      "#include <iostream>",
      "#include <stack>",
      "#include <string>",
      "",
      "int main() {",
      "    // 1. Declaration and Initialization",
      "    std::stack<int> s1; // Empty stack of integers",
      "    std::stack<std::string> s2;",
      "",
      "    // 2. Adding elements (push)",
      "    s1.push(10);",
      "    s1.push(20);",
      "    s1.push(30);",
      "",
      "    std::cout << \"Elements pushed to s1: 10, 20, 30\" << std::endl;",
      "",
      "    // 3. Accessing the top element",
      "    std::cout << \"Top element of s1: \" << s1.top() << std::endl;",
      "",
      "    // 4. Removing elements (pop)",
      "    s1.pop(); // Removes 30",
      "    std::cout << \"Top element of s1 after pop: \" << s1.top() << std::endl;",
      "",
      "    // 5. Size and Empty",
      "    std::cout << \"s1 size: \" << s1.size() << std::endl;",
      "    std::cout << \"s1 is empty: \" << (s1.empty() ? \"Yes\" : \"No\") << std::endl;",
      "",
      "    // 6. Iterating (not directly supported, must pop to see elements)",
      "    std::cout << \"Elements in s1 (popping): \";",
      "    while (!s1.empty()) {",
      "        std::cout << s1.top() << \" \";",
      "        s1.pop();",
      "    }",
      "    std::cout << std::endl;",
      "    std::cout << \"s1 size after popping: \" << s1.size() << std::endl;",
      "",
      "    // 7. Using with custom underlying container (e.g., std::vector)",
      "    std::stack<double, std::vector<double>> s_vec;",
      "    s_vec.push(1.1);",
      "    s_vec.push(2.2);",
      "    std::cout << \"Top of s_vec: \" << s_vec.top() << std::endl;",
      "",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ STL: Basic usage and common methods for std::stack (LIFO adapter container)."
  },
  "cpp_stl__unordered_map_basic_usage": {
    "prefix": "cpp_stl__unordered_map_basic_usage",
    "body": [
      "// C++ STL: std::unordered_map - Unordered Associative Container",
      "// std::unordered_map is an associative container that stores elements formed by a combination of a key value and a mapped value,",
      "// but unlike std::map, it does not maintain any particular order of elements.",
      "// Elements are organized into buckets based on hash values to allow for fast individual element access.",
      "#include <iostream>",
      "#include <unordered_map>",
      "#include <string>",
      "",
      "int main() {",
      "    // 1. Declaration and Initialization",
      "    std::unordered_map<std::string, int> ages; // Unordered map with string keys and int values",
      "    std::unordered_map<int, std::string> students = {",
      "        {101, \"Alice\"},",
      "        {102, \"Bob\"},",
      "        {103, \"Charlie\"}",
      "    };",
      "",
      "    std::cout << \"Students unordered_map (order not guaranteed):\" << std::endl;",
      "    for (const auto& pair : students) {",
      "        std::cout << pair.first << \": \" << pair.second << std::endl;",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 2. Inserting elements",
      "    ages[\"Alice\"] = 30; // Using array-like syntax (inserts if key doesn't exist, updates if it does)",
      "    ages[\"Bob\"] = 25;",
      "    ages.insert({\"Charlie\", 35}); // Using insert with initializer list",
      "    ages.insert(std::make_pair(\"David\", 40)); // Using insert with std::make_pair",
      "",
      "    std::cout << \"Ages unordered_map after insertions (order not guaranteed):\" << std::endl;",
      "    for (const auto& pair : ages) {",
      "        std::cout << pair.first << \": \" << pair.second << std::endl;",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 3. Accessing elements",
      "    std::cout << \"Alice's age: \" << ages[\"Alice\"] << std::endl; // Access using key (inserts if not found)",
      "    try {",
      "        std::cout << \"Bob's age: \" << ages.at(\"Bob\") << std::endl; // Access using at() (throws if not found)",
      "        // std::cout << \"Eve's age: \" << ages.at(\"Eve\") << std::endl; // This would throw std::out_of_range",
      "    } catch (const std::out_of_range& oor) {",
      "        std::cerr << \"Error: \" << oor.what() << std::endl;",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 4. Checking if a key exists (find and count)",
      "    if (ages.count(\"Charlie\")) { // count() returns 1 if key exists, 0 otherwise for std::unordered_map",
      "        std::cout << \"Charlie exists in ages unordered_map.\" << std::endl;",
      "    }",
      "    if (ages.find(\"David\") != ages.end()) {",
      "        std::cout << \"David exists in ages unordered_map.\" << std::endl;",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 5. Erasing elements",
      "    ages.erase(\"Bob\"); // Erase by key",
      "    std::cout << \"Ages unordered_map after erasing Bob:\" << std::endl;",
      "    for (const auto& pair : ages) {",
      "        std::cout << pair.first << \": \" << pair.second << std::endl;",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    auto it_erase = ages.find(\"Charlie\");",
      "    if (it_erase != ages.end()) {",
      "        ages.erase(it_erase); // Erase by iterator",
      "    }",
      "    std::cout << \"Ages unordered_map after erasing Charlie:\" << std::endl;",
      "    for (const auto& pair : ages) {",
      "        std::cout << pair.first << \": \" << pair.second << std::endl;",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 6. Size and Empty",
      "    std::cout << \"Ages unordered_map size: \" << ages.size() << std::endl;",
      "    std::cout << \"Ages unordered_map is empty: \" << (ages.empty() ? \"Yes\" : \"No\") << std::endl;",
      "",
      "    // 7. Clearing the unordered_map",
      "    ages.clear();",
      "    std::cout << \"Ages unordered_map size after clear: \" << ages.size() << std::endl;",
      "",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ STL: Basic usage and common methods for std::unordered_map (unordered associative container)."
  },
  "cpp_stl__unordered_set_basic_usage": {
    "prefix": "cpp_stl__unordered_set_basic_usage",
    "body": [
      "// C++ STL: std::unordered_set - Unordered Unique Elements Container",
      "// std::unordered_set is an associative container that stores unique elements in no particular order.",
      "// Elements are organized into buckets based on hash values to allow for fast individual element access.",
      "#include <iostream>",
      "#include <unordered_set>",
      "#include <string>",
      "",
      "int main() {",
      "    // 1. Declaration and Initialization",
      "    std::unordered_set<int> us1; // Empty unordered_set of integers",
      "    std::unordered_set<std::string> us2 = {\"apple\", \"banana\", \"cherry\", \"apple\"}; // Initializer list (duplicates ignored)",
      "",
      "    std::cout << \"us2 elements (order not guaranteed): \";",
      "    for (const std::string& fruit : us2) {",
      "        std::cout << fruit << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 2. Inserting elements",
      "    us1.insert(10);",
      "    us1.insert(5);",
      "    us1.insert(20);",
      "    us1.insert(5); // Duplicate, will be ignored",
      "",
      "    std::cout << \"us1 elements (order not guaranteed): \";",
      "    for (int x : us1) {",
      "        std::cout << x << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 3. Checking if an element exists (find and count)",
      "    if (us1.count(10)) { // count() returns 1 if element exists, 0 otherwise for std::unordered_set",
      "        std::cout << \"10 exists in us1.\" << std::endl;",
      "    }",
      "    if (us1.find(15) == us1.end()) {",
      "        std::cout << \"15 does not exist in us1.\" << std::endl;",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 4. Erasing elements",
      "    us1.erase(5); // Erase by value",
      "    std::cout << \"us1 after erasing 5: \";",
      "    for (int x : us1) {",
      "        std::cout << x << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    auto it_erase = us1.find(20);",
      "    if (it_erase != us1.end()) {",
      "        us1.erase(it_erase); // Erase by iterator",
      "    }",
      "    std::cout << \"us1 after erasing 20: \";",
      "    for (int x : us1) {",
      "        std::cout << x << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    // 5. Size and Empty",
      "    std::cout << \"us1 size: \" << us1.size() << std::endl;",
      "    std::cout << \"us1 is empty: \" << (us1.empty() ? \"Yes\" : \"No\") << std::endl;",
      "",
      "    // 6. Clearing the unordered_set",
      "    us2.clear();",
      "    std::cout << \"us2 size after clear: \" << us2.size() << std::endl;",
      "",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ STL: Basic usage and common methods for std::unordered_set (unordered unique elements container)."
  },
  "cpp_stl__priority_queue_basic_usage": {
    "prefix": "cpp_stl__priority_queue_basic_usage",
    "body": [
      "// C++ STL: std::priority_queue - Priority Queue Adapter Container",
      "// std::priority_queue is a container adapter that provides a max-heap by default,",
      "// meaning the largest element is always at the top. It is implemented on top of other standard containers (like std::vector).",
      "#include <iostream>",
      "#include <queue>",
      "#include <vector>",
      "#include <functional>",
      "",
      "int main() {",
      "    // 1. Declaration and Initialization (Max-Heap by default)",
      "    std::priority_queue<int> pq1; // Max-heap of integers",
      "",
      "    // 2. Adding elements (push)",
      "    pq1.push(10);",
      "    pq1.push(30);",
      "    pq1.push(20);",
      "    pq1.push(5);",
      "    pq1.push(15);",
      "",
      "    std::cout << \"Elements pushed to pq1: 10, 30, 20, 5, 15\" << std::endl;",
      "",
      "    // 3. Accessing the top element (largest element)",
      "    std::cout << \"Top element of pq1: \" << pq1.top() << std::endl; // Should be 30",
      "",
      "    // 4. Removing elements (pop)",
      "    pq1.pop(); // Removes 30",
      "    std::cout << \"Top element of pq1 after first pop: \" << pq1.top() << std::endl; // Should be 20",
      "",
      "    // 5. Size and Empty",
      "    std::cout << \"pq1 size: \" << pq1.size() << std::endl;",
      "    std::cout << \"pq1 is empty: \" << (pq1.empty() ? \"Yes\" : \"No\") << std::endl;",
      "",
      "    // 6. Iterating (not directly supported, must pop to see elements in order)",
      "    std::cout << \"Elements in pq1 (popping in priority order): \";",
      "    while (!pq1.empty()) {",
      "        std::cout << pq1.top() << \" \";",
      "        pq1.pop();",
      "    }",
      "    std::cout << std::endl;",
      "    std::cout << \"pq1 size after popping: \" << pq1.size() << std::endl;",
      "",
      "    // 7. Min-Heap (using std::greater)",
      "    std::priority_queue<int, std::vector<int>, std::greater<int>> min_pq;",
      "    min_pq.push(10);",
      "    min_pq.push(30);",
      "    min_pq.push(20);",
      "    min_pq.push(5);",
      "    min_pq.push(15);",
      "",
      "    std::cout << \"\\nMin-heap elements (popping in priority order): \";",
      "    while (!min_pq.empty()) {",
      "        std::cout << min_pq.top() << \" \";",
      "        min_pq.pop();",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ STL: Basic usage and common methods for std::priority_queue (priority queue adapter container)."
  }
}
