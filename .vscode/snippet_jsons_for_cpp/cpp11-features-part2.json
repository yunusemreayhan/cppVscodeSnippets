{
  "cpp_11__perfect_forwarding": {
    "prefix": "cpp_11__perfect_forwarding",
    "body": [
      "// C++11: Perfect forwarding with universal references",
      "#include <utility>",
      "#include <iostream>",
      "",
      "// Function to be called",
      "void process(int& x) { std::cout << \"lvalue: \" << x << std::endl; }",
      "void process(int&& x) { std::cout << \"rvalue: \" << x << std::endl; }",
      "",
      "// Perfect forwarding function",
      "template<typename T>",
      "void forward_to_process(T&& arg) {",
      "    process(std::forward<T>(arg));",
      "}",
      "",
      "// Variadic perfect forwarding",
      "template<typename... Args>",
      "void emplace_wrapper(std::vector<MyClass>& vec, Args&&... args) {",
      "    vec.emplace_back(std::forward<Args>(args)...);",
      "}",
      "",
      "// Usage",
      "int x = 5;",
      "forward_to_process(x);    // calls process(int&)",
      "forward_to_process(10);   // calls process(int&&)",
      "forward_to_process(std::move(x)); // calls process(int&&)",
      "$0"
    ],
    "description": "C++11 perfect forwarding with universal references"
  },

  "cpp_11__constexpr": {
    "prefix": "cpp_11__constexpr",
    "body": [
      "// C++11: constexpr for compile-time computation",
      "",
      "// constexpr function (C++11 limited to single return)",
      "constexpr int factorial(int n) {",
      "    return n <= 1 ? 1 : n * factorial(n - 1);",
      "}",
      "",
      "// constexpr variable",
      "constexpr int fact5 = factorial(5); // Computed at compile time",
      "",
      "// constexpr constructor and member functions",
      "class Point {",
      "    int x, y;",
      "public:",
      "    constexpr Point(int x, int y) : x(x), y(y) {}",
      "    constexpr int getX() const { return x; }",
      "    constexpr int getY() const { return y; }",
      "    constexpr Point translate(int dx, int dy) const {",
      "        return Point(x + dx, y + dy);",
      "    }",
      "};",
      "",
      "constexpr Point p1(10, 20);",
      "constexpr Point p2 = p1.translate(5, 5);",
      "constexpr int px = p2.getX(); // 15 at compile-time",
      "",
      "// Use in template parameter",
      "template<int N>",
      "struct Array {",
      "    int data[N];",
      "};",
      "Array<factorial(5)> arr; // Array<120>",
      "$0"
    ],
    "description": "C++11 constexpr for compile-time computation"
  },

  "cpp_11__nullptr": {
    "prefix": "cpp_11__nullptr",
    "body": [
      "// C++11: nullptr - type-safe null pointer",
      "",
      "// Old way (C++98/03)",
      "int* p1 = NULL;  // NULL is typically defined as 0",
      "int* p2 = 0;     // Can be ambiguous",
      "",
      "// New way (C++11)",
      "int* p3 = nullptr;  // Type-safe, unambiguous",
      "",
      "// Function overloading example",
      "void f(int) { std::cout << \"f(int)\\n\"; }",
      "void f(int*) { std::cout << \"f(int*)\\n\"; }",
      "void f(std::nullptr_t) { std::cout << \"f(nullptr)\\n\"; }",
      "",
      "f(0);       // Calls f(int) - ambiguous!",
      "f(nullptr); // Calls f(std::nullptr_t) or f(int*) - clear intent",
      "",
      "// Template with nullptr",
      "template<typename T>",
      "void reset(T*& ptr) {",
      "    delete ptr;",
      "    ptr = nullptr;",
      "}",
      "$0"
    ],
    "description": "C++11 nullptr for type-safe null pointers"
  },

  "cpp_11__default_delete_functions": {
    "prefix": "cpp_11__default_delete_functions",
    "body": [
      "// C++11: Default and deleted functions",
      "",
      "class Widget {",
      "public:",
      "    // Explicitly defaulted functions",
      "    Widget() = default;                          // Default constructor",
      "    Widget(const Widget&) = default;             // Copy constructor",
      "    Widget& operator=(const Widget&) = default;  // Copy assignment",
      "    Widget(Widget&&) = default;                  // Move constructor",
      "    Widget& operator=(Widget&&) = default;       // Move assignment",
      "    ~Widget() = default;                         // Destructor",
      "",
      "    // Custom constructor",
      "    Widget(int value) : value_(value) {}",
      "",
      "private:",
      "    int value_ = 0;",
      "};",
      "",
      "class NonCopyable {",
      "public:",
      "    NonCopyable() = default;",
      "    ",
      "    // Delete copy operations",
      "    NonCopyable(const NonCopyable&) = delete;",
      "    NonCopyable& operator=(const NonCopyable&) = delete;",
      "    ",
      "    // Allow move operations",
      "    NonCopyable(NonCopyable&&) = default;",
      "    NonCopyable& operator=(NonCopyable&&) = default;",
      "};",
      "",
      "// Delete specific function overloads",
      "void processValue(int x) { /* ... */ }",
      "void processValue(double) = delete; // Prevent implicit conversion",
      "$0"
    ],
    "description": "C++11 explicitly defaulted and deleted functions"
  },

  "cpp_11__override_final": {
    "prefix": "cpp_11__override_final",
    "body": [
      "// C++11: override and final keywords",
      "",
      "class Base {",
      "public:",
      "    virtual void foo() { std::cout << \"Base::foo\\n\"; }",
      "    virtual void bar() { std::cout << \"Base::bar\\n\"; }",
      "    virtual void baz() final { std::cout << \"Base::baz (final)\\n\"; }",
      "};",
      "",
      "class Derived : public Base {",
      "public:",
      "    // override ensures we're actually overriding",
      "    void foo() override { std::cout << \"Derived::foo\\n\"; }",
      "    ",
      "    // void fooo() override; // Error! No base function to override",
      "    // void baz() override;  // Error! Cannot override final",
      "};",
      "",
      "// final class cannot be inherited",
      "class FinalClass final {",
      "    // ...",
      "};",
      "",
      "// class CannotDerive : public FinalClass {}; // Error!",
      "$0"
    ],
    "description": "C++11 override and final keywords for virtual functions"
  },

  "cpp_11__delegating_constructors": {
    "prefix": "cpp_11__delegating_constructors",
    "body": [
      "// C++11: Delegating constructors",
      "",
      "class Rectangle {",
      "private:",
      "    double width, height;",
      "    std::string name;",
      "",
      "public:",
      "    // Main constructor",
      "    Rectangle(double w, double h, const std::string& n)",
      "        : width(w), height(h), name(n) {",
      "        std::cout << \"Main constructor\\n\";",
      "    }",
      "    ",
      "    // Delegating constructors",
      "    Rectangle(double w, double h) : Rectangle(w, h, \"unnamed\") {",
      "        std::cout << \"Delegating constructor 1\\n\";",
      "    }",
      "    ",
      "    Rectangle(double size) : Rectangle(size, size) {",
      "        std::cout << \"Delegating constructor 2 (square)\\n\";",
      "    }",
      "    ",
      "    Rectangle() : Rectangle(1.0) {",
      "        std::cout << \"Default constructor\\n\";",
      "    }",
      "};",
      "",
      "// Usage",
      "Rectangle r1(3.0, 4.0, \"rect1\");",
      "Rectangle r2(3.0, 4.0);  // delegates to main constructor",
      "Rectangle r3(5.0);       // creates a square",
      "Rectangle r4;            // default 1x1 square",
      "$0"
    ],
    "description": "C++11 delegating constructors"
  },

  "cpp_11__inheriting_constructors": {
    "prefix": "cpp_11__inheriting_constructors",
    "body": [
      "// C++11: Inheriting constructors",
      "",
      "class Base {",
      "public:",
      "    Base(int x) { std::cout << \"Base(int): \" << x << std::endl; }",
      "    Base(double x, double y) { ",
      "        std::cout << \"Base(double, double): \" << x << \", \" << y << std::endl; ",
      "    }",
      "    Base(const std::string& s) { ",
      "        std::cout << \"Base(string): \" << s << std::endl; ",
      "    }",
      "};",
      "",
      "class Derived : public Base {",
      "public:",
      "    // Inherit all constructors from Base",
      "    using Base::Base;",
      "    ",
      "    // Can still add own constructors",
      "    Derived(int x, int y) : Base(x) {",
      "        std::cout << \"Derived(int, int): \" << y << std::endl;",
      "    }",
      "};",
      "",
      "// Usage",
      "Derived d1(42);              // calls Base(int)",
      "Derived d2(3.14, 2.71);      // calls Base(double, double)",
      "Derived d3(\"hello\");         // calls Base(string)",
      "Derived d4(10, 20);          // calls Derived(int, int)",
      "$0"
    ],
    "description": "C++11 inheriting constructors with using declaration"
  },

  "cpp_11__alias_templates": {
    "prefix": "cpp_11__alias_templates",
    "body": [
      "// C++11: Alias templates (template using)",
      "",
      "// Type alias (like typedef but clearer)",
      "using IntPtr = int*;",
      "using FuncPtr = void(*)(int, double);",
      "using IntVector = std::vector<int>;",
      "",
      "// Template alias",
      "template<typename T>",
      "using Vec = std::vector<T>;",
      "",
      "template<typename T>",
      "using Matrix = std::vector<std::vector<T>>;",
      "",
      "template<typename Key>",
      "using StringMap = std::unordered_map<Key, std::string>;",
      "",
      "// Partial template specialization alias",
      "template<typename T, typename Allocator = std::allocator<T>>",
      "using List = std::list<T, Allocator>;",
      "",
      "// Usage",
      "Vec<int> v = {1, 2, 3, 4, 5};",
      "Matrix<double> m = {{1.0, 2.0}, {3.0, 4.0}};",
      "StringMap<int> id_to_name = {{1, \"Alice\"}, {2, \"Bob\"}};",
      "List<std::string> names = {\"Alice\", \"Bob\", \"Charlie\"};",
      "$0"
    ],
    "description": "C++11 alias templates using 'using' keyword"
  },

  "cpp_11__raw_string_literals": {
    "prefix": "cpp_11__raw_string_literals",
    "body": [
      "// C++11: Raw string literals",
      "",
      "// Regular string with escape sequences",
      "const char* regular = \"Line 1\\nLine 2\\n\\tTabbed\\n\\\"Quoted\\\"\\\\Backslash\";",
      "",
      "// Raw string literal - no escape sequences",
      "const char* raw = R\"(Line 1",
      "Line 2",
      "\tTabbed",
      "\"Quoted\"",
      "\\Backslash)\";",
      "",
      "// Raw string with custom delimiter",
      "const char* raw_delim = R\"delimiter(",
      "This string can contain )",
      "characters without ending",
      ")delimiter\";",
      "",
      "// Useful for regex patterns",
      "std::regex pattern(R\"(\\d{3}-\\d{3}-\\d{4})\"); // Phone number pattern",
      "",
      "// Useful for JSON",
      "const char* json = R\"({",
      "    \"name\": \"John Doe\",",
      "    \"age\": 30,",
      "    \"email\": \"john@example.com\"",
      "})\";",
      "",
      "// Useful for SQL",
      "const char* sql = R\"(",
      "SELECT * FROM users",
      "WHERE age > 18",
      "ORDER BY name ASC",
      ")\";",
      "$0"
    ],
    "description": "C++11 raw string literals for multi-line and special character strings"
  },

  "cpp_11__user_defined_literals": {
    "prefix": "cpp_11__user_defined_literals",
    "body": [
      "// C++11: User-defined literals",
      "#include <chrono>",
      "",
      "// User-defined literal for kilometers",
      "constexpr long double operator\"\"_km(long double km) {",
      "    return km * 1000.0; // Convert to meters",
      "}",
      "",
      "// User-defined literal for degrees to radians",
      "constexpr long double operator\"\"_deg(long double deg) {",
      "    return deg * 3.14159265358979323846 / 180.0;",
      "}",
      "",
      "// User-defined literal for binary",
      "constexpr unsigned long long operator\"\"_bin(const char* str, size_t len) {",
      "    unsigned long long result = 0;",
      "    for (size_t i = 0; i < len; ++i) {",
      "        result = result * 2 + (str[i] - '0');",
      "    }",
      "    return result;",
      "}",
      "",
      "// C++14 standard literals",
      "using namespace std::chrono_literals;",
      "",
      "// Usage",
      "auto distance = 5.5_km;              // 5500.0 meters",
      "auto angle = 45.0_deg;               // 0.785398 radians",
      "auto binary = 101010_bin;            // 42",
      "auto duration = 100ms;               // 100 milliseconds (C++14)",
      "$0"
    ],
    "description": "C++11 user-defined literals for custom types"
  },

  "cpp_11__thread_support": {
    "prefix": "cpp_11__thread_support",
    "body": [
      "// C++11: Thread support library",
      "#include <thread>",
      "#include <mutex>",
      "#include <condition_variable>",
      "#include <atomic>",
      "#include <future>",
      "",
      "// Basic thread usage",
      "void worker(int id) {",
      "    std::cout << \"Worker \" << id << \" on thread \" ",
      "              << std::this_thread::get_id() << std::endl;",
      "    std::this_thread::sleep_for(std::chrono::seconds(1));",
      "}",
      "",
      "// Mutex for synchronization",
      "std::mutex mtx;",
      "int shared_counter = 0;",
      "",
      "void increment_counter(int n) {",
      "    for (int i = 0; i < n; ++i) {",
      "        std::lock_guard<std::mutex> lock(mtx);",
      "        ++shared_counter;",
      "    }",
      "}",
      "",
      "// Atomic operations",
      "std::atomic<int> atomic_counter{0};",
      "",
      "// Future and promise",
      "void compute_async(std::promise<int> prom) {",
      "    prom.set_value(42);",
      "}",
      "",
      "// Usage",
      "std::thread t1(worker, 1);",
      "std::thread t2(worker, 2);",
      "",
      "// Using async",
      "auto future = std::async(std::launch::async, []() { return 42; });",
      "int result = future.get();",
      "",
      "t1.join();",
      "t2.join();",
      "$0"
    ],
    "description": "C++11 thread support with mutex, atomic, and future"
  },

  "cpp_11__chrono": {
    "prefix": "cpp_11__chrono",
    "body": [
      "// C++11: Chrono library for time utilities",
      "#include <chrono>",
      "#include <iostream>",
      "",
      "// Time points and durations",
      "auto start = std::chrono::steady_clock::now();",
      "",
      "// Different duration types",
      "std::chrono::seconds sec(1);",
      "std::chrono::milliseconds ms(1000);",
      "std::chrono::microseconds us(1000000);",
      "std::chrono::nanoseconds ns(1000000000);",
      "",
      "// Duration arithmetic",
      "auto total = sec + ms; // 2000ms",
      "",
      "// Custom duration",
      "using FPS = std::chrono::duration<double, std::ratio<1, 60>>;",
      "FPS frames(1); // 1/60th of a second",
      "",
      "// Measure execution time",
      "auto begin = std::chrono::high_resolution_clock::now();",
      "// ... code to measure ...",
      "auto end = std::chrono::high_resolution_clock::now();",
      "",
      "auto elapsed = std::chrono::duration_cast<std::chrono::microseconds>(end - begin);",
      "std::cout << \"Time: \" << elapsed.count() << \" microseconds\\n\";",
      "",
      "// System clock for wall time",
      "auto now = std::chrono::system_clock::now();",
      "std::time_t now_c = std::chrono::system_clock::to_time_t(now);",
      "std::cout << \"Current time: \" << std::ctime(&now_c);",
      "$0"
    ],
    "description": "C++11 chrono library for time measurement and manipulation"
  },

  "cpp_11__random": {
    "prefix": "cpp_11__random",
    "body": [
      "// C++11: Random number generation",
      "#include <random>",
      "",
      "// Random device for seed",
      "std::random_device rd;",
      "",
      "// Mersenne Twister generator",
      "std::mt19937 gen(rd());",
      "// Or with fixed seed for reproducibility",
      "// std::mt19937 gen(12345);",
      "",
      "// Distributions",
      "std::uniform_int_distribution<> dis_int(1, 100);",
      "std::uniform_real_distribution<> dis_real(0.0, 1.0);",
      "std::normal_distribution<> dis_normal(0.0, 1.0);",
      "std::bernoulli_distribution dis_bool(0.7); // 70% true",
      "",
      "// Generate random numbers",
      "int random_int = dis_int(gen);",
      "double random_real = dis_real(gen);",
      "double random_normal = dis_normal(gen);",
      "bool random_bool = dis_bool(gen);",
      "",
      "// Shuffle container",
      "std::vector<int> v = {1, 2, 3, 4, 5};",
      "std::shuffle(v.begin(), v.end(), gen);",
      "",
      "// Random element from container",
      "std::uniform_int_distribution<size_t> dis_index(0, v.size() - 1);",
      "int random_element = v[dis_index(gen)];",
      "$0"
    ],
    "description": "C++11 random number generation with distributions"
  },

  "cpp_11__type_traits": {
    "prefix": "cpp_11__type_traits",
    "body": [
      "// C++11: Type traits for compile-time type information",
      "#include <type_traits>",
      "",
      "// Primary type categories",
      "static_assert(std::is_integral<int>::value, \"int is integral\");",
      "static_assert(std::is_floating_point<double>::value, \"double is floating point\");",
      "static_assert(std::is_pointer<int*>::value, \"int* is pointer\");",
      "static_assert(std::is_array<int[10]>::value, \"int[10] is array\");",
      "",
      "// Type properties",
      "static_assert(std::is_const<const int>::value, \"const int is const\");",
      "static_assert(std::is_volatile<volatile int>::value, \"volatile int is volatile\");",
      "static_assert(std::is_signed<int>::value, \"int is signed\");",
      "",
      "// Type relationships",
      "static_assert(std::is_same<int, int>::value, \"same types\");",
      "static_assert(std::is_base_of<Base, Derived>::value, \"inheritance check\");",
      "static_assert(std::is_convertible<int, double>::value, \"int converts to double\");",
      "",
      "// Type modifications",
      "using NonConstType = typename std::remove_const<const int>::type; // int",
      "using NonRefType = typename std::remove_reference<int&>::type;    // int",
      "using AddPointer = typename std::add_pointer<int>::type;          // int*",
      "",
      "// Enable_if for SFINAE",
      "template<typename T>",
      "typename std::enable_if<std::is_integral<T>::value, T>::type",
      "increment(T value) {",
      "    return value + 1;",
      "}",
      "$0"
    ],
    "description": "C++11 type traits for compile-time type introspection"
  },

  "cpp_11__function_bind": {
    "prefix": "cpp_11__function_bind",
    "body": [
      "// C++11: std::function and std::bind",
      "#include <functional>",
      "",
      "// std::function - type-erased function wrapper",
      "std::function<int(int, int)> operation;",
      "",
      "// Can hold free functions",
      "int add(int a, int b) { return a + b; }",
      "operation = add;",
      "",
      "// Can hold lambdas",
      "operation = [](int a, int b) { return a * b; };",
      "",
      "// Can hold member functions",
      "struct Calculator {",
      "    int multiply(int a, int b) { return a * b; }",
      "};",
      "Calculator calc;",
      "operation = std::bind(&Calculator::multiply, &calc, ",
      "                      std::placeholders::_1, std::placeholders::_2);",
      "",
      "// std::bind - partial function application",
      "auto add5 = std::bind(add, 5, std::placeholders::_1);",
      "int result = add5(3); // 8",
      "",
      "// Bind with reordered arguments",
      "auto subtract = [](int a, int b) { return a - b; };",
      "auto reverse_subtract = std::bind(subtract, ",
      "                                   std::placeholders::_2, ",
      "                                   std::placeholders::_1);",
      "",
      "// Using std::ref for reference binding",
      "int x = 10;",
      "auto increment = std::bind([](int& n) { ++n; }, std::ref(x));",
      "increment(); // x is now 11",
      "$0"
    ],
    "description": "C++11 std::function and std::bind for functional programming"
  },

  "cpp_11__regex": {
    "prefix": "cpp_11__regex",
    "body": [
      "// C++11: Regular expressions",
      "#include <regex>",
      "#include <string>",
      "",
      "// Basic regex matching",
      "std::string text = \"The year is 2024\";",
      "std::regex year_regex(R\"(\\d{4})\");",
      "",
      "if (std::regex_search(text, year_regex)) {",
      "    std::cout << \"Found a year!\\n\";",
      "}",
      "",
      "// Capture groups",
      "std::string email = \"user@example.com\";",
      "std::regex email_regex(R\"(([\\w.]+)@([\\w.]+))\");",
      "std::smatch matches;",
      "",
      "if (std::regex_match(email, matches, email_regex)) {",
      "    std::cout << \"Full match: \" << matches[0] << std::endl;",
      "    std::cout << \"Username: \" << matches[1] << std::endl;",
      "    std::cout << \"Domain: \" << matches[2] << std::endl;",
      "}",
      "",
      "// Find all matches",
      "std::string data = \"123-456-7890, 987-654-3210\";",
      "std::regex phone_regex(R\"(\\d{3}-\\d{3}-\\d{4})\");",
      "std::sregex_iterator it(data.begin(), data.end(), phone_regex);",
      "std::sregex_iterator end;",
      "",
      "while (it != end) {",
      "    std::cout << \"Phone: \" << it->str() << std::endl;",
      "    ++it;",
      "}",
      "",
      "// Replace text",
      "std::string result = std::regex_replace(data, phone_regex, \"XXX-XXX-XXXX\");",
      "$0"
    ],
    "description": "C++11 regular expressions for pattern matching"
  },

  "cpp_11__tuple": {
    "prefix": "cpp_11__tuple",
    "body": [
      "// C++11: std::tuple for heterogeneous collections",
      "#include <tuple>",
      "#include <string>",
      "",
      "// Creating tuples",
      "std::tuple<int, double, std::string> t1(42, 3.14, \"hello\");",
      "auto t2 = std::make_tuple(10, 20.5, \"world\");",
      "",
      "// Accessing elements",
      "int first = std::get<0>(t1);",
      "double second = std::get<1>(t1);",
      "std::string third = std::get<2>(t1);",
      "",
      "// Modifying elements",
      "std::get<0>(t1) = 100;",
      "",
      "// Tuple size",
      "constexpr size_t size = std::tuple_size<decltype(t1)>::value; // 3",
      "",
      "// Tuple element type",
      "using FirstType = std::tuple_element<0, decltype(t1)>::type; // int",
      "",
      "// Unpacking with tie",
      "int a;",
      "double b;",
      "std::string c;",
      "std::tie(a, b, c) = t1;",
      "",
      "// Ignore specific elements",
      "std::tie(a, std::ignore, c) = t1;",
      "",
      "// Return multiple values",
      "std::tuple<bool, int, std::string> process() {",
      "    return std::make_tuple(true, 42, \"success\");",
      "}",
      "",
      "// Tuple comparison",
      "auto t3 = std::make_tuple(1, 2.0);",
      "auto t4 = std::make_tuple(1, 3.0);",
      "bool is_less = t3 < t4; // true",
      "$0"
    ],
    "description": "C++11 std::tuple for storing heterogeneous values"
  },

  "cpp_11__array": {
    "prefix": "cpp_11__array",
    "body": [
      "// C++11: std::array - fixed-size array container",
      "#include <array>",
      "#include <algorithm>",
      "",
      "// Declaration and initialization",
      "std::array<int, 5> arr1 = {1, 2, 3, 4, 5};",
      "std::array<int, 5> arr2 = {{1, 2, 3, 4, 5}}; // double braces also work",
      "std::array<int, 5> arr3{};                    // zero-initialized",
      "",
      "// Size is part of the type",
      "constexpr size_t size = arr1.size(); // 5",
      "static_assert(size == 5, \"Size is compile-time constant\");",
      "",
      "// Element access",
      "int first = arr1[0];",
      "int second = arr1.at(1);  // bounds-checked",
      "int& front = arr1.front();",
      "int& back = arr1.back();",
      "",
      "// Iterators",
      "for (auto it = arr1.begin(); it != arr1.end(); ++it) {",
      "    std::cout << *it << \" \";",
      "}",
      "",
      "// Range-based for loop",
      "for (const auto& elem : arr1) {",
      "    std::cout << elem << \" \";",
      "}",
      "",
      "// STL algorithms work",
      "std::sort(arr1.begin(), arr1.end());",
      "std::reverse(arr1.begin(), arr1.end());",
      "",
      "// Fill and swap",
      "arr2.fill(10);",
      "arr1.swap(arr2);",
      "",
      "// Get underlying array",
      "int* data = arr1.data();",
      "$0"
    ],
    "description": "C++11 std::array fixed-size container"
  },

  "cpp_11__forward_list": {
    "prefix": "cpp_11__forward_list",
    "body": [
      "// C++11: std::forward_list - singly linked list",
      "#include <forward_list>",
      "",
      "// Declaration and initialization",
      "std::forward_list<int> flist1;",
      "std::forward_list<int> flist2 = {1, 2, 3, 4, 5};",
      "std::forward_list<int> flist3(5, 10); // 5 elements with value 10",
      "",
      "// Insert at front (no push_back!)",
      "flist1.push_front(42);",
      "flist1.emplace_front(43);",
      "",
      "// Insert after position",
      "auto it = flist2.begin();",
      "flist2.insert_after(it, 99);        // insert 99 after first element",
      "flist2.insert_after(it, 3, 88);     // insert three 88s",
      "flist2.insert_after(it, {10, 20});  // insert list",
      "",
      "// Erase operations",
      "flist2.pop_front();",
      "flist2.erase_after(flist2.begin()); // erase second element",
      "flist2.erase_after(flist2.begin(), flist2.end()); // erase range",
      "",
      "// Special operations",
      "flist2.remove(3);                    // remove all 3s",
      "flist2.remove_if([](int n) { return n > 10; });",
      "",
      "// Sorting and unique",
      "flist2.sort();",
      "flist2.sort(std::greater<int>());",
      "flist2.unique();                     // remove consecutive duplicates",
      "",
      "// Splicing",
      "std::forward_list<int> other = {100, 200, 300};",
      "flist2.splice_after(flist2.begin(), other);",
      "",
      "// No size() method - use distance if needed",
      "auto size = std::distance(flist2.begin(), flist2.end());",
      "$0"
    ],
    "description": "C++11 std::forward_list singly-linked list container"
  },

  "cpp_11__unordered_containers": {
    "prefix": "cpp_11__unordered_containers",
    "body": [
      "// C++11: Unordered associative containers (hash tables)",
      "#include <unordered_map>",
      "#include <unordered_set>",
      "",
      "// unordered_map - hash table of key-value pairs",
      "std::unordered_map<std::string, int> umap;",
      "umap[\"apple\"] = 5;",
      "umap[\"banana\"] = 3;",
      "umap.insert({\"orange\", 7});",
      "umap.emplace(\"grape\", 2);",
      "",
      "// Access and search",
      "if (umap.find(\"apple\") != umap.end()) {",
      "    std::cout << \"Found apple: \" << umap[\"apple\"] << std::endl;",
      "}",
      "",
      "// unordered_set - hash table of unique values",
      "std::unordered_set<int> uset = {1, 2, 3, 4, 5};",
      "uset.insert(6);",
      "uset.erase(3);",
      "",
      "// unordered_multimap - allows duplicate keys",
      "std::unordered_multimap<std::string, int> ummap;",
      "ummap.insert({\"key\", 1});",
      "ummap.insert({\"key\", 2}); // same key, different value",
      "",
      "// unordered_multiset - allows duplicate values",
      "std::unordered_multiset<int> umset = {1, 2, 2, 3, 3, 3};",
      "",
      "// Hash function info",
      "auto bucket_count = umap.bucket_count();",
      "auto load_factor = umap.load_factor();",
      "umap.reserve(100); // reserve buckets for 100 elements",
      "",
      "// Custom hash function",
      "struct Point { int x, y; };",
      "struct PointHash {",
      "    size_t operator()(const Point& p) const {",
      "        return std::hash<int>()(p.x) ^ (std::hash<int>()(p.y) << 1);",
      "    }",
      "};",
      "std::unordered_set<Point, PointHash> point_set;",
      "$0"
    ],
    "description": "C++11 unordered associative containers (hash-based)"
  },

  "cpp_11__emplace": {
    "prefix": "cpp_11__emplace",
    "body": [
      "// C++11: Emplace operations for in-place construction",
      "#include <vector>",
      "#include <map>",
      "#include <string>",
      "",
      "struct Person {",
      "    std::string name;",
      "    int age;",
      "    Person(const std::string& n, int a) : name(n), age(a) {",
      "        std::cout << \"Person constructed\\n\";",
      "    }",
      "    Person(const Person& other) : name(other.name), age(other.age) {",
      "        std::cout << \"Person copied\\n\";",
      "    }",
      "    Person(Person&& other) : name(std::move(other.name)), age(other.age) {",
      "        std::cout << \"Person moved\\n\";",
      "    }",
      "};",
      "",
      "// Vector emplace",
      "std::vector<Person> people;",
      "people.push_back(Person(\"Alice\", 30));  // construct + move",
      "people.emplace_back(\"Bob\", 25);         // construct in-place",
      "",
      "// Map emplace",
      "std::map<int, Person> id_to_person;",
      "id_to_person.insert(std::make_pair(1, Person(\"Charlie\", 35))); // construct + move",
      "id_to_person.emplace(2, Person(\"David\", 28));                  // construct + move",
      "id_to_person.emplace(std::piecewise_construct,",
      "                     std::forward_as_tuple(3),",
      "                     std::forward_as_tuple(\"Eve\", 22));        // truly in-place",
      "",
      "// Emplace with hint",
      "auto hint = id_to_person.begin();",
      "id_to_person.emplace_hint(hint, 4, Person(\"Frank\", 40));",
      "",
      "// Try emplace (C++17 but showing the pattern)",
      "// auto [it, inserted] = map.try_emplace(key, args...);",
      "$0"
    ],
    "description": "C++11 emplace operations for efficient in-place construction"
  },

  "cpp_11__static_assert": {
    "prefix": "cpp_11__static_assert",
    "body": [
      "// C++11: static_assert for compile-time assertions",
      "",
      "// Basic static_assert",
      "static_assert(sizeof(int) >= 4, \"int must be at least 32 bits\");",
      "static_assert(sizeof(void*) == 8, \"This code requires 64-bit pointers\");",
      "",
      "// With type traits",
      "template<typename T>",
      "class Container {",
      "    static_assert(std::is_default_constructible<T>::value,",
      "                  \"T must be default constructible\");",
      "    static_assert(!std::is_pointer<T>::value,",
      "                  \"Container cannot store raw pointers\");",
      "    // ...",
      "};",
      "",
      "// Template constraints",
      "template<int N>",
      "class FixedArray {",
      "    static_assert(N > 0, \"Array size must be positive\");",
      "    static_assert(N <= 1000000, \"Array size too large\");",
      "    int data[N];",
      "};",
      "",
      "// Checking template parameters",
      "template<typename T, typename U>",
      "void safe_copy(T& dest, const U& src) {",
      "    static_assert(sizeof(T) >= sizeof(U),",
      "                  \"Destination must be large enough\");",
      "    static_assert(std::is_trivially_copyable<T>::value &&",
      "                  std::is_trivially_copyable<U>::value,",
      "                  \"Types must be trivially copyable\");",
      "    std::memcpy(&dest, &src, sizeof(U));",
      "}",
      "",
      "// C++17 allows static_assert without message",
      "// static_assert(condition);",
      "$0"
    ],
    "description": "C++11 static_assert for compile-time assertions"
  },

  "cpp_11__alignas_alignof": {
    "prefix": "cpp_11__alignas_alignof",
    "body": [
      "// C++11: alignas and alignof for memory alignment",
      "#include <iostream>",
      "#include <memory>",
      "",
      "// alignof operator",
      "std::cout << \"Alignment of char: \" << alignof(char) << std::endl;",
      "std::cout << \"Alignment of int: \" << alignof(int) << std::endl;",
      "std::cout << \"Alignment of double: \" << alignof(double) << std::endl;",
      "",
      "// alignas specifier",
      "struct alignas(16) Vec4 {",
      "    float x, y, z, w;",
      "};",
      "",
      "// Align to cache line",
      "struct alignas(64) CacheLineAligned {",
      "    int data;",
      "    // Padding will be added to reach 64 bytes",
      "};",
      "",
      "// Align variable",
      "alignas(32) char buffer[1024];",
      "",
      "// Over-aligned allocation (C++17)",
      "// auto* aligned_mem = new(std::align_val_t{64}) char[1024];",
      "",
      "// Check alignment",
      "std::cout << \"Vec4 alignment: \" << alignof(Vec4) << std::endl;",
      "std::cout << \"Vec4 size: \" << sizeof(Vec4) << std::endl;",
      "",
      "// Alignment in templates",
      "template<typename T, size_t Alignment>",
      "class AlignedStorage {",
      "    alignas(Alignment) char data[sizeof(T)];",
      "public:",
      "    T* get() { return reinterpret_cast<T*>(data); }",
      "};",
      "$0"
    ],
    "description": "C++11 alignas and alignof for controlling memory alignment"
  },

  "cpp_11__noexcept": {
    "prefix": "cpp_11__noexcept",
    "body": [
      "// C++11: noexcept specifier and operator",
      "#include <utility>",
      "",
      "// noexcept specifier",
      "void safe_function() noexcept {",
      "    // This function promises not to throw",
      "}",
      "",
      "// Conditional noexcept",
      "template<typename T>",
      "void swap_wrapper(T& a, T& b) noexcept(noexcept(std::swap(a, b))) {",
      "    std::swap(a, b);",
      "}",
      "",
      "// noexcept operator",
      "void may_throw() { throw 42; }",
      "void no_throw() noexcept { }",
      "",
      "static_assert(!noexcept(may_throw()), \"may_throw can throw\");",
      "static_assert(noexcept(no_throw()), \"no_throw cannot throw\");",
      "",
      "// Move operations with noexcept",
      "class Widget {",
      "    std::vector<int> data;",
      "public:",
      "    // Move constructor",
      "    Widget(Widget&& other) noexcept",
      "        : data(std::move(other.data)) {}",
      "    ",
      "    // Move assignment",
      "    Widget& operator=(Widget&& other) noexcept {",
      "        data = std::move(other.data);",
      "        return *this;",
      "    }",
      "};",
      "",
      "// Destructor is implicitly noexcept",
      "class MyClass {",
      "    ~MyClass() { } // implicitly noexcept",
      "    // ~MyClass() noexcept(false) { } // can throw",
      "};",
      "$0"
    ],
    "description": "C++11 noexcept for exception specifications"
  },

  "cpp_11__explicit_conversion": {
    "prefix": "cpp_11__explicit_conversion",
    "body": [
      "// C++11: Explicit conversion operators",
      "",
      "class Rational {",
      "    int num, den;",
      "public:",
      "    Rational(int n, int d) : num(n), den(d) {}",
      "    ",
      "    // Explicit conversion to double",
      "    explicit operator double() const {",
      "        return static_cast<double>(num) / den;",
      "    }",
      "    ",
      "    // Explicit conversion to bool (special case)",
      "    explicit operator bool() const {",
      "        return num != 0;",
      "    }",
      "};",
      "",
      "// Smart pointer example",
      "template<typename T>",
      "class SmartPtr {",
      "    T* ptr;",
      "public:",
      "    explicit SmartPtr(T* p) : ptr(p) {}",
      "    ",
      "    // Explicit bool conversion for if statements",
      "    explicit operator bool() const {",
      "        return ptr != nullptr;",
      "    }",
      "    ",
      "    T* get() const { return ptr; }",
      "};",
      "",
      "// Usage",
      "Rational r(3, 4);",
      "// double d = r;              // Error! Needs explicit cast",
      "double d = static_cast<double>(r); // OK",
      "double d2 = double(r);             // OK",
      "",
      "if (r) {  // OK - explicit bool conversion allowed in conditions",
      "    std::cout << \"r is non-zero\\n\";",
      "}",
      "",
      "SmartPtr<int> sp(new int(42));",
      "if (sp) {  // OK - explicit bool conversion",
      "    std::cout << \"sp is valid\\n\";",
      "}",
      "$0"
    ],
    "description": "C++11 explicit conversion operators"
  },

  "cpp_11__sizeof_member": {
    "prefix": "cpp_11__sizeof_member",
    "body": [
      "// C++11: sizeof on class members without object",
      "",
      "struct Data {",
      "    char c;",
      "    int i;",
      "    double d;",
      "    int arr[10];",
      "    std::string str;",
      "};",
      "",
      "// C++98/03 way - needed an object",
      "// Data* dummy = nullptr;",
      "// size_t old_size = sizeof(dummy->i);",
      "",
      "// C++11 way - no object needed",
      "size_t char_size = sizeof(Data::c);      // 1",
      "size_t int_size = sizeof(Data::i);       // 4",
      "size_t double_size = sizeof(Data::d);    // 8",
      "size_t array_size = sizeof(Data::arr);   // 40",
      "size_t string_size = sizeof(Data::str);  // implementation defined",
      "",
      "// Works in templates",
      "template<typename T>",
      "void print_member_sizes() {",
      "    std::cout << \"Size of T::value: \" << sizeof(T::value) << std::endl;",
      "    std::cout << \"Size of T::data: \" << sizeof(T::data) << std::endl;",
      "}",
      "",
      "// Useful for alignment calculations",
      "template<typename T>",
      "struct AlignedStorage {",
      "    static constexpr size_t member_size = sizeof(T::data);",
      "    static constexpr size_t alignment = alignof(T::data);",
      "    alignas(alignment) char storage[member_size];",
      "};",
      "$0"
    ],
    "description": "C++11 sizeof on class members without creating objects"
  },

  "cpp_11__enum_class": {
    "prefix": "cpp_11__enum_class",
    "body": [
      "// C++11: Strongly typed enums (enum class)",
      "",
      "// Old-style enum (C++98/03)",
      "enum Color { RED, GREEN, BLUE };",
      "enum Status { OK, ERROR, PENDING };  // ERROR conflicts!",
      "",
      "// C++11 enum class - strongly typed",
      "enum class NewColor { Red, Green, Blue };",
      "enum class NewStatus { Ok, Error, Pending };  // No conflict!",
      "",
      "// Specify underlying type",
      "enum class ErrorCode : uint8_t {",
      "    None = 0,",
      "    FileNotFound = 1,",
      "    AccessDenied = 2,",
      "    Unknown = 255",
      "};",
      "",
      "// Forward declaration (requires underlying type)",
      "enum class Priority : int;",
      "// ... later ...",
      "enum class Priority : int { Low, Medium, High };",
      "",
      "// Usage",
      "NewColor color = NewColor::Red;",
      "// int val = color;                    // Error! No implicit conversion",
      "int val = static_cast<int>(color);    // OK",
      "",
      "// Comparison",
      "if (color == NewColor::Red) {         // OK",
      "    // ...",
      "}",
      "// if (color == 0) { }                // Error! Type safe",
      "",
      "// Switch statement",
      "switch (color) {",
      "    case NewColor::Red:",
      "        break;",
      "    case NewColor::Green:",
      "        break;",
      "    case NewColor::Blue:",
      "        break;",
      "}",
      "$0"
    ],
    "description": "C++11 strongly typed enums (enum class)"
  }
}
