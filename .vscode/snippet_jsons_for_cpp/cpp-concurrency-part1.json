{
  "cpp_concurrency__std_thread": {
    "prefix": "cpp_concurrency__std_thread",
    "body": [
      "// C++ Concurrency: std::thread basics",
      "// std::thread is the fundamental building block for concurrency in C++.",
      "// It represents a single thread of execution.",
      "// Reference: https://en.cppreference.com/w/cpp/thread/thread",
      "#include <iostream>",
      "#include <thread>",
      "#include <chrono>",
      "#include <vector>",
      "#include <functional>",
      "",
      "// Function to be executed by a thread",
      "void task_function(int id) {",
      "    std::cout << \"Task \" << id << \" running on thread \" << std::this_thread::get_id() << std::endl;",
      "    std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Simulate work",
      "    std::cout << \"Task \" << id << \" finished.\" << std::endl;",
      "}",
      "",
      "// Class with an overloaded operator() (functor) to be executed by a thread",
      "class TaskObject {",
      "public:",
      "    void operator()(int id) const { // operator() must be const if passed by value",
      "        std::cout << \"Task object \" << id << \" running on thread \" << std::this_thread::get_id() << std::endl;",
      "        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Simulate work",
      "        std::cout << \"Task object \" << id << \" finished.\" << std::endl;",
      "    }",
      "};",
      "",
      "int main() {",
      "    std::cout << \"Main thread ID: \" << std::this_thread::get_id() << \"\\n\\n\";",
      "",
      "    // 1. Launching a thread with a regular function",
      "    // Arguments are passed by value by default.",
      "    std::thread t1(task_function, 1);",
      "    std::cout << \"t1 launched.\\n\";",
      "",
      "    // 2. Launching a thread with a lambda expression",
      "    // Lambdas are often convenient for short, inline tasks.",
      "    std::thread t2([](int id) {",
      "        std::cout << \"Lambda task \" << id << \" running on thread \" << std::this_thread::get_id() << std::endl;",
      "        std::this_thread::sleep_for(std::chrono::milliseconds(100));",
      "        std::cout << \"Lambda task \" << id << \" finished.\" << std::endl;",
      "    }, 2);",
      "    std::cout << \"t2 launched.\\n\";",
      "",
      "    // 3. Launching a thread with a function object (functor)",
      "    // If the functor has state, a copy is made for the thread.",
      "    TaskObject to;",
      "    std::thread t3(to, 3);",
      "    std::cout << \"t3 launched.\\n\";",
      "",
      "    // 4. Passing arguments by reference (requires std::ref)",
      "    int shared_var = 0;",
      "    std::mutex mtx_ref;",
      "    std::thread t4([&](int& val) {",
      "        std::lock_guard<std::mutex> lock(mtx_ref);",
      "        val += 100;",
      "        std::cout << \"Thread \" << std::this_thread::get_id() << \": shared_var updated to \" << val << std::endl;",
      "    }, std::ref(shared_var));",
      "    std::cout << \"t4 launched.\\n\";",
      "",
      "    // Joining threads: The main thread waits for the launched threads to complete.",
      "    // It's crucial to join or detach a thread before its std::thread object is destroyed,",
      "    // otherwise, std::terminate() will be called.",
      "    std::cout << \"\\nJoining threads...\\n\";",
      "    if (t1.joinable()) {",
      "        t1.join();",
      "        std::cout << \"t1 joined.\\n\";",
      "    }",
      "    if (t2.joinable()) {",
      "        t2.join();",
      "        std::cout << \"t2 joined.\\n\";",
      "    }",
      "    if (t3.joinable()) {",
      "        t3.join();",
      "        std::cout << \"t3 joined.\\n\";",
      "    }",
      "    if (t4.joinable()) {",
      "        t4.join();",
      "        std::cout << \"t4 joined.\\n\";",
      "    }",
      "    std::cout << \"Shared variable after t4: \" << shared_var << \"\\n\";",
      "",
      "    // 5. Detaching a thread: The thread runs independently in the background.",
      "    // The std::thread object no longer manages the thread of execution.",
      "    // Be extremely careful with detached threads, as they can outlive the resources they access.",
      "    // Ensure any shared resources are properly managed (e.g., smart pointers, global mutexes).",
      "    std::thread t5(task_function, 5);",
      "    t5.detach();",
      "    std::cout << \"t5 detached. It will run independently.\\n\";",
      "",
      "    // Main thread continues execution and might finish before detached thread.",
      "    std::cout << \"Main thread finished.\\n\";",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ Concurrency: std::thread basics, launching, joining, detaching, and passing arguments. Reference: https://en.cppreference.com/w/cpp/thread/thread"
  },

  "cpp_concurrency__std_mutex": {
    "prefix": "cpp_concurrency__std_mutex",
    "body": [
      "// C++ Concurrency: Mutexes and Locks",
      "// Mutexes (Mutual Exclusion) are fundamental synchronization primitives used to protect shared data from concurrent access by multiple threads.",
      "// They ensure that only one thread can access a critical section of code at a time, preventing data races.",
      "// Reference: https://en.cppreference.com/w/cpp/thread/mutex",
      "#include <iostream>",
      "#include <thread>",
      "#include <mutex>",
      "#include <vector>",
      "#include <chrono>",
      "#include <numeric>",
      "",
      "// --- std::mutex ---",
      "// The basic mutex type. Provides exclusive ownership.",
      "std::mutex basic_mtx;",
      "int shared_data_basic = 0;",
      "",
      "void increment_basic_data() {",
      "    for (int i = 0; i < 10000; ++i) {",
      "        // Option 1: Manual lock/unlock (prone to errors if exceptions occur or unlock is forgotten)",
      "        // basic_mtx.lock();",
      "        // shared_data_basic++;",
      "        // basic_mtx.unlock();",
      "",
      "        // Option 2: std::lock_guard (RAII - Resource Acquisition Is Initialization)",
      "        // Preferred for simple, block-scoped locks. Automatically locks on construction and unlocks on destruction.",
      "        // Reference: https://en.cppreference.com/w/cpp/thread/lock_guard",
      "        std::lock_guard<std::mutex> lock(basic_mtx);",
      "        shared_data_basic++;",
      "    }",
      "}",
      "",
      "// --- std::unique_lock ---",
      "// More flexible than std::lock_guard. Allows deferred locking, timed locking, recursive locking, and moving ownership.",
      "// Reference: https://en.cppreference.com/w/cpp/thread/unique_lock",
      "void access_shared_data_unique_lock() {",
      "    std::unique_lock<std::mutex> lock(basic_mtx, std::defer_lock); // Create lock object but don't lock yet",
      "    std::cout << \"Thread \" << std::this_thread::get_id() << \": Doing some work before locking...\\n\";",
      "    std::this_thread::sleep_for(std::chrono::milliseconds(50));",
      "",
      "    lock.lock(); // Explicitly lock the mutex",
      "    std::cout << \"Thread \" << std::this_thread::get_id() << \": Unique lock acquired. shared_data_basic = \" << shared_data_basic << std::endl;",
      "    std::this_thread::sleep_for(std::chrono::milliseconds(50));",
      "    lock.unlock(); // Explicitly unlock the mutex (can be relocked)",
      "    std::cout << \"Thread \" << std::this_thread::get_id() << \": Unique lock released. Doing more work...\\n\";",
      "    std::this_thread::sleep_for(std::chrono::milliseconds(50));",
      "",
      "    lock.lock(); // Can relock the mutex",
      "    std::cout << \"Thread \" << std::this_thread::get_id() << \": Unique lock (relocked). shared_data_basic = \" << shared_data_basic << std::endl;",
      "    // Mutex is automatically unlocked when 'lock' goes out of scope.",
      "}",
      "",
      "// --- std::recursive_mutex ---",
      "// A mutex that can be locked multiple times by the *same* thread without causing a deadlock.",
      "// Each lock must be matched by an unlock. Not recommended for general use due to potential for misuse.",
      "// Reference: https://en.cppreference.com/w/cpp/thread/recursive_mutex",
      "std::recursive_mutex recursive_mtx;",
      "int recursive_data = 0;",
      "",
      "void recursive_function(int depth) {",
      "    if (depth > 0) {",
      "        std::lock_guard<std::recursive_mutex> lock(recursive_mtx);",
      "        recursive_data++;",
      "        std::cout << \"Thread \" << std::this_thread::get_id() << \": Recursive lock depth \" << depth << \", data = \" << recursive_data << std::endl;",
      "        recursive_function(depth - 1);",
      "    }",
      "}",
      "",
      "// --- std::timed_mutex ---",
      "// A mutex that supports timed locking (try_lock_for, try_lock_until).",
      "// Useful when a thread needs to attempt to acquire a lock but not block indefinitely.",
      "// Reference: https://en.cppreference.com/w/cpp/thread/timed_mutex",
      "std::timed_mutex timed_mtx;",
      "int timed_data = 0;",
      "",
      "void timed_worker(int id) {",
      "    std::cout << \"Timed Worker \" << id << \": Trying to acquire lock...\\n\";",
      "    if (timed_mtx.try_lock_for(std::chrono::milliseconds(100))) { // Try to lock for 100ms",
      "        std::cout << \"Timed Worker \" << id << \": Acquired lock. Data = \" << ++timed_data << std::endl;",
      "        std::this_thread::sleep_for(std::chrono::milliseconds(200)); // Hold lock for a bit",
      "        timed_mtx.unlock();",
      "        std::cout << \"Timed Worker \" << id << \": Released lock.\\n\";",
      "    } else {",
      "        std::cout << \"Timed Worker \" << id << \": Could not acquire lock in time.\\n\";",
      "    }",
      "}",
      "",
      "// --- std::scoped_lock (C++17) ---",
      "// A variadic lock guard that can lock multiple mutexes at once, preventing deadlocks.",
      "// It uses a deadlock-avoidance algorithm (e.g., std::lock).",
      "// Reference: https://en.cppreference.com/w/cpp/thread/scoped_lock",
      "std::mutex mtxA, mtxB;",
      "int resourceA = 0;",
      "int resourceB = 0;",
      "",
      "void deadlock_free_worker(int id) {",
      "    std::cout << \"Scoped Lock Worker \" << id << \": Trying to lock both mutexes...\\n\";",
      "    // Locks mtxA and mtxB in a deadlock-safe manner.",
      "    std::scoped_lock lock(mtxA, mtxB); ",
      "    resourceA++;",
      "    resourceB++;",
      "    std::cout << \"Scoped Lock Worker \" << id << \": Acquired both locks. A=\" << resourceA << \", B=\" << resourceB << std::endl;",
      "    std::this_thread::sleep_for(std::chrono::milliseconds(150));",
      "} // Locks are automatically released on scope exit",
      "",
      "int main() {",
      "    std::cout << \"--- std::mutex and std::lock_guard example ---\\n\";",
      "    std::vector<std::thread> threads_basic;",
      "    for (int i = 0; i < 10; ++i) {",
      "        threads_basic.emplace_back(increment_basic_data);",
      "    }",
      "    for (auto& t : threads_basic) { t.join(); }",
      "    std::cout << \"Final shared_data_basic (should be 100000): \" << shared_data_basic << \"\\n\\n\";",
      "",
      "    std::cout << \"--- std::unique_lock example ---\\n\";",
      "    std::thread t_unique_lock(access_shared_data_unique_lock);",
      "    t_unique_lock.join();",
      "    std::cout << \"\\n\";",
      "",
      "    std::cout << \"--- std::recursive_mutex example ---\\n\";",
      "    std::thread t_recursive(recursive_function, 3);",
      "    t_recursive.join();",
      "    std::cout << \"Final recursive_data: \" << recursive_data << \"\\n\\n\";",
      "",
      "    std::cout << \"--- std::timed_mutex example ---\\n\";",
      "    std::vector<std::thread> threads_timed;",
      "    for (int i = 0; i < 3; ++i) {",
      "        threads_timed.emplace_back(timed_worker, i + 1);",
      "    }",
      "    for (auto& t : threads_timed) { t.join(); }",
      "    std::cout << \"Final timed_data: \" << timed_data << \"\\n\\n\";",
      "",
      "    std::cout << \"--- std::scoped_lock example (C++17) ---\\n\";",
      "    std::vector<std::thread> threads_scoped;",
      "    for (int i = 0; i < 3; ++i) {",
      "        threads_scoped.emplace_back(deadlock_free_worker, i + 1);",
      "    }",
      "    for (auto& t : threads_scoped) { t.join(); }",
      "    std::cout << \"Final resourceA: \" << resourceA << \", Final resourceB: \" << resourceB << \"\\n\\n\";",
      "",
      "    std::cout << \"Main thread finished.\\n\";",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ Concurrency: Mutexes and Locks (std::mutex, std::lock_guard, std::unique_lock, std::recursive_mutex, std::timed_mutex, std::scoped_lock). References: https://en.cppreference.com/w/cpp/thread/mutex, https://en.cppreference.com/w/cpp/thread/lock_guard, https://en.cppreference.com/w/cpp/thread/unique_lock, https://en.cppreference.com/w/cpp/thread/recursive_mutex, https://en.cppreference.com/w/cpp/thread/timed_mutex, https://en.cppreference.com/w/cpp/thread/scoped_lock"
  },

  "cpp_concurrency__std_condition_variable": {
    "prefix": "cpp_concurrency__std_condition_variable",
    "body": [
      "// C++ Concurrency: std::condition_variable (Producer-Consumer Pattern)",
      "// std::condition_variable allows threads to wait until a certain condition is met.",
      "// It's typically used with a std::mutex and a predicate to avoid spurious wakeups.",
      "// Reference: https://en.cppreference.com/w/cpp/thread/condition_variable",
      "#include <iostream>",
      "#include <thread>",
      "#include <mutex>",
      "#include <condition_variable>",
      "#include <queue>",
      "#include <string>",
      "#include <chrono>",
      "",
      "std::mutex mtx_cv;",
      "std::condition_variable cv;",
      "std::queue<std::string> data_queue;",
      "bool finished_producing = false;",
      "",
      "void producer() {",
      "    std::cout << \"Producer: Starting...\\n\";",
      "    for (int i = 0; i < 5; ++i) {",
      "        std::string data = \"data_\" + std::to_string(i);",
      "        {",
      "            std::lock_guard<std::mutex> lock(mtx_cv); // Lock to protect the queue",
      "            data_queue.push(data);",
      "            std::cout << \"Producer produced: \" << data << std::endl;",
      "        }",
      "        cv.notify_one(); // Notify one waiting consumer that data is available",
      "        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Simulate work",
      "    }",
      "    {",
      "        std::lock_guard<std::mutex> lock(mtx_cv);",
      "        finished_producing = true; // Signal that production is finished",
      "        std::cout << \"Producer: Finished producing.\\n\";",
      "    }",
      "    cv.notify_all(); // Notify all consumers to check the finished flag",
      "}",
      "",
      "void consumer(int id) {",
      "    std::cout << \"Consumer \" << id << \": Starting...\\n\";",
      "    while (true) {",
      "        std::unique_lock<std::mutex> lock(mtx_cv);",
      "        // Wait until data is available OR production is finished.",
      "        // The lambda predicate prevents spurious wakeups and re-checks the condition.",
      "        cv.wait(lock, [&]{ return finished_producing || !data_queue.empty(); });",
      "",
      "        // If production is finished AND queue is empty, exit.",
      "        if (finished_producing && data_queue.empty()) {",
      "            std::cout << \"Consumer \" << id << \": No more data, exiting.\\n\";",
      "            break;",
      "        }",
      "",
      "        // Process data from the queue",
      "        std::string data = data_queue.front();",
      "        data_queue.pop();",
      "        std::cout << \"Consumer \" << id << \" consumed: \" << data << std::endl;",
      "        lock.unlock(); // Unlock early if processing takes time and doesn't need the lock",
      "        std::this_thread::sleep_for(std::chrono::milliseconds(150)); // Simulate work",
      "    }",
      "}",
      "",
      "int main() {",
      "    std::thread prod_thread(producer);",
      "    std::thread cons_thread1(consumer, 1);",
      "    std::thread cons_thread2(consumer, 2);",
      "",
      "    prod_thread.join();",
      "    cons_thread1.join();",
      "    cons_thread2.join();",
      "",
      "    std::cout << \"\\nProducer-Consumer example finished.\" << std::endl;",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ Concurrency: std::condition_variable for producer-consumer pattern. Reference: https://en.cppreference.com/w/cpp/thread/condition_variable"
  },

  "cpp_concurrency__std_future_promise": {
    "prefix": "cpp_concurrency__std_future_promise",
    "body": [
      "// C++ Concurrency: std::future and std::promise",
      "// std::promise allows setting a value or an exception that can be retrieved by a std::future object.",
      "// std::future provides a mechanism to access the result of an asynchronous operation.",
      "// They are used for one-time communication of a result from one thread to another.",
      "// Reference: https://en.cppreference.com/w/cpp/thread/promise",
      "// Reference: https://en.cppreference.com/w/cpp/thread/future",
      "#include <iostream>",
      "#include <thread>",
      "#include <future>",
      "#include <chrono>",
      "#include <stdexcept>",
      "",
      "// Function that sets a value in a promise",
      "void calculate_sum(std::promise<int>&& promise_obj, int a, int b) {",
      "    std::cout << \"Thread \" << std::this_thread::get_id() << \": Calculating sum...\\n\";",
      "    std::this_thread::sleep_for(std::chrono::seconds(1)); // Simulate long computation",
      "    int sum = a + b;",
      "    promise_obj.set_value(sum); // Fulfills the promise, making the value available via future",
      "    std::cout << \"Thread \" << std::this_thread::get_id() << \": Promise set value: \" << sum << std::endl;",
      "}",
      "",
      "// Function that sets an exception in a promise",
      "void calculate_division(std::promise<double>&& promise_obj, double numerator, double denominator) {",
      "    try {",
      "        if (denominator == 0) {",
      "            throw std::runtime_error(\"Division by zero!\");",
      "        }",
      "        std::this_thread::sleep_for(std::chrono::milliseconds(500));",
      "        promise_obj.set_value(numerator / denominator);",
      "    } catch (...) {",
      "        // Catch any exception and store it in the promise",
      "        promise_obj.set_exception(std::current_exception());",
      "    }",
      "}",
      "",
      "int main() {",
      "    std::cout << \"--- std::promise and std::future for value retrieval ---\\n\";",
      "    // Create a promise and get its associated future",
      "    std::promise<int> promise_sum;",
      "    std::future<int> future_sum = promise_sum.get_future();",
      "",
      "    // Launch a thread to perform the calculation and set the promise",
      "    std::thread t_sum(calculate_sum, std::move(promise_sum), 10, 20);",
      "",
      "    std::cout << \"Main thread waiting for sum result...\\n\";",
      "    // Get the result from the future. This call blocks until the promise is fulfilled.",
      "    int result_sum = future_sum.get();",
      "    std::cout << \"Main thread: Result from future (sum): \" << result_sum << std::endl;",
      "",
      "    t_sum.join();",
      "",
      "    std::cout << \"\\n--- std::promise and std::future for exception handling ---\\n\";",
      "    std::promise<double> promise_div;",
      "    std::future<double> future_div = promise_div.get_future();",
      "",
      "    // Launch a thread with a task that might throw an exception",
      "    std::thread t_div(calculate_division, std::move(promise_div), 10.0, 0.0); // This will cause division by zero",
      "",
      "    std::cout << \"Main thread waiting for division result...\\n\";",
      "    try {",
      "        double result_div = future_div.get(); // This will rethrow the exception set in the promise",
      "        std::cout << \"Main thread: Result from future (division): \" << result_div << std::endl;",
      "    } catch (const std::exception& e) {",
      "        std::cerr << \"Main thread: Caught exception from future: \" << e.what() << std::endl;",
      "    }",
      "",
      "    t_div.join();",
      "",
      "    std::cout << \"\\nMain thread finished.\\n\";",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ Concurrency: std::future and std::promise for asynchronous results and exception handling. References: https://en.cppreference.com/w/cpp/thread/promise, https://en.cppreference.com/w/cpp/thread/future"
  },

  "cpp_concurrency__std_async": {
    "prefix": "cpp_concurrency__std_async",
    "body": [
      "// C++ Concurrency: std::async",
      "// std::async is a high-level utility for launching asynchronous tasks.",
      "// It returns a std::future that will eventually hold the result of the task.",
      "// It can choose to run the task on a new thread (std::launch::async) or defer it (std::launch::deferred).",
      "// Reference: https://en.cppreference.com/w/cpp/thread/async",
      "#include <iostream>",
      "#include <future>",
      "#include <chrono>",
      "#include <thread>",
      "",
      "// Function to be executed asynchronously",
      "int calculate_product(int a, int b) {",
      "    std::cout << \"  [Task] Calculating product in thread: \" << std::this_thread::get_id() << std::endl;",
      "    std::this_thread::sleep_for(std::chrono::seconds(1)); // Simulate work",
      "    return a * b;",
      "}",
      "",
      "int main() {",
      "    std::cout << \"Main thread ID: \" << std::this_thread::get_id() << \"\\n\\n\";",
      "",
      "    // 1. Launching a task with std::launch::async (guarantees a new thread)",
      "    std::cout << \"--- std::async with std::launch::async ---\\n\";",
      "    std::future<int> future_product = std::async(std::launch::async, calculate_product, 5, 6);",
      "",
      "    std::cout << \"Main thread doing other work while product is calculated...\\n\";",
      "    std::this_thread::sleep_for(std::chrono::milliseconds(500));",
      "",
      "    // Get the result. This call blocks until the result is ready.",
      "    int result_product = future_product.get();",
      "    std::cout << \"Main thread: Product result: \" << result_product << \"\\n\\n\";",
      "",
      "    // 2. Launching a task with default launch policy (implementation-defined: async or deferred)",
      "    // This is the most common usage. The system decides whether to run it on a new thread or defer.",
      "    std::cout << \"--- std::async with default launch policy ---\\n\";",
      "    std::future<int> future_sum = std::async([](int a, int b) {",
      "        std::cout << \"  [Task] Calculating sum in thread: \" << std::this_thread::get_id() << std::endl;",
      "        std::this_thread::sleep_for(std::chrono::milliseconds(500));",
      "        return a + b;",
      "    }, 10, 15);",
      "",
      "    std::cout << \"Main thread waiting for sum...\\n\";",
      "    std::cout << \"Main thread: Sum result: \" << future_sum.get() << \"\\n\\n\";",
      "",
      "    // 3. Launching a task with std::launch::deferred (task runs on first call to .get() or .wait())",
      "    // The task is executed synchronously on the thread that calls .get() or .wait().",
      "    std::cout << \"--- std::async with std::launch::deferred ---\\n\";",
      "    std::future<int> future_deferred = std::async(std::launch::deferred, []() {",
      "        std::cout << \"  [Task] Deferred task running on thread: \" << std::this_thread::get_id() << std::endl;",
      "        return 100;",
      "    });",
      "",
      "    std::cout << \"Main thread calling get() for deferred task...\\n\";",
      "    std::cout << \"Main thread: Deferred result: \" << future_deferred.get() << \"\\n\\n\";",
      "",
      "    // Important: The destructor of std::future blocks until the associated asynchronous operation completes.",
      "    // This means if you don't call .get() or .wait(), the future's destruction will implicitly join the thread.",
      "    std::cout << \"Main thread finished.\\n\";",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ Concurrency: std::async for simplified asynchronous task execution with different launch policies. Reference: https://en.cppreference.com/w/cpp/thread/async"
  },

  "cpp_concurrency__std_atomic": {
    "prefix": "cpp_concurrency__std_atomic",
    "body": [
      "// C++ Concurrency: std::atomic for Atomic Operations",
      "// std::atomic provides atomic (indivisible) operations on data, ensuring thread safety without explicit locks.",
      "// This is crucial for low-level synchronization and building lock-free data structures.",
      "// Reference: https://en.cppreference.com/w/cpp/atomic/atomic",
      "#include <iostream>",
      "#include <thread>",
      "#include <atomic>",
      "#include <vector>",
      "#include <chrono>",
      "",
      "// An atomic integer counter",
      "std::atomic<int> atomic_counter(0);",
      "// std::atomic_int atomic_counter(0); // std::atomic_int is an alias for std::atomic<int>",
      "",
      "void increment_atomic_counter() {",
      "    for (int i = 0; i < 100000; ++i) {",
      "        // Atomic increment: equivalent to atomic_counter.fetch_add(1, std::memory_order_seq_cst);",
      "        // This operation is guaranteed to be atomic and sequentially consistent by default.",
      "        atomic_counter++;",
      "    }",
      "}",
      "",
      "int main() {",
      "    std::cout << \"--- std::atomic basic increment example ---\\n\";",
      "    std::vector<std::thread> threads;",
      "    for (int i = 0; i < 10; ++i) {",
      "        threads.emplace_back(increment_atomic_counter);",
      "    }",
      "",
      "    for (auto& t : threads) {",
      "        t.join();",
      "    }",
      "",
      "    // The final value should be exactly 10 * 100000 = 1000000 due to atomicity.",
      "    std::cout << \"Final atomic_counter (should be 1000000): \" << atomic_counter.load() << \"\\n\\n\";",
      "",
      "    std::cout << \"--- Other basic atomic operations ---\\n\";",
      "    std::atomic<bool> flag(false);",
      "",
      "    // store(): Atomically sets the value.",
      "    flag.store(true);",
      "    std::cout << \"Atomic flag after store(true): \" << std::boolalpha << flag.load() << std::endl;",
      "",
      "    // load(): Atomically reads the value.",
      "    bool current_flag = flag.load();",
      "    std::cout << \"Atomic flag after load(): \" << std::boolalpha << current_flag << std::endl;",
      "",
      "    // is_lock_free(): Checks if the atomic operation is implemented without locks (hardware support).",
      "    // True means it's typically faster.",
      "    std::cout << \"std::atomic<int> is lock-free: \" << std::boolalpha << atomic_counter.is_lock_free() << std::endl;",
      "    std::cout << \"std::atomic<bool> is lock-free: \" << std::boolalpha << flag.is_lock_free() << \"\\n\";",
      "",
      "    std::cout << \"\\nMain thread finished.\\n\";",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ Concurrency: std::atomic for lock-free atomic operations (increment, load, store, is_lock_free). Reference: https://en.cppreference.com/w/cpp/atomic/atomic"
  },

  "cpp_concurrency__thread_local": {
    "prefix": "cpp_concurrency__thread_local",
    "body": [
      "// C++ Concurrency: thread_local Storage Duration Specifier",
      "// The `thread_local` keyword specifies that a variable has thread storage duration.",
      "// This means each thread that accesses the variable gets its own independent copy of it.",
      "// It's useful for avoiding false sharing or when each thread needs its own state.",
      "// Reference: https://en.cppreference.com/w/cpp/language/thread_local",
      "#include <iostream>",
      "#include <thread>",
      "#include <vector>",
      "#include <chrono>",
      "",
      "// Global thread-local variable: each thread will have its own 'thread_specific_data'",
      "thread_local int thread_specific_data = 0;",
      "",
      "void increment_thread_data(int id) {",
      "    // Accessing thread_specific_data modifies only this thread's copy.",
      "    thread_specific_data += id; ",
      "    std::cout << \"Thread \" << std::this_thread::get_id() ",
      "              << \": thread_specific_data = \" << thread_specific_data << std::endl;",
      "    std::this_thread::sleep_for(std::chrono::milliseconds(50));",
      "}",
      "",
      "int main() {",
      "    std::cout << \"Main thread: Initial thread_specific_data = \" << thread_specific_data << std::endl;",
      "",
      "    // Modify main thread's copy",
      "    thread_specific_data = 100;",
      "    std::cout << \"Main thread: Modified thread_specific_data = \" << thread_specific_data << \"\\n\\n\";",
      "",
      "    std::vector<std::thread> threads;",
      "    for (int i = 1; i <= 3; ++i) {",
      "        // Each new thread will get its own copy, initialized to 0.",
      "        threads.emplace_back(increment_thread_data, i * 10);",
      "    }",
      "",
      "    for (auto& t : threads) {",
      "        t.join();",
      "    }",
      "",
      "    // After all threads join, the main thread's copy of thread_specific_data remains unchanged.",
      "    std::cout << \"\\nMain thread after joins: thread_specific_data = \" << thread_specific_data << std::endl;",
      "",
      "    std::cout << \"Main thread finished.\\n\";",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ Concurrency: thread_local storage for thread-specific data. Reference: https://en.cppreference.com/w/cpp/language/thread_local"
  },

  "cpp_concurrency__std_call_once": {
    "prefix": "cpp_concurrency__std_call_once",
    "body": [
      "// C++ Concurrency: std::call_once and std::once_flag",
      "// std::call_once ensures that a callable object (function, lambda, etc.) is called exactly once,",
      "// even if multiple threads attempt to call it concurrently.",
      "// It's typically used for lazy, thread-safe initialization of global or static resources.",
      "// Reference: https://en.cppreference.com/w/cpp/thread/call_once",
      "#include <iostream>",
      "#include <thread>",
      "#include <mutex>",
      "#include <vector>",
      "#include <chrono>",
      "",
      "// A std::once_flag is used to manage the state of the one-time initialization.",
      "std::once_flag initialization_flag;",
      "",
      "// Resource that needs to be initialized exactly once.",
      "class SingletonResource {",
      "public:",
      "    static SingletonResource& get_instance() {",
      "        // std::call_once ensures this lambda (and thus the constructor) is called only once.",
      "        std::call_once(initialization_flag, []() {",
      "            instance_ptr = new SingletonResource();",
      "            std::cout << \"  [SingletonResource] Initialized by thread: \" << std::this_thread::get_id() << std::endl;",
      "        });",
      "        return *instance_ptr;",
      "    }",
      "",
      "    void do_something() const {",
      "        std::cout << \"  [SingletonResource] Doing something from thread: \" << std::this_thread::get_id() << std::endl;",
      "    }",
      "",
      "private:",
      "    SingletonResource() = default; // Private constructor for Singleton pattern",
      "    ~SingletonResource() = default;",
      "    SingletonResource(const SingletonResource&) = delete;",
      "    SingletonResource& operator=(const SingletonResource&) = delete;",
      "",
      "    static SingletonResource* instance_ptr;",
      "};",
      "",
      "SingletonResource* SingletonResource::instance_ptr = nullptr;",
      "",
      "void worker_function() {",
      "    std::cout << \"Worker thread \" << std::this_thread::get_id() << \" trying to get resource...\" << std::endl;",
      "    SingletonResource::get_instance().do_something();",
      "    std::this_thread::sleep_for(std::chrono::milliseconds(50));",
      "    std::cout << \"Worker thread \" << std::this_thread::get_id() << \" finished resource access.\" << std::endl;",
      "}",
      "",
      "int main() {",
      "    std::cout << \"--- std::call_once example (Singleton Initialization) ---\\n\";",
      "    std::vector<std::thread> threads;",
      "    for (int i = 0; i < 5; ++i) {",
      "        threads.emplace_back(worker_function);",
      "    }",
      "",
      "    for (auto& t : threads) {",
      "        t.join();",
      "    }",
      "",
      "    std::cout << \"\\nAll threads finished. Resource was initialized only once.\\n\";",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ Concurrency: std::call_once and std::once_flag for one-time initialization (e.g., Singleton pattern). Reference: https://en.cppreference.com/w/cpp/thread/call_once"
  },

  "cpp_concurrency__std_shared_mutex": {
    "prefix": "cpp_concurrency__std_shared_mutex",
    "body": [
      "// C++ Concurrency: std::shared_mutex (C++17) for Reader-Writer Lock",
      "// std::shared_mutex provides a reader-writer lock mechanism.",
      "// Multiple threads can acquire a shared (read) lock concurrently.",
      "// Only one thread can acquire an exclusive (write) lock at a time.",
      "// A write lock blocks all other read and write locks.",
      "// Reference: https://en.cppreference.com/w/cpp/thread/shared_mutex",
      "#include <iostream>",
      "#include <thread>",
      "#include <shared_mutex>",
      "#include <vector>",
      "#include <string>",
      "#include <chrono>",
      "",
      "std::shared_mutex shared_mtx;",
      "int shared_resource = 0;",
      "",
      "void reader(int id) {",
      "    for (int i = 0; i < 3; ++i) {",
      "        // Acquire a shared lock (allows multiple readers concurrently)",
      "        std::shared_lock<std::shared_mutex> lock(shared_mtx); ",
      "        std::cout << \"Reader \" << id << \" reads: \" << shared_resource << std::endl;",
      "        // lock.unlock(); // Can release shared lock early if needed",
      "        std::this_thread::sleep_for(std::chrono::milliseconds(50)); // Simulate reading time",
      "    } // Lock is automatically released when 'lock' goes out of scope",
      "}",
      "",
      "void writer(int id) {",
      "    for (int i = 0; i < 2; ++i) {",
      "        // Acquire an exclusive lock (blocks all other readers and writers)",
      "        std::unique_lock<std::shared_mutex> lock(shared_mtx); ",
      "        shared_resource++;",
      "        std::cout << \"Writer \" << id << \" writes: \" << shared_resource << std::endl;",
      "        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Simulate writing time",
      "    } // Lock is automatically released when 'lock' goes out of scope",
      "}",
      "",
      "int main() {",
      "    std::cout << \"--- std::shared_mutex example ---\\n\";",
      "    std::vector<std::thread> threads;",
      "",
      "    // Create writer threads (fewer writers, as they block more)",
      "    for (int i = 1; i <= 2; ++i) {",
      "        threads.emplace_back(writer, i);",
      "    }",
      "",
      "    // Create reader threads (more readers, as they can run concurrently)",
      "    for (int i = 1; i <= 5; ++i) {",
      "        threads.emplace_back(reader, i);",
      "    }",
      "",
      "    for (auto& t : threads) {",
      "        t.join();",
      "    }",
      "",
      "    std::cout << \"\\nFinal shared_resource value: \" << shared_resource << std::endl;",
      "    std::cout << \"Main thread finished.\\n\";",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ Concurrency: std::shared_mutex for reader-writer locks (C++17). Reference: https://en.cppreference.com/w/cpp/thread/shared_mutex"
  },

  "cpp_concurrency__std_latch_barrier": {
    "prefix": "cpp_concurrency__std_latch_barrier",
    "body": [
      "// C++ Concurrency: std::latch and std::barrier (C++20)",
      "// These are synchronization primitives for coordinating groups of threads.",
      "// std::latch: A single-use barrier that allows a set of threads to wait until a counter reaches zero.",
      "// Reference: https://en.cppreference.com/w/cpp/thread/latch",
      "// std::barrier: A reusable barrier that allows a set of threads to wait until all threads reach a certain point.",
      "// It can execute a completion function when all threads arrive.",
      "// Reference: https://en.cppreference.com/w/cpp/thread/barrier",
      "#include <iostream>",
      "#include <thread>",
      "#include <vector>",
      "#include <latch>",
      "#include <barrier>",
      "#include <chrono>",
      "#include <functional> // For std::ref",
      "",
      "// Example with std::latch (one-time synchronization)",
      "void worker_latch(int id, std::latch& start_latch, std::latch& end_latch) {",
      "    std::cout << \"Worker \" << id << \": Waiting to start...\\n\";",
      "    start_latch.arrive_and_wait(); // Decrement counter and wait until it's zero",
      "    ",
      "    std::cout << \"Worker \" << id << \" started processing.\\n\";",
      "    std::this_thread::sleep_for(std::chrono::milliseconds(100 + id * 10)); // Simulate work",
      "    std::cout << \"Worker \" << id << \" finished processing.\\n\";",
      "    ",
      "    end_latch.arrive_and_wait(); // Signal completion and wait for others to finish",
      "}",
      "",
      "// Example with std::barrier (reusable synchronization)",
      "void worker_barrier(int id, std::barrier& sync_barrier) {",
      "    for (int i = 0; i < 3; ++i) { // Simulate 3 phases of work",
      "        std::cout << \"Worker \" << id << \" phase \" << i + 1 << \" started.\\n\";",
      "        std::this_thread::sleep_for(std::chrono::milliseconds(50)); // Simulate work in phase",
      "        sync_barrier.arrive_and_wait(); // Synchronize at barrier. All threads wait here.",
      "        std::cout << \"Worker \" << id << \" phase \" << i + 1 << \" finished.\\n\";",
      "    }",
      "}",
      "",
      "int main() {",
      "    std::cout << \"--- std::latch example ---\\n\";",
      "    const int num_latch_workers = 3;",
      "    // Latch for starting: +1 for the main thread to release workers.",
      "    std::latch start_latch(num_latch_workers + 1); ",
      "    // Latch for ending: workers signal their completion.",
      "    std::latch end_latch(num_latch_workers);",
      "    std::vector<std::thread> latch_threads;",
      "",
      "    for (int i = 0; i < num_latch_workers; ++i) {",
      "        latch_threads.emplace_back(worker_latch, i + 1, std::ref(start_latch), std::ref(end_latch));",
      "    }",
      "",
      "    std::cout << \"Main thread preparing workers (latch)...\\n\";",
      "    std::this_thread::sleep_for(std::chrono::milliseconds(200));",
      "    start_latch.arrive_and_wait(); // Main thread signals workers to start",
      "    std::cout << \"Main thread released latch workers.\\n\";",
      "",
      "    end_latch.wait(); // Main thread waits for all workers to finish",
      "    std::cout << \"All latch workers finished.\\n\\n\";",
      "",
      "    for (auto& t : latch_threads) {",
      "        t.join();",
      "    }",
      "",
      "    std::cout << \"--- std::barrier example ---\\n\";",
      "    const int num_barrier_workers = 3;",
      "    // The completion function runs when all threads arrive at the barrier.",
      "    // It's executed by one of the arriving threads (arbitrarily chosen).",
      "    auto on_completion = []() noexcept {",
      "        static int phase = 0;",
      "        std::cout << \"  [Barrier] Phase \" << ++phase << \" completed! All threads synchronized.\\n\";",
      "    };",
      "    std::barrier sync_barrier(num_barrier_workers, on_completion);",
      "    std::vector<std::thread> barrier_threads;",
      "",
      "    for (int i = 0; i < num_barrier_workers; ++i) {",
      "        barrier_threads.emplace_back(worker_barrier, i + 1, std::ref(sync_barrier));",
      "    }",
      "",
      "    for (auto& t : barrier_threads) {",
      "        t.join();",
      "    }",
      "",
      "    std::cout << \"\\nAll barrier workers finished.\\n\";",
      "",
      "    std::cout << \"Main thread finished.\\n\";",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ Concurrency: std::latch (one-time) and std::barrier (reusable) for thread synchronization (C++20). References: https://en.cppreference.com/w/cpp/thread/latch, https://en.cppreference.com/w/cpp/thread/barrier"
  }
}
