{
  "cpp_algorithm__all_of_any_of_none_of": {
    "prefix": "cpp_algorithm__all_of_any_of_none_of",
    "body": [
      "// std::all_of, std::any_of, std::none_of - Check if predicate is true for all/any/none elements",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/all_any_none_of",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "std::vector<int> vec = {2, 4, 6, 8, 10};",
      "",
      "// all_of: Returns true if pred returns true for all elements in range [first, last)",
      "bool all_even = std::all_of(vec.begin(), vec.end(), [](int i){ return i % 2 == 0; });",
      "std::cout << \"All even: \" << all_even << std::endl; // true",
      "",
      "// any_of: Returns true if pred returns true for at least one element",
      "bool has_greater_than_5 = std::any_of(vec.begin(), vec.end(), [](int i){ return i > 5; });",
      "std::cout << \"Has element > 5: \" << has_greater_than_5 << std::endl; // true",
      "",
      "// none_of: Returns true if pred returns false for all elements",
      "bool no_negatives = std::none_of(vec.begin(), vec.end(), [](int i){ return i < 0; });",
      "std::cout << \"No negatives: \" << no_negatives << std::endl; // true",
      "$0"
    ],
    "description": "Check if a predicate is true for all, any, or none of the elements in a range. all_of returns true if the predicate returns true for all elements or if the range is empty. any_of returns true if the predicate returns true for at least one element. none_of returns true if the predicate returns false for all elements or if the range is empty. Time complexity: O(n) where n is the distance between first and last. Link: https://en.cppreference.com/w/cpp/algorithm/all_any_none_of"
  },

  "cpp_algorithm__for_each": {
    "prefix": "cpp_algorithm__for_each",
    "body": [
      "// std::for_each - Apply function to each element in range",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/for_each",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "std::vector<int> vec = {1, 2, 3, 4, 5};",
      "",
      "// Apply function to each element",
      "std::for_each(vec.begin(), vec.end(), [](int& n){ n *= 2; });",
      "",
      "// Print each element",
      "std::for_each(vec.begin(), vec.end(), [](const int& n){ std::cout << n << \" \"; });",
      "std::cout << std::endl;",
      "",
      "// for_each with function object",
      "struct Sum {",
      "    int sum = 0;",
      "    void operator()(int n) { sum += n; }",
      "};",
      "",
      "Sum s = std::for_each(vec.begin(), vec.end(), Sum());",
      "std::cout << \"Sum: \" << s.sum << std::endl;",
      "",
      "// C++17: for_each_n - Apply function to first n elements",
      "std::for_each_n(vec.begin(), 3, [](int& n){ n += 10; });",
      "$0"
    ],
    "description": "Applies the given function object to each element in the range [first, last). The function is applied in order from first to last. If the function object has a return value, it is ignored. for_each returns the function object after it has been applied to all elements. Time complexity: O(n) applications of the function. Link: https://en.cppreference.com/w/cpp/algorithm/for_each"
  },

  "cpp_algorithm__count_count_if": {
    "prefix": "cpp_algorithm__count_count_if",
    "body": [
      "// std::count, std::count_if - Count elements satisfying criteria",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/count",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "std::vector<int> vec = {1, 2, 3, 2, 5, 2, 6, 2};",
      "",
      "// count: Count occurrences of a specific value",
      "auto count_2 = std::count(vec.begin(), vec.end(), 2);",
      "std::cout << \"Count of 2: \" << count_2 << std::endl; // 4",
      "",
      "// count_if: Count elements satisfying a predicate",
      "auto count_even = std::count_if(vec.begin(), vec.end(), ",
      "                                [](int i){ return i % 2 == 0; });",
      "std::cout << \"Count of even numbers: \" << count_even << std::endl; // 5",
      "",
      "// Count elements in a range",
      "auto count_range = std::count_if(vec.begin(), vec.end(), ",
      "                                 [](int i){ return i >= 3 && i <= 5; });",
      "std::cout << \"Count in range [3,5]: \" << count_range << std::endl; // 3",
      "$0"
    ],
    "description": "Returns the number of elements in the range [first, last) that compare equal to value (count) or satisfy a predicate (count_if). count uses operator== to compare elements with the value. count_if applies the predicate to each element and counts those for which it returns true. Time complexity: O(n) comparisons/applications of the predicate. Link: https://en.cppreference.com/w/cpp/algorithm/count"
  },

  "cpp_algorithm__find_find_if_find_if_not": {
    "prefix": "cpp_algorithm__find_find_if_find_if_not",
    "body": [
      "// std::find, std::find_if, std::find_if_not - Find elements in range",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/find",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "std::vector<int> vec = {1, 3, 5, 7, 9, 11};",
      "",
      "// find: Find first occurrence of value",
      "auto it1 = std::find(vec.begin(), vec.end(), 5);",
      "if (it1 != vec.end()) {",
      "    std::cout << \"Found 5 at position: \" << std::distance(vec.begin(), it1) << std::endl;",
      "}",
      "",
      "// find_if: Find first element satisfying predicate",
      "auto it2 = std::find_if(vec.begin(), vec.end(), [](int i){ return i > 6; });",
      "if (it2 != vec.end()) {",
      "    std::cout << \"First element > 6: \" << *it2 << std::endl; // 7",
      "}",
      "",
      "// find_if_not: Find first element NOT satisfying predicate (C++11)",
      "auto it3 = std::find_if_not(vec.begin(), vec.end(), [](int i){ return i % 2 == 1; });",
      "if (it3 == vec.end()) {",
      "    std::cout << \"All elements are odd\\n\";",
      "}",
      "",
      "// Find with custom comparison",
      "struct Person { std::string name; int age; };",
      "std::vector<Person> people = {{\"Alice\", 30}, {\"Bob\", 25}, {\"Carol\", 35}};",
      "auto person = std::find_if(people.begin(), people.end(), ",
      "                          [](const Person& p){ return p.age > 30; });",
      "$0"
    ],
    "description": "Searches for elements in a range. find searches for the first element equal to value. find_if searches for the first element for which predicate returns true. find_if_not searches for the first element for which predicate returns false. Returns an iterator to the first element found, or last if no such element is found. Time complexity: O(n) comparisons. Link: https://en.cppreference.com/w/cpp/algorithm/find"
  },

  "cpp_algorithm__find_end": {
    "prefix": "cpp_algorithm__find_end",
    "body": [
      "// std::find_end - Find last occurrence of a subsequence",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/find_end",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "std::vector<int> haystack = {1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4};",
      "std::vector<int> needle = {1, 2, 3};",
      "",
      "// Find last occurrence of subsequence",
      "auto it = std::find_end(haystack.begin(), haystack.end(),",
      "                       needle.begin(), needle.end());",
      "",
      "if (it != haystack.end()) {",
      "    std::cout << \"Last occurrence at position: \" ",
      "              << std::distance(haystack.begin(), it) << std::endl; // 8",
      "}",
      "",
      "// With custom predicate",
      "auto it2 = std::find_end(haystack.begin(), haystack.end(),",
      "                        needle.begin(), needle.end(),",
      "                        [](int a, int b){ return a == b; });",
      "$0"
    ],
    "description": "Searches for the last occurrence of the sequence [s_first, s_last) within the range [first, last). Returns an iterator to the beginning of the last occurrence of the sequence in the range, or last if no such sequence is found. The elements are compared using operator== or the given binary predicate. Time complexity: O(S*(N-S+1)) where S is the distance between s_first and s_last. Link: https://en.cppreference.com/w/cpp/algorithm/find_end"
  },

  "cpp_algorithm__find_first_of": {
    "prefix": "cpp_algorithm__find_first_of",
    "body": [
      "// std::find_first_of - Find first element from a set",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/find_first_of",
      "#include <algorithm>",
      "#include <vector>",
      "#include <string>",
      "#include <iostream>",
      "",
      "std::string str = \"Hello, World!\";",
      "std::string vowels = \"aeiouAEIOU\";",
      "",
      "// Find first vowel in string",
      "auto it = std::find_first_of(str.begin(), str.end(),",
      "                            vowels.begin(), vowels.end());",
      "",
      "if (it != str.end()) {",
      "    std::cout << \"First vowel: '\" << *it << \"' at position \" ",
      "              << std::distance(str.begin(), it) << std::endl; // 'e' at position 1",
      "}",
      "",
      "// With integers",
      "std::vector<int> vec = {0, 2, 3, 25, 5};",
      "std::vector<int> targets = {3, 19, 10, 2};",
      "",
      "auto it2 = std::find_first_of(vec.begin(), vec.end(),",
      "                             targets.begin(), targets.end());",
      "if (it2 != vec.end()) {",
      "    std::cout << \"First match: \" << *it2 << std::endl; // 2",
      "}",
      "$0"
    ],
    "description": "Searches the range [first, last) for any of the elements in the range [s_first, s_last). Returns an iterator to the first element in the range that is equal to an element from the sequence, or last if no such element is found. Elements are compared using operator== or the given binary predicate. Time complexity: O(N*S) where N is the distance between first and last, and S is the distance between s_first and s_last. Link: https://en.cppreference.com/w/cpp/algorithm/find_first_of"
  },

  "cpp_algorithm__adjacent_find": {
    "prefix": "cpp_algorithm__adjacent_find",
    "body": [
      "// std::adjacent_find - Find first pair of adjacent equal elements",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/adjacent_find",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "std::vector<int> vec = {1, 2, 3, 3, 4, 5, 5, 5, 6};",
      "",
      "// Find first pair of equal adjacent elements",
      "auto it = std::adjacent_find(vec.begin(), vec.end());",
      "if (it != vec.end()) {",
      "    std::cout << \"First adjacent pair: \" << *it << \" at position \"",
      "              << std::distance(vec.begin(), it) << std::endl; // 3 at position 2",
      "}",
      "",
      "// With custom predicate - find adjacent elements where second > first + 1",
      "auto it2 = std::adjacent_find(vec.begin(), vec.end(),",
      "                             [](int a, int b){ return b > a + 1; });",
      "if (it2 != vec.end()) {",
      "    std::cout << \"Jump from \" << *it2 << \" to \" << *(it2 + 1) << std::endl;",
      "}",
      "",
      "// Find adjacent elements with specific difference",
      "auto it3 = std::adjacent_find(vec.begin(), vec.end(),",
      "                             [](int a, int b){ return std::abs(a - b) > 2; });",
      "$0"
    ],
    "description": "Searches the range [first, last) for two consecutive identical elements. Returns an iterator to the first of the first pair of identical elements, or last if no such pair is found. Can use a custom binary predicate to determine if elements should be treated as equal. Time complexity: O(n) applications of the predicate. Link: https://en.cppreference.com/w/cpp/algorithm/adjacent_find"
  },

  "cpp_algorithm__search": {
    "prefix": "cpp_algorithm__search",
    "body": [
      "// std::search - Search for a subsequence",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/search",
      "#include <algorithm>",
      "#include <vector>",
      "#include <string>",
      "#include <iostream>",
      "",
      "std::string text = \"The quick brown fox jumps over the lazy dog\";",
      "std::string pattern = \"fox\";",
      "",
      "// Search for pattern in text",
      "auto it = std::search(text.begin(), text.end(),",
      "                     pattern.begin(), pattern.end());",
      "",
      "if (it != text.end()) {",
      "    std::cout << \"Found at position: \" << std::distance(text.begin(), it) << std::endl;",
      "}",
      "",
      "// Search with custom predicate",
      "std::vector<int> vec1 = {1, 2, 3, 4, 5, 6, 7, 8, 9};",
      "std::vector<int> vec2 = {4, 5, 6};",
      "",
      "auto it2 = std::search(vec1.begin(), vec1.end(),",
      "                      vec2.begin(), vec2.end());",
      "",
      "// C++17: Search with searcher",
      "auto it3 = std::search(text.begin(), text.end(),",
      "                      std::boyer_moore_searcher(pattern.begin(), pattern.end()));",
      "$0"
    ],
    "description": "Searches for the first occurrence of the sequence [s_first, s_last) in the range [first, last). Returns an iterator to the beginning of the first occurrence of the sequence in the range, or last if no such sequence is found. Can use custom predicates or C++17 searchers for optimized searching. Time complexity: O((N-S+1)*S) for naive search. Link: https://en.cppreference.com/w/cpp/algorithm/search"
  },

  "cpp_algorithm__search_n": {
    "prefix": "cpp_algorithm__search_n",
    "body": [
      "// std::search_n - Search for n consecutive copies of value",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/search_n",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "std::vector<int> vec = {1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5};",
      "",
      "// Search for 3 consecutive 3s",
      "auto it = std::search_n(vec.begin(), vec.end(), 3, 3);",
      "",
      "if (it != vec.end()) {",
      "    std::cout << \"Found 3 consecutive 3s at position: \"",
      "              << std::distance(vec.begin(), it) << std::endl; // 3",
      "}",
      "",
      "// Search with custom predicate - find 2 consecutive elements > 3",
      "auto it2 = std::search_n(vec.begin(), vec.end(), 2, 3,",
      "                        [](int elem, int value){ return elem > value; });",
      "",
      "if (it2 != vec.end()) {",
      "    std::cout << \"Found at position: \" << std::distance(vec.begin(), it2) << std::endl;",
      "}",
      "$0"
    ],
    "description": "Searches the range [first, last) for the first sequence of count identical elements, each equal to value. Can use a custom binary predicate. Returns an iterator to the beginning of the found sequence, or last if no such sequence is found. Time complexity: O(n) where n is the distance between first and last. Link: https://en.cppreference.com/w/cpp/algorithm/search_n"
  },

  "cpp_algorithm__copy_copy_if_copy_n": {
    "prefix": "cpp_algorithm__copy_copy_if_copy_n",
    "body": [
      "// std::copy, std::copy_if, std::copy_n - Copy elements to another range",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/copy",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "#include <iterator>",
      "",
      "std::vector<int> source = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};",
      "std::vector<int> dest1(source.size());",
      "std::vector<int> dest2;",
      "std::vector<int> dest3(5);",
      "",
      "// copy: Copy all elements",
      "std::copy(source.begin(), source.end(), dest1.begin());",
      "",
      "// copy_if: Copy elements that satisfy condition",
      "std::copy_if(source.begin(), source.end(), ",
      "             std::back_inserter(dest2),",
      "             [](int i){ return i % 2 == 0; });",
      "// dest2 now contains: 2, 4, 6, 8, 10",
      "",
      "// copy_n: Copy first n elements",
      "std::copy_n(source.begin(), 5, dest3.begin());",
      "// dest3 now contains: 1, 2, 3, 4, 5",
      "",
      "// Copy to output stream",
      "std::copy(source.begin(), source.end(), ",
      "          std::ostream_iterator<int>(std::cout, \" \"));",
      "$0"
    ],
    "description": "Copies elements from one range to another. copy copies all elements, copy_if copies only elements satisfying a predicate, copy_n copies exactly n elements. The destination range must have enough space. Returns an iterator to the end of the destination range. Time complexity: O(n) for all variants. Link: https://en.cppreference.com/w/cpp/algorithm/copy"
  },

  "cpp_algorithm__copy_backward": {
    "prefix": "cpp_algorithm__copy_backward",
    "body": [
      "// std::copy_backward - Copy elements backwards",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/copy_backward",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};",
      "",
      "// Shift elements to the right by 2 positions",
      "// Must copy backwards to avoid overwriting",
      "std::copy_backward(vec.begin(), vec.begin() + 8, vec.begin() + 10);",
      "",
      "// Now vec contains: 1, 2, 1, 2, 3, 4, 5, 6, 7, 8",
      "",
      "// Safe overlapping copy example",
      "std::vector<int> data = {1, 2, 3, 4, 5};",
      "// Copy [0,3) to [2,5) - overlapping ranges",
      "std::copy_backward(data.begin(), data.begin() + 3, data.begin() + 5);",
      "// Result: 1, 2, 1, 2, 3",
      "",
      "for (int n : data) {",
      "    std::cout << n << \" \";",
      "}",
      "$0"
    ],
    "description": "Copies elements from the range [first, last) to another range ending at d_last. The elements are copied in reverse order (the last element is copied first), but their relative order is preserved. Useful for shifting elements when ranges overlap. Returns an iterator to the beginning of the destination range. Time complexity: O(n). Link: https://en.cppreference.com/w/cpp/algorithm/copy_backward"
  },

  "cpp_algorithm__move_move_backward": {
    "prefix": "cpp_algorithm__move_move_backward",
    "body": [
      "// std::move (algorithm), std::move_backward - Move elements",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/move",
      "#include <algorithm>",
      "#include <vector>",
      "#include <string>",
      "#include <iostream>",
      "",
      "// Move with std::move (algorithm version)",
      "std::vector<std::string> source = {\"Hello\", \"World\", \"C++\", \"Algorithm\"};",
      "std::vector<std::string> dest(source.size());",
      "",
      "// Move all elements",
      "std::move(source.begin(), source.end(), dest.begin());",
      "// source strings are now in valid but unspecified state",
      "",
      "// Move backward example",
      "std::vector<std::string> vec = {\"A\", \"B\", \"C\", \"D\", \"E\"};",
      "// Shift elements to the right",
      "std::move_backward(vec.begin(), vec.begin() + 3, vec.begin() + 5);",
      "// Result: \"A\", \"B\", \"A\", \"B\", \"C\"",
      "",
      "// Practical example: inserting element in middle",
      "std::vector<std::string> data = {\"one\", \"two\", \"four\", \"five\"};",
      "data.resize(data.size() + 1);",
      "std::move_backward(data.begin() + 2, data.end() - 1, data.end());",
      "data[2] = \"three\";",
      "// Result: \"one\", \"two\", \"three\", \"four\", \"five\"",
      "$0"
    ],
    "description": "Moves elements from one range to another. std::move transfers ownership of elements using move semantics. move_backward moves elements in reverse order but preserves their relative order, useful for shifting elements when ranges overlap. After moving, the source elements are left in a valid but unspecified state. Time complexity: O(n). Link: https://en.cppreference.com/w/cpp/algorithm/move"
  },

  "cpp_algorithm__fill_fill_n": {
    "prefix": "cpp_algorithm__fill_fill_n",
    "body": [
      "// std::fill, std::fill_n - Fill range with value",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/fill",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "std::vector<int> vec(10);",
      "",
      "// fill: Fill entire range with value",
      "std::fill(vec.begin(), vec.end(), 42);",
      "// vec now contains: 42, 42, 42, 42, 42, 42, 42, 42, 42, 42",
      "",
      "// Fill subrange",
      "std::fill(vec.begin() + 2, vec.begin() + 5, 99);",
      "// vec now contains: 42, 42, 99, 99, 99, 42, 42, 42, 42, 42",
      "",
      "// fill_n: Fill n elements starting from iterator",
      "std::fill_n(vec.begin(), 3, 0);",
      "// vec now contains: 0, 0, 0, 99, 99, 42, 42, 42, 42, 42",
      "",
      "// fill_n returns iterator to element past the last filled",
      "auto it = std::fill_n(vec.begin() + 5, 2, 77);",
      "std::cout << \"Next element after filled: \" << *it << std::endl; // 42",
      "",
      "// Fill with custom objects",
      "struct Point { int x, y; };",
      "std::vector<Point> points(5);",
      "std::fill(points.begin(), points.end(), Point{10, 20});",
      "$0"
    ],
    "description": "Assigns the given value to elements in a range. fill assigns to all elements in [first, last). fill_n assigns to the first n elements starting at first. fill returns void, while fill_n returns an iterator one past the last element assigned. Time complexity: O(n) assignments. Link: https://en.cppreference.com/w/cpp/algorithm/fill"
  }
}
