{
  "cpp_concurrency__std_atomic_flag": {
    "prefix": "cpp_concurrency__std_atomic_flag",
    "body": [
      "// C++ Concurrency: std::atomic_flag (Simplest Atomic Type)",
      "// std::atomic_flag is the simplest, most primitive atomic type.",
      "// It's a boolean flag that supports only two operations: test_and_set and clear.",
      "// It's guaranteed to be lock-free.",
      "// Reference: https://en.cppreference.com/w/cpp/atomic/atomic_flag",
      "#include <iostream>",
      "#include <thread>",
      "#include <atomic>",
      "#include <vector>",
      "#include <chrono>",
      "",
      "std::atomic_flag lock_flag = ATOMIC_FLAG_INIT; // Must be initialized with ATOMIC_FLAG_INIT",
      "int shared_resource_flag = 0;",
      "",
      "void increment_with_atomic_flag() {",
      "    for (int i = 0; i < 10000; ++i) {",
      "        // Spin-lock using atomic_flag",
      "        while (lock_flag.test_and_set(std::memory_order_acquire)) {",
      "            // Loop while the flag is set (locked)",
      "            // std::this_thread::yield(); // Optional: yield to other threads to reduce busy-waiting",
      "        }",
      "        // Critical section",
      "        shared_resource_flag++;",
      "        lock_flag.clear(std::memory_order_release); // Release the lock",
      "    }",
      "}",
      "",
      "int main() {",
      "    std::cout << \"--- std::atomic_flag example (Spin-lock) ---\\n\";",
      "    std::vector<std::thread> threads;",
      "    for (int i = 0; i < 10; ++i) {",
      "        threads.emplace_back(increment_with_atomic_flag);",
      "    }",
      "",
      "    for (auto& t : threads) {",
      "        t.join();",
      "    }",
      "",
      "    // The final value should be exactly 10 * 10000 = 100000 due to atomicity.",
      "    std::cout << \"Final shared_resource_flag (should be 100000): \" << shared_resource_flag << \"\\n\";",
      "",
      "    std::cout << \"std::atomic_flag is lock-free: \" << std::boolalpha << lock_flag.is_lock_free() << \"\\n\";",
      "",
      "    std::cout << \"\\nMain thread finished.\\n\";",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ Concurrency: std::atomic_flag, the simplest atomic type, often used for spin-locks. Reference: https://en.cppreference.com/w/cpp/atomic/atomic_flag"
  },

  "cpp_concurrency__std_stop_token": {
    "prefix": "cpp_concurrency__std_stop_token",
    "body": [
      "// C++ Concurrency: std::stop_token, std::stop_source, std::stop_callback (C++20)",
      "// These classes provide a cooperative cancellation mechanism for threads.",
      "// std::stop_source: Creates and manages stop tokens.",
      "// std::stop_token: Allows checking if a stop has been requested.",
      "// std::stop_callback: Registers a callback to be executed when stop is requested.",
      "// Reference: https://en.cppreference.com/w/cpp/thread/stop_token",
      "// Reference: https://en.cppreference.com/w/cpp/thread/stop_source",
      "// Reference: https://en.cppreference.com/w/cpp/thread/stop_callback",
      "#include <iostream>",
      "#include <thread>",
      "#include <chrono>",
      "#include <stop_token>",
      "#include <vector>",
      "#include <functional>",
      "",
      "void worker_with_stop_token(std::stop_token st) {",
      "    int count = 0;",
      "    while (!st.stop_requested()) {",
      "        std::cout << \"  Worker \" << std::this_thread::get_id() << \": Working... \" << count++ << std::endl;",
      "        std::this_thread::sleep_for(std::chrono::milliseconds(200));",
      "    }",
      "    std::cout << \"  Worker \" << std::this_thread::get_id() << \": Stop requested, exiting.\\n\";",
      "}",
      "",
      "void worker_with_stop_callback(std::stop_token st) {",
      "    // Register a callback that will be invoked when stop is requested.",
      "    // The callback is executed on the thread that calls request_stop().",
      "    std::stop_callback cb(st, []{",
      "        std::cout << \"  [Callback] Stop callback invoked on thread: \" << std::this_thread::get_id() << std::endl;",
      "    });",
      "",
      "    int count = 0;",
      "    while (!st.stop_requested()) {",
      "        std::cout << \"  Worker with callback \" << std::this_thread::get_id() << \": Working... \" << count++ << std::endl;",
      "        std::this_thread::sleep_for(std::chrono::milliseconds(200));",
      "    }",
      "    std::cout << \"  Worker with callback \" << std::this_thread::get_id() << \": Stop requested, exiting.\\n\";",
      "}",
      "",
      "int main() {",
      "    std::cout << \"--- std::stop_token example ---\\n\";",
      "    // std::stop_source manages the stop state and creates stop_tokens.",
      "    std::stop_source stop_src1;",
      "    std::jthread t1(worker_with_stop_token, stop_src1.get_token()); // jthread automatically gets a stop_token",
      "    // Or, for std::thread:",
      "    // std::thread t1(worker_with_stop_token, stop_src1.get_token());",
      "",
      "    std::cout << \"Main thread: Waiting for 1 second before requesting stop for t1...\\n\";",
      "    std::this_thread::sleep_for(std::chrono::seconds(1));",
      "    stop_src1.request_stop(); // Request stop for all associated tokens",
      "    t1.join(); // Wait for t1 to finish",
      "    std::cout << \"t1 finished.\\n\\n\";",
      "",
      "    std::cout << \"--- std::stop_callback example ---\\n\";",
      "    std::stop_source stop_src2;",
      "    std::jthread t2(worker_with_stop_callback, stop_src2.get_token());",
      "",
      "    std::cout << \"Main thread: Waiting for 1 second before requesting stop for t2...\\n\";",
      "    std::this_thread::sleep_for(std::chrono::seconds(1));",
      "    stop_src2.request_stop(); // This will trigger the callback on the main thread (or the thread calling request_stop)",
      "    t2.join();",
      "    std::cout << \"t2 finished.\\n\\n\";",
      "",
      "    std::cout << \"Main thread finished.\\n\";",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ Concurrency: std::stop_token, std::stop_source, std::stop_callback (C++20) for cooperative thread cancellation. References: https://en.cppreference.com/w/cpp/thread/stop_token, https://en.cppreference.com/w/cpp/thread/stop_source, https://en.cppreference.com/w/cpp/thread/stop_callback"
  },

  "cpp_concurrency__std_semaphore": {
    "prefix": "cpp_concurrency__std_semaphore",
    "body": [
      "// C++ Concurrency: std::counting_semaphore and std::binary_semaphore (C++20)",
      "// Semaphores are synchronization primitives that control access to a common resource.",
      "// They maintain an internal counter, which is decremented by acquire() and incremented by release().",
      "// std::counting_semaphore: A general-purpose semaphore with an arbitrary counter.",
      "// std::binary_semaphore: A semaphore with a counter that is either 0 or 1 (like a mutex).",
      "// Reference: https://en.cppreference.com/w/cpp/thread/counting_semaphore",
      "#include <iostream>",
      "#include <thread>",
      "#include <vector>",
      "#include <semaphore>",
      "#include <chrono>",
      "",
      "// A counting semaphore initialized with 2, allowing 2 threads to access a resource concurrently.",
      "std::counting_semaphore<2> resource_semaphore(2); ",
      "",
      "void worker_counting_semaphore(int id) {",
      "    std::cout << \"Worker \" << id << \": Trying to acquire resource...\\n\";",
      "    resource_semaphore.acquire(); // Decrement counter, blocks if counter is 0",
      "    std::cout << \"Worker \" << id << \": Acquired resource. Working...\\n\";",
      "    std::this_thread::sleep_for(std::chrono::milliseconds(200 + id * 50)); // Simulate work",
      "    std::cout << \"Worker \" << id << \": Releasing resource.\\n\";",
      "    resource_semaphore.release(); // Increment counter",
      "}",
      "",
      "// A binary semaphore (like a mutex, but can be released by a different thread)",
      "std::binary_semaphore binary_sem(1); // Initialized with 1, allowing one access at a time",
      "int shared_binary_resource = 0;",
      "",
      "void worker_binary_semaphore(int id) {",
      "    std::cout << \"Binary Worker \" << id << \": Trying to acquire...\\n\";",
      "    binary_sem.acquire();",
      "    std::cout << \"Binary Worker \" << id << \": Acquired. shared_binary_resource = \" << ++shared_binary_resource << \"\\n\";",
      "    std::this_thread::sleep_for(std::chrono::milliseconds(100));",
      "    binary_sem.release();",
      "    std::cout << \"Binary Worker \" << id << \": Released.\\n\";",
      "}",
      "",
      "int main() {",
      "    std::cout << \"--- std::counting_semaphore example ---\\n\";",
      "    std::vector<std::thread> counting_threads;",
      "    for (int i = 0; i < 5; ++i) {",
      "        counting_threads.emplace_back(worker_counting_semaphore, i + 1);",
      "    }",
      "",
      "    for (auto& t : counting_threads) {",
      "        t.join();",
      "    }",
      "    std::cout << \"All counting semaphore workers finished.\\n\\n\";",
      "",
      "    std::cout << \"--- std::binary_semaphore example ---\\n\";",
      "    std::vector<std::thread> binary_threads;",
      "    for (int i = 0; i < 5; ++i) {",
      "        binary_threads.emplace_back(worker_binary_semaphore, i + 1);",
      "    }",
      "",
      "    for (auto& t : binary_threads) {",
      "        t.join();",
      "    }",
      "    std::cout << \"Final shared_binary_resource (should be 5): \" << shared_binary_resource << \"\\n\";",
      "    std::cout << \"All binary semaphore workers finished.\\n\";",
      "",
      "    std::cout << \"\\nMain thread finished.\\n\";",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ Concurrency: std::counting_semaphore and std::binary_semaphore (C++20) for resource control. Reference: https://en.cppreference.com/w/cpp/thread/counting_semaphore"
  }
}
