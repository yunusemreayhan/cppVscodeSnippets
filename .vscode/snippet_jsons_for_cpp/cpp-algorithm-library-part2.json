{
  "cpp_algorithm__transform": {
    "prefix": "cpp_algorithm__transform",
    "body": [
      "// std::transform - Apply operation to elements and store results",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/transform",
      "#include <algorithm>",
      "#include <vector>",
      "#include <string>",
      "#include <iostream>",
      "#include <cctype>",
      "",
      "std::vector<int> vec1 = {1, 2, 3, 4, 5};",
      "std::vector<int> vec2 = {10, 20, 30, 40, 50};",
      "std::vector<int> result(5);",
      "",
      "// Unary operation - square each element",
      "std::transform(vec1.begin(), vec1.end(), result.begin(),",
      "               [](int x) { return x * x; });",
      "// result: 1, 4, 9, 16, 25",
      "",
      "// Binary operation - add corresponding elements",
      "std::transform(vec1.begin(), vec1.end(), vec2.begin(), result.begin(),",
      "               [](int a, int b) { return a + b; });",
      "// result: 11, 22, 33, 44, 55",
      "",
      "// Transform in-place",
      "std::transform(vec1.begin(), vec1.end(), vec1.begin(),",
      "               [](int x) { return x * 2; });",
      "// vec1: 2, 4, 6, 8, 10",
      "",
      "// String transformation example",
      "std::string str = \"hello world\";",
      "std::transform(str.begin(), str.end(), str.begin(), ::toupper);",
      "// str: \"HELLO WORLD\"",
      "$0"
    ],
    "description": "Applies the given function to a range and stores the result in another range. The unary version applies a unary operation to each element. The binary version applies a binary operation to pairs of elements from two ranges. Returns an iterator to the element past the last element written. Time complexity: O(n) applications of the operation. Link: https://en.cppreference.com/w/cpp/algorithm/transform"
  },

  "cpp_algorithm__generate_generate_n": {
    "prefix": "cpp_algorithm__generate_generate_n",
    "body": [
      "// std::generate, std::generate_n - Fill range with generated values",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/generate",
      "#include <algorithm>",
      "#include <vector>",
      "#include <random>",
      "#include <iostream>",
      "",
      "// Random number generator",
      "std::random_device rd;",
      "std::mt19937 gen(rd());",
      "std::uniform_int_distribution<> dis(1, 100);",
      "",
      "std::vector<int> vec1(10);",
      "std::vector<int> vec2(10);",
      "",
      "// generate: Fill entire range with generated values",
      "std::generate(vec1.begin(), vec1.end(), [&]() { return dis(gen); });",
      "",
      "// generate_n: Fill n elements with generated values",
      "std::generate_n(vec2.begin(), 5, [&]() { return dis(gen); });",
      "",
      "// Generate sequence",
      "int counter = 0;",
      "std::generate(vec1.begin(), vec1.end(), [&counter]() { return counter++; });",
      "// vec1: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9",
      "",
      "// Generate Fibonacci sequence",
      "int a = 0, b = 1;",
      "std::generate_n(vec2.begin(), 10, [&]() {",
      "    int result = a;",
      "    int temp = a + b;",
      "    a = b;",
      "    b = temp;",
      "    return result;",
      "});",
      "// vec2: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34",
      "$0"
    ],
    "description": "Assigns the result of successive calls to a generator function to elements in a range. generate assigns to all elements in [first, last). generate_n assigns to the first n elements. The generator is called once for each element. Time complexity: O(n) invocations of the generator. Link: https://en.cppreference.com/w/cpp/algorithm/generate"
  },

  "cpp_algorithm__remove_remove_if": {
    "prefix": "cpp_algorithm__remove_remove_if",
    "body": [
      "// std::remove, std::remove_if - Remove elements from range",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/remove",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "std::vector<int> vec = {1, 2, 3, 2, 5, 2, 6, 2};",
      "",
      "// remove: Remove all occurrences of value",
      "// Note: doesn't actually erase elements, just moves them to the end",
      "auto new_end = std::remove(vec.begin(), vec.end(), 2);",
      "vec.erase(new_end, vec.end()); // Actually erase the removed elements",
      "// vec now contains: 1, 3, 5, 6",
      "",
      "// remove_if: Remove elements satisfying predicate",
      "std::vector<int> vec2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};",
      "auto new_end2 = std::remove_if(vec2.begin(), vec2.end(),",
      "                               [](int x) { return x % 2 == 0; });",
      "vec2.erase(new_end2, vec2.end());",
      "// vec2 now contains: 1, 3, 5, 7, 9",
      "",
      "// Remove-erase idiom in one line",
      "vec.erase(std::remove(vec.begin(), vec.end(), 3), vec.end());",
      "",
      "// Remove with custom objects",
      "struct Person { std::string name; int age; };",
      "std::vector<Person> people = {{\"Alice\", 30}, {\"Bob\", 25}, {\"Carol\", 35}};",
      "people.erase(",
      "    std::remove_if(people.begin(), people.end(),",
      "                   [](const Person& p) { return p.age < 30; }),",
      "    people.end());",
      "$0"
    ],
    "description": "Removes elements equal to value (remove) or satisfying a predicate (remove_if) by moving elements to preserve relative order of remaining elements. Returns an iterator to the new end of the range. Elements between the new end and the old end have unspecified values. Typically used with container's erase method (remove-erase idiom). Time complexity: O(n) comparisons. Link: https://en.cppreference.com/w/cpp/algorithm/remove"
  },

  "cpp_algorithm__remove_copy_remove_copy_if": {
    "prefix": "cpp_algorithm__remove_copy_remove_copy_if",
    "body": [
      "// std::remove_copy, std::remove_copy_if - Copy elements except those to remove",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/remove_copy",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "#include <iterator>",
      "",
      "std::vector<int> source = {1, 2, 3, 2, 5, 2, 6, 2};",
      "std::vector<int> dest;",
      "",
      "// remove_copy: Copy all except specified value",
      "std::remove_copy(source.begin(), source.end(),",
      "                 std::back_inserter(dest), 2);",
      "// dest contains: 1, 3, 5, 6",
      "",
      "// remove_copy_if: Copy all except those satisfying predicate",
      "std::vector<int> source2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};",
      "std::vector<int> dest2;",
      "",
      "std::remove_copy_if(source2.begin(), source2.end(),",
      "                    std::back_inserter(dest2),",
      "                    [](int x) { return x % 2 == 0; });",
      "// dest2 contains: 1, 3, 5, 7, 9",
      "",
      "// Copy to output stream, removing vowels",
      "std::string text = \"Hello World\";",
      "std::remove_copy_if(text.begin(), text.end(),",
      "                    std::ostream_iterator<char>(std::cout),",
      "                    [](char c) {",
      "                        return std::string(\"aeiouAEIOU\").find(c) != std::string::npos;",
      "                    });",
      "// Output: \"Hll Wrld\"",
      "$0"
    ],
    "description": "Copies elements from the source range to the destination range, omitting elements equal to value (remove_copy) or satisfying a predicate (remove_copy_if). The relative order of elements that are not removed is preserved. Returns an iterator to the element past the last element copied. Time complexity: O(n) comparisons. Link: https://en.cppreference.com/w/cpp/algorithm/remove_copy"
  },

  "cpp_algorithm__replace_replace_if": {
    "prefix": "cpp_algorithm__replace_replace_if",
    "body": [
      "// std::replace, std::replace_if - Replace elements in range",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/replace",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "std::vector<int> vec = {1, 2, 3, 2, 5, 2, 6, 2};",
      "",
      "// replace: Replace all occurrences of old_value with new_value",
      "std::replace(vec.begin(), vec.end(), 2, 99);",
      "// vec now contains: 1, 99, 3, 99, 5, 99, 6, 99",
      "",
      "// replace_if: Replace elements satisfying predicate",
      "std::vector<int> vec2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};",
      "std::replace_if(vec2.begin(), vec2.end(),",
      "                [](int x) { return x > 5; }, 0);",
      "// vec2 now contains: 1, 2, 3, 4, 5, 0, 0, 0, 0, 0",
      "",
      "// Replace negative values with zero",
      "std::vector<int> data = {5, -3, 2, -1, 8, -4, 7};",
      "std::replace_if(data.begin(), data.end(),",
      "                [](int x) { return x < 0; }, 0);",
      "// data now contains: 5, 0, 2, 0, 8, 0, 7",
      "",
      "// Replace with calculation",
      "std::replace_if(vec2.begin(), vec2.end(),",
      "                [](int x) { return x % 2 == 0; }, -1);",
      "$0"
    ],
    "description": "Replaces all elements equal to old_value with new_value (replace) or all elements satisfying a predicate with new_value (replace_if). Modifies elements in-place. Time complexity: O(n) comparisons. Link: https://en.cppreference.com/w/cpp/algorithm/replace"
  },

  "cpp_algorithm__replace_copy_replace_copy_if": {
    "prefix": "cpp_algorithm__replace_copy_replace_copy_if",
    "body": [
      "// std::replace_copy, std::replace_copy_if - Copy with replacements",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/replace_copy",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "#include <iterator>",
      "",
      "std::vector<int> source = {1, 2, 3, 2, 5, 2, 6, 2};",
      "std::vector<int> dest(source.size());",
      "",
      "// replace_copy: Copy with specific value replaced",
      "std::replace_copy(source.begin(), source.end(),",
      "                  dest.begin(), 2, 99);",
      "// dest contains: 1, 99, 3, 99, 5, 99, 6, 99",
      "",
      "// replace_copy_if: Copy with conditional replacement",
      "std::vector<int> source2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};",
      "std::vector<int> dest2;",
      "",
      "std::replace_copy_if(source2.begin(), source2.end(),",
      "                     std::back_inserter(dest2),",
      "                     [](int x) { return x % 2 == 0; }, 0);",
      "// dest2 contains: 1, 0, 3, 0, 5, 0, 7, 0, 9, 0",
      "",
      "// Censor bad words example",
      "std::vector<std::string> words = {\"good\", \"bad\", \"nice\", \"ugly\", \"great\"};",
      "std::vector<std::string> censored;",
      "",
      "std::replace_copy_if(words.begin(), words.end(),",
      "                     std::back_inserter(censored),",
      "                     [](const std::string& s) {",
      "                         return s == \"bad\" || s == \"ugly\";",
      "                     }, \"****\");",
      "$0"
    ],
    "description": "Copies elements from source range to destination range, replacing elements equal to old_value with new_value (replace_copy) or elements satisfying a predicate with new_value (replace_copy_if). Source range is not modified. Returns an iterator to the element past the last element copied. Time complexity: O(n) comparisons. Link: https://en.cppreference.com/w/cpp/algorithm/replace_copy"
  },

  "cpp_algorithm__swap_swap_ranges_iter_swap": {
    "prefix": "cpp_algorithm__swap_swap_ranges_iter_swap",
    "body": [
      "// std::swap, std::swap_ranges, std::iter_swap - Swap elements",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/swap",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "// std::swap - swap two objects",
      "int a = 5, b = 10;",
      "std::swap(a, b);",
      "// Now a = 10, b = 5",
      "",
      "// std::swap_ranges - swap two ranges",
      "std::vector<int> vec1 = {1, 2, 3, 4, 5};",
      "std::vector<int> vec2 = {6, 7, 8, 9, 10};",
      "",
      "std::swap_ranges(vec1.begin(), vec1.begin() + 3, vec2.begin());",
      "// vec1: 6, 7, 8, 4, 5",
      "// vec2: 1, 2, 3, 9, 10",
      "",
      "// std::iter_swap - swap values pointed to by two iterators",
      "auto it1 = vec1.begin() + 1;",
      "auto it2 = vec1.begin() + 3;",
      "std::iter_swap(it1, it2);",
      "// Swaps vec1[1] and vec1[3]",
      "",
      "// Practical example: reverse array manually",
      "std::vector<int> arr = {1, 2, 3, 4, 5};",
      "for (size_t i = 0; i < arr.size() / 2; ++i) {",
      "    std::iter_swap(arr.begin() + i, arr.end() - 1 - i);",
      "}",
      "// arr: 5, 4, 3, 2, 1",
      "$0"
    ],
    "description": "Swaps values of objects or ranges. std::swap exchanges values of two objects. swap_ranges exchanges elements between two ranges. iter_swap exchanges values pointed to by two iterators. All operations use move semantics when possible. Time complexity: O(1) for swap and iter_swap, O(n) for swap_ranges. Link: https://en.cppreference.com/w/cpp/algorithm/swap"
  },

  "cpp_algorithm__reverse_reverse_copy": {
    "prefix": "cpp_algorithm__reverse_reverse_copy",
    "body": [
      "// std::reverse, std::reverse_copy - Reverse order of elements",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/reverse",
      "#include <algorithm>",
      "#include <vector>",
      "#include <string>",
      "#include <iostream>",
      "",
      "// reverse: Reverse in-place",
      "std::vector<int> vec = {1, 2, 3, 4, 5};",
      "std::reverse(vec.begin(), vec.end());",
      "// vec: 5, 4, 3, 2, 1",
      "",
      "// Reverse substring",
      "std::string str = \"Hello World\";",
      "std::reverse(str.begin(), str.begin() + 5);",
      "// str: \"olleH World\"",
      "",
      "// reverse_copy: Copy in reversed order",
      "std::vector<int> source = {1, 2, 3, 4, 5};",
      "std::vector<int> dest(source.size());",
      "",
      "std::reverse_copy(source.begin(), source.end(), dest.begin());",
      "// dest: 5, 4, 3, 2, 1",
      "// source unchanged",
      "",
      "// Check if palindrome",
      "std::string text = \"racecar\";",
      "std::string reversed;",
      "reversed.reserve(text.size());",
      "std::reverse_copy(text.begin(), text.end(), std::back_inserter(reversed));",
      "bool is_palindrome = (text == reversed);",
      "$0"
    ],
    "description": "Reverses the order of elements in a range. reverse modifies the range in-place by swapping elements. reverse_copy copies elements to a destination range in reverse order without modifying the source. Time complexity: O(n/2) swaps for reverse, O(n) assignments for reverse_copy. Link: https://en.cppreference.com/w/cpp/algorithm/reverse"
  },

  "cpp_algorithm__rotate_rotate_copy": {
    "prefix": "cpp_algorithm__rotate_rotate_copy",
    "body": [
      "// std::rotate, std::rotate_copy - Rotate elements in range",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/rotate",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "// rotate: Rotate left so that n_first becomes the first element",
      "std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8};",
      "",
      "// Rotate left by 3 positions",
      "std::rotate(vec.begin(), vec.begin() + 3, vec.end());",
      "// vec: 4, 5, 6, 7, 8, 1, 2, 3",
      "",
      "// Rotate right by 2 positions (rotate left by size-2)",
      "std::vector<int> vec2 = {1, 2, 3, 4, 5};",
      "std::rotate(vec2.begin(), vec2.end() - 2, vec2.end());",
      "// vec2: 4, 5, 1, 2, 3",
      "",
      "// rotate_copy: Copy with rotation",
      "std::vector<int> source = {1, 2, 3, 4, 5};",
      "std::vector<int> dest(source.size());",
      "",
      "std::rotate_copy(source.begin(), source.begin() + 2, source.end(), dest.begin());",
      "// dest: 3, 4, 5, 1, 2",
      "",
      "// Practical example: move element to front",
      "auto it = std::find(vec.begin(), vec.end(), 6);",
      "if (it != vec.end()) {",
      "    std::rotate(vec.begin(), it, it + 1);",
      "}",
      "// Moves 6 to the front",
      "$0"
    ],
    "description": "Rotates elements in a range such that the element at n_first becomes the new first element. rotate performs left rotation in-place. rotate_copy copies elements to a destination range with rotation. Returns iterator to the new position of the first element. Time complexity: O(n) for both algorithms. Link: https://en.cppreference.com/w/cpp/algorithm/rotate"
  },

  "cpp_algorithm__unique_unique_copy": {
    "prefix": "cpp_algorithm__unique_unique_copy",
    "body": [
      "// std::unique, std::unique_copy - Remove consecutive duplicates",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/unique",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "// unique: Remove consecutive duplicates in-place",
      "std::vector<int> vec = {1, 1, 2, 2, 2, 3, 3, 4, 5, 5};",
      "",
      "auto new_end = std::unique(vec.begin(), vec.end());",
      "vec.erase(new_end, vec.end());",
      "// vec: 1, 2, 3, 4, 5",
      "",
      "// unique with custom predicate",
      "std::vector<int> vec2 = {1, 3, 3, 7, 7, 8, 10, 10};",
      "auto new_end2 = std::unique(vec2.begin(), vec2.end(),",
      "                           [](int a, int b) { return b == a + 1; });",
      "vec2.erase(new_end2, vec2.end());",
      "",
      "// unique_copy: Copy without consecutive duplicates",
      "std::vector<int> source = {1, 1, 2, 2, 2, 3, 3, 4, 5, 5};",
      "std::vector<int> dest;",
      "",
      "std::unique_copy(source.begin(), source.end(), std::back_inserter(dest));",
      "// dest: 1, 2, 3, 4, 5",
      "",
      "// Remove all duplicates (not just consecutive)",
      "std::vector<int> data = {3, 1, 4, 1, 5, 9, 2, 6, 5};",
      "std::sort(data.begin(), data.end()); // Sort first",
      "data.erase(std::unique(data.begin(), data.end()), data.end());",
      "// data: 1, 2, 3, 4, 5, 6, 9",
      "$0"
    ],
    "description": "Eliminates consecutive duplicate elements from a range. unique removes consecutive duplicates in-place and returns iterator to new end. unique_copy copies elements to destination omitting consecutive duplicates. Elements are compared using operator== or given predicate. Often used after sort to remove all duplicates. Time complexity: O(n) comparisons. Link: https://en.cppreference.com/w/cpp/algorithm/unique"
  },

  "cpp_algorithm__partition_stable_partition": {
    "prefix": "cpp_algorithm__partition_stable_partition",
    "body": [
      "// std::partition, std::stable_partition - Partition range by predicate",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/partition",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "// partition: Reorder so elements satisfying predicate come first",
      "std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};",
      "",
      "auto pivot = std::partition(vec.begin(), vec.end(),",
      "                           [](int x) { return x % 2 == 0; });",
      "// All even numbers before pivot, odd numbers after",
      "// Order within each partition is not guaranteed",
      "",
      "std::cout << \"Even numbers: \";",
      "std::for_each(vec.begin(), pivot, [](int n) { std::cout << n << \" \"; });",
      "std::cout << \"\\nOdd numbers: \";",
      "std::for_each(pivot, vec.end(), [](int n) { std::cout << n << \" \"; });",
      "",
      "// stable_partition: Maintains relative order within partitions",
      "std::vector<int> vec2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};",
      "",
      "auto pivot2 = std::stable_partition(vec2.begin(), vec2.end(),",
      "                                   [](int x) { return x > 5; });",
      "// Elements > 5 come first, maintaining their relative order",
      "// Result: 6, 7, 8, 9, 10, 1, 2, 3, 4, 5",
      "",
      "// Practical example: separate positive and negative",
      "std::vector<int> numbers = {-5, 3, -2, 7, -1, 4, -8, 6};",
      "std::stable_partition(numbers.begin(), numbers.end(),",
      "                     [](int x) { return x >= 0; });",
      "// Result: 3, 7, 4, 6, -5, -2, -1, -8",
      "$0"
    ],
    "description": "Reorders elements so that elements satisfying the predicate appear before those that don't. partition may reorder elements within each group. stable_partition maintains the relative order of elements within each group. Returns iterator to first element of second group. Time complexity: O(n) for partition, O(n log n) for stable_partition. Link: https://en.cppreference.com/w/cpp/algorithm/partition"
  },

  "cpp_algorithm__sort_stable_sort_partial_sort": {
    "prefix": "cpp_algorithm__sort_stable_sort_partial_sort",
    "body": [
      "// std::sort, std::stable_sort, std::partial_sort - Sort elements",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/sort",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "#include <functional>",
      "",
      "// sort: Sort entire range (typically introsort)",
      "std::vector<int> vec = {3, 1, 4, 1, 5, 9, 2, 6, 5};",
      "std::sort(vec.begin(), vec.end());",
      "// vec: 1, 1, 2, 3, 4, 5, 5, 6, 9",
      "",
      "// Sort in descending order",
      "std::sort(vec.begin(), vec.end(), std::greater<int>());",
      "// vec: 9, 6, 5, 5, 4, 3, 2, 1, 1",
      "",
      "// Sort with custom comparison",
      "struct Person { std::string name; int age; };",
      "std::vector<Person> people = {{\"Alice\", 30}, {\"Bob\", 25}, {\"Carol\", 35}};",
      "",
      "std::sort(people.begin(), people.end(),",
      "          [](const Person& a, const Person& b) { return a.age < b.age; });",
      "",
      "// stable_sort: Maintains relative order of equal elements",
      "std::vector<std::pair<int, char>> pairs = {{1,'a'}, {2,'b'}, {1,'c'}, {2,'d'}};",
      "std::stable_sort(pairs.begin(), pairs.end(),",
      "                [](const auto& a, const auto& b) { return a.first < b.first; });",
      "// Maintains order of elements with same first value",
      "",
      "// partial_sort: Sort only first n elements",
      "std::vector<int> scores = {85, 92, 78, 95, 88, 73, 91, 87, 90};",
      "std::partial_sort(scores.begin(), scores.begin() + 3, scores.end(),",
      "                 std::greater<int>());",
      "// First 3 elements are the 3 highest: 95, 92, 91",
      "// Rest are unspecified order",
      "$0"
    ],
    "description": "Sorts elements in ascending order. sort uses introsort (quicksort + heapsort + insertion sort). stable_sort maintains relative order of equivalent elements. partial_sort sorts only the first n elements. All accept custom comparison functions. Time complexity: O(n log n) average for sort, O(n log n) for stable_sort, O(n log m) for partial_sort where m is number of sorted elements. Link: https://en.cppreference.com/w/cpp/algorithm/sort"
  },

  "cpp_algorithm__nth_element": {
    "prefix": "cpp_algorithm__nth_element",
    "body": [
      "// std::nth_element - Partial sorting algorithm",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/nth_element",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "std::vector<int> vec = {5, 2, 8, 1, 9, 3, 7, 4, 6};",
      "",
      "// Find the median (5th element when sorted)",
      "std::nth_element(vec.begin(), vec.begin() + 4, vec.end());",
      "std::cout << \"Median: \" << vec[4] << std::endl; // 5",
      "// Elements before vec[4] are <= vec[4]",
      "// Elements after vec[4] are >= vec[4]",
      "",
      "// Find the 3 smallest elements",
      "std::nth_element(vec.begin(), vec.begin() + 2, vec.end());",
      "// First 3 elements are the 3 smallest (order not specified)",
      "",
      "// Find kth largest element",
      "int k = 3; // Find 3rd largest",
      "std::nth_element(vec.begin(), vec.end() - k, vec.end());",
      "std::cout << k << \"rd largest: \" << vec[vec.size() - k] << std::endl;",
      "",
      "// With custom comparison",
      "std::nth_element(vec.begin(), vec.begin() + 4, vec.end(),",
      "                std::greater<int>());",
      "// Now vec[4] is the 5th largest element",
      "$0"
    ],
    "description": "Rearranges elements so that the element at the nth position is the element that would be in that position if the range was sorted. All elements before nth are less than or equal to the elements after nth. Useful for finding medians or kth smallest/largest elements. Time complexity: O(n) on average. Link: https://en.cppreference.com/w/cpp/algorithm/nth_element"
  },

  "cpp_algorithm__binary_search_lower_bound_upper_bound": {
    "prefix": "cpp_algorithm__binary_search_lower_bound_upper_bound",
    "body": [
      "// std::binary_search, std::lower_bound, std::upper_bound - Binary search operations",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/binary_search",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "std::vector<int> vec = {1, 2, 4, 4, 4, 6, 7, 9};",
      "// Note: vector must be sorted for binary search operations",
      "",
      "// binary_search: Check if value exists",
      "bool found = std::binary_search(vec.begin(), vec.end(), 4);",
      "std::cout << \"4 exists: \" << found << std::endl; // true",
      "",
      "// lower_bound: First position where value could be inserted",
      "auto lower = std::lower_bound(vec.begin(), vec.end(), 4);",
      "std::cout << \"Lower bound of 4 at position: \"",
      "          << std::distance(vec.begin(), lower) << std::endl; // 2",
      "",
      "// upper_bound: Last position where value could be inserted",
      "auto upper = std::upper_bound(vec.begin(), vec.end(), 4);",
      "std::cout << \"Upper bound of 4 at position: \"",
      "          << std::distance(vec.begin(), upper) << std::endl; // 5",
      "",
      "// Count occurrences of value",
      "auto count = std::distance(lower, upper);",
      "std::cout << \"Count of 4: \" << count << std::endl; // 3",
      "",
      "// equal_range: Get both bounds at once",
      "auto range = std::equal_range(vec.begin(), vec.end(), 4);",
      "std::cout << \"Range: [\" << std::distance(vec.begin(), range.first)",
      "          << \", \" << std::distance(vec.begin(), range.second) << \")\\n\";",
      "",
      "// Insert in sorted position",
      "int value = 5;",
      "vec.insert(std::upper_bound(vec.begin(), vec.end(), value), value);",
      "$0"
    ],
    "description": "Binary search operations on sorted ranges. binary_search returns true if value is found. lower_bound returns iterator to first element not less than value. upper_bound returns iterator to first element greater than value. equal_range returns both bounds. All require sorted input. Time complexity: O(log n) comparisons. Link: https://en.cppreference.com/w/cpp/algorithm/binary_search"
  },

  "cpp_algorithm__merge_inplace_merge": {
    "prefix": "cpp_algorithm__merge_inplace_merge",
    "body": [
      "// std::merge, std::inplace_merge - Merge sorted sequences",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/merge",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "// merge: Merge two sorted ranges into a third",
      "std::vector<int> vec1 = {1, 3, 5, 7, 9};",
      "std::vector<int> vec2 = {2, 4, 6, 8, 10};",
      "std::vector<int> result(vec1.size() + vec2.size());",
      "",
      "std::merge(vec1.begin(), vec1.end(),",
      "          vec2.begin(), vec2.end(),",
      "          result.begin());",
      "// result: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10",
      "",
      "// Merge with custom comparison",
      "std::merge(vec1.begin(), vec1.end(),",
      "          vec2.begin(), vec2.end(),",
      "          result.begin(), std::greater<int>());",
      "",
      "// inplace_merge: Merge two consecutive sorted ranges",
      "std::vector<int> vec = {1, 3, 5, 7, 9, 2, 4, 6, 8, 10};",
      "// First half [0, 5) and second half [5, 10) are sorted",
      "",
      "std::inplace_merge(vec.begin(), vec.begin() + 5, vec.end());",
      "// vec: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10",
      "",
      "// Practical example: merge sort implementation",
      "void merge_sort(std::vector<int>::iterator first, std::vector<int>::iterator last) {",
      "    if (last - first > 1) {",
      "        auto middle = first + (last - first) / 2;",
      "        merge_sort(first, middle);",
      "        merge_sort(middle, last);",
      "        std::inplace_merge(first, middle, last);",
      "    }",
      "}",
      "$0"
    ],
    "description": "Merges sorted sequences. merge combines two sorted ranges into a third sorted range. inplace_merge merges two consecutive sorted ranges in-place. Both maintain the relative order of equivalent elements (stable). Requires pre-sorted input ranges. Time complexity: O(n+m) for merge, O(n log n) for inplace_merge. Link: https://en.cppreference.com/w/cpp/algorithm/merge"
  },

  "cpp_algorithm__includes_set_operations": {
    "prefix": "cpp_algorithm__includes_set_operations",
    "body": [
      "// Set operations: includes, set_difference, set_intersection, set_union, set_symmetric_difference",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/includes",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "#include <iterator>",
      "",
      "std::vector<int> set1 = {1, 2, 3, 4, 5, 6, 7, 8};",
      "std::vector<int> set2 = {3, 4, 5, 9, 10};",
      "std::vector<int> result;",
      "",
      "// includes: Check if set2 is subset of set1",
      "bool is_subset = std::includes(set1.begin(), set1.end(),",
      "                              set2.begin(), set2.end());",
      "std::cout << \"set2 subset of set1: \" << is_subset << std::endl; // false",
      "",
      "// set_difference: Elements in set1 but not in set2",
      "std::set_difference(set1.begin(), set1.end(),",
      "                   set2.begin(), set2.end(),",
      "                   std::back_inserter(result));",
      "// result: 1, 2, 6, 7, 8",
      "",
      "// set_intersection: Elements in both sets",
      "result.clear();",
      "std::set_intersection(set1.begin(), set1.end(),",
      "                     set2.begin(), set2.end(),",
      "                     std::back_inserter(result));",
      "// result: 3, 4, 5",
      "",
      "// set_union: Elements in either set",
      "result.clear();",
      "std::set_union(set1.begin(), set1.end(),",
      "              set2.begin(), set2.end(),",
      "              std::back_inserter(result));",
      "// result: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10",
      "",
      "// set_symmetric_difference: Elements in either set but not both",
      "result.clear();",
      "std::set_symmetric_difference(set1.begin(), set1.end(),",
      "                             set2.begin(), set2.end(),",
      "                             std::back_inserter(result));",
      "// result: 1, 2, 6, 7, 8, 9, 10",
      "$0"
    ],
    "description": "Set operations on sorted ranges. includes tests if one set is a subset of another. set_difference computes elements in first set but not in second. set_intersection computes common elements. set_union computes all unique elements. set_symmetric_difference computes elements in either set but not both. All require sorted inputs. Time complexity: O(n+m). Link: https://en.cppreference.com/w/cpp/algorithm/includes"
  },

  "cpp_algorithm__heap_operations": {
    "prefix": "cpp_algorithm__heap_operations",
    "body": [
      "// Heap operations: make_heap, push_heap, pop_heap, sort_heap",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/make_heap",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "std::vector<int> vec = {3, 1, 4, 1, 5, 9, 2, 6};",
      "",
      "// make_heap: Convert range into a max heap",
      "std::make_heap(vec.begin(), vec.end());",
      "// vec is now a valid max heap with largest element at front",
      "std::cout << \"Max element: \" << vec.front() << std::endl; // 9",
      "",
      "// push_heap: Add element to heap",
      "vec.push_back(7); // Add to end",
      "std::push_heap(vec.begin(), vec.end()); // Restore heap property",
      "",
      "// pop_heap: Remove largest element",
      "std::pop_heap(vec.begin(), vec.end()); // Move largest to end",
      "int largest = vec.back();",
      "vec.pop_back(); // Actually remove it",
      "std::cout << \"Removed: \" << largest << std::endl;",
      "",
      "// sort_heap: Sort a heap",
      "std::sort_heap(vec.begin(), vec.end());",
      "// vec is now sorted in ascending order",
      "",
      "// Min heap using custom comparison",
      "std::vector<int> min_heap = {3, 1, 4, 1, 5, 9, 2, 6};",
      "std::make_heap(min_heap.begin(), min_heap.end(), std::greater<int>());",
      "std::cout << \"Min element: \" << min_heap.front() << std::endl; // 1",
      "",
      "// is_heap: Check if range is a heap",
      "bool is_valid = std::is_heap(vec.begin(), vec.end());",
      "",
      "// is_heap_until: Find first element breaking heap property",
      "auto heap_end = std::is_heap_until(vec.begin(), vec.end());",
      "$0"
    ],
    "description": "Heap operations for creating and manipulating binary heaps. make_heap creates a heap from a range. push_heap inserts element into heap. pop_heap removes largest element. sort_heap sorts a heap. is_heap checks if range is a valid heap. Default creates max heap, use greater<> for min heap. Time complexity: O(n) for make_heap, O(log n) for push/pop_heap, O(n log n) for sort_heap. Link: https://en.cppreference.com/w/cpp/algorithm/make_heap"
  }
}
