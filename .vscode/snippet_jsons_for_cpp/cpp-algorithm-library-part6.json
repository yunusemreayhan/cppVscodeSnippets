{
  "cpp_raw_memory__uninitialized_copy": {
    "prefix": "cpp_raw_memory__uninitialized_copy",
    "body": [
      "// std::uninitialized_copy - Copy elements to uninitialized memory (C++11)",
      "// Reference: https://en.cppreference.com/w/cpp/memory/uninitialized_copy",
      "#include <memory>",
      "#include <vector>",
      "#include <iostream>",
      "#include <string>",
      "",
      "// Example with integers",
      "std::vector<int> source = {1, 2, 3, 4, 5};",
      "// Allocate raw memory for 5 integers",
      "int* dest_raw = static_cast<int*>(::operator new(sizeof(int) * source.size()));",
      "",
      "try {",
      "    // Copy elements from source to uninitialized dest_raw",
      "    // This constructs elements in dest_raw using copy constructor",
      "    std::uninitialized_copy(source.begin(), source.end(), dest_raw);",
      "",
      "    std::cout << \"Copied integers: \";",
      "    for (size_t i = 0; i < source.size(); ++i) {",
      "        std::cout << dest_raw[i] << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "",
      "} catch (...) {",
      "    // Handle exceptions during construction",
      "}",
      "",
      "// Remember to destroy objects and deallocate memory",
      "for (size_t i = 0; i < source.size(); ++i) {",
      "    std::destroy_at(dest_raw + i); // C++17",
      "}",
      "::operator delete(dest_raw, sizeof(int) * source.size());",
      "",
      "// Example with strings (more complex objects)",
      "std::vector<std::string> str_source = {\"hello\", \"world\", \"cpp\"};",
      "std::string* str_dest_raw = static_cast<std::string*>(::operator new(sizeof(std::string) * str_source.size()));",
      "",
      "try {",
      "    std::uninitialized_copy(str_source.begin(), str_source.end(), str_dest_raw);",
      "",
      "    std::cout << \"Copied strings: \";",
      "    for (size_t i = 0; i < str_source.size(); ++i) {",
      "        std::cout << str_dest_raw[i] << \" \";",
      "    }",
      "    std::cout << std::endl;",
      "",
      "} catch (...) {",
      "    // Proper cleanup in case of exception during construction",
      "    // Need to destroy already constructed objects before rethrowing",
      "    for (size_t i = 0; i < str_source.size(); ++i) {",
      "        std::destroy_at(str_dest_raw + i);",
      "    }",
      "}",
      "for (size_t i = 0; i < str_source.size(); ++i) {",
      "    std::destroy_at(str_dest_raw + i);",
      "}",
      "::operator delete(str_dest_raw, sizeof(std::string) * str_source.size());",
      "$0"
    ],
    "description": "Copies elements from a source range to a destination range of uninitialized memory. It constructs new objects in the destination using the copy constructor. Useful for placement new scenarios or custom memory management. Time complexity: O(n) copy constructions. Link: https://en.cppreference.com/w/cpp/memory/uninitialized_copy"
  },
  "cpp_raw_memory__uninitialized_fill": {
    "prefix": "cpp_raw_memory__uninitialized_fill",
    "body": [
      "// std::uninitialized_fill - Fill uninitialized memory with copies of a value (C++11)",
      "// Reference: https://en.cppreference.com/w/cpp/memory/uninitialized_fill",
      "#include <memory>",
      "#include <vector>",
      "#include <iostream>",
      "#include <string>",
      "",
      "// Allocate raw memory for 5 strings",
      "std::string* str_raw = static_cast<std::string*>(::operator new(sizeof(std::string) * 5));",
      "",
      "try {",
      "    // Fill uninitialized memory with copies of \"test\"",
      "    std::uninitialized_fill(str_raw, str_raw + 5, std::string(\"test\"));",
      "",
      "    std::cout << \"Filled strings: \";",
      "    for (size_t i = 0; i < 5; ++i) {",
      "        std::cout << str_raw[i] << \" \";",
      "    }",
      "    std::cout << std::endl; // Filled strings: test test test test test",
      "",
      "} catch (...) {",
      "    // Proper cleanup in case of exception during construction",
      "    // Need to destroy already constructed objects before rethrowing",
      "    // (This example is simplified; real code needs to track constructed count)",
      "}",
      "",
      "// Remember to destroy objects and deallocate memory",
      "for (size_t i = 0; i < 5; ++i) {",
      "    std::destroy_at(str_raw + i); // C++17",
      "}",
      "::operator delete(str_raw, sizeof(std::string) * 5);",
      "",
      "// Example with integers (trivial type, no special construction needed)",
      "int* int_raw = static_cast<int*>(::operator new(sizeof(int) * 3));",
      "std::uninitialized_fill(int_raw, int_raw + 3, 42);",
      "std::cout << \"Filled integers: \";",
      "for (size_t i = 0; i < 3; ++i) {",
      "    std::cout << int_raw[i] << \" \";",
      "}",
      "std::cout << std::endl; // Filled integers: 42 42 42",
      "::operator delete(int_raw, sizeof(int) * 3);",
      "$0"
    ],
    "description": "Fills a range of uninitialized memory with copies of a provided value. It constructs new objects in the destination using the copy constructor. Useful for initializing raw memory buffers. Time complexity: O(n) copy constructions. Link: https://en.cppreference.com/w/cpp/memory/uninitialized_fill"
  },
  "cpp_raw_memory__uninitialized_move": {
    "prefix": "cpp_raw_memory__uninitialized_move",
    "body": [
      "// std::uninitialized_move - Move elements to uninitialized memory (C++11)",
      "// Reference: https://en.cppreference.com/w/cpp/memory/uninitialized_move",
      "#include <memory>",
      "#include <vector>",
      "#include <iostream>",
      "#include <string>",
      "",
      "// Example with strings",
      "std::vector<std::string> source = {\"apple\", \"banana\", \"cherry\"};",
      "// Allocate raw memory for 3 strings",
      "std::string* dest_raw = static_cast<std::string*>(::operator new(sizeof(std::string) * source.size()));",
      "",
      "std::cout << \"Original source: \";",
      "for (const auto& s : source) std::cout << \"'\" << s << \"' \";",
      "std::cout << std::endl;",
      "",
      "try {",
      "    // Move elements from source to uninitialized dest_raw",
      "    // This constructs elements in dest_raw using move constructor",
      "    std::uninitialized_move(source.begin(), source.end(), dest_raw);",
      "",
      "    std::cout << \"Moved strings to raw memory: \";",
      "    for (size_t i = 0; i < source.size(); ++i) {",
      "        std::cout << \"'\" << dest_raw[i] << \"' \";",
      "    }",
      "    std::cout << std::endl; // Moved strings to raw memory: 'apple' 'banana' 'cherry'",
      "",
      "    // Source elements are now in a valid but unspecified state (often empty)",
      "    std::cout << \"Source after move: \";",
      "    for (const auto& s : source) std::cout << \"'\" << s << \"' \";",
      "    std::cout << std::endl; // Source after move: '' '' '' (or similar)",
      "",
      "} catch (...) {",
      "    // Proper cleanup in case of exception during construction",
      "    // Need to destroy already constructed objects before rethrowing",
      "}",
      "",
      "// Remember to destroy objects and deallocate memory",
      "for (size_t i = 0; i < source.size(); ++i) {",
      "    std::destroy_at(dest_raw + i);",
      "}",
      "::operator delete(dest_raw, sizeof(std::string) * source.size());",
      "$0"
    ],
    "description": "Moves elements from a source range to a destination range of uninitialized memory. It constructs new objects in the destination using the move constructor, potentially leaving source elements in a valid but unspecified state. Useful for efficient transfer of resources. Time complexity: O(n) move constructions. Link: https://en.cppreference.com/w/cpp/memory/uninitialized_move"
  },
  "cpp_raw_memory__destroy": {
    "prefix": "cpp_raw_memory__destroy",
    "body": [
      "// std::destroy - Destroys objects in a range (C++17)",
      "// Reference: https://en.cppreference.com/w/cpp/memory/destroy",
      "#include <memory>",
      "#include <vector>",
      "#include <iostream>",
      "#include <string>",
      "",
      "struct MyObject {",
      "    std::string name;",
      "    MyObject(const std::string& n) : name(n) {",
      "        std::cout << \"Constructing MyObject: \" << name << std::endl;",
      "    }",
      "    ~MyObject() {",
      "        std::cout << \"Destroying MyObject: \" << name << std::endl;",
      "    }",
      "};",
      "",
      "int main() {",
      "    // Allocate raw memory for 3 MyObjects",
      "    MyObject* raw_mem = static_cast<MyObject*>(::operator new(sizeof(MyObject) * 3));",
      "",
      "    // Construct objects in raw memory using placement new",
      "    new (raw_mem + 0) MyObject(\"One\");",
      "    new (raw_mem + 1) MyObject(\"Two\");",
      "    new (raw_mem + 2) MyObject(\"Three\");",
      "",
      "    std::cout << \"Objects constructed. Now destroying...\" << std::endl;",
      "",
      "    // Destroy the objects in the raw memory range",
      "    std::destroy(raw_mem, raw_mem + 3);",
      "",
      "    std::cout << \"Objects destroyed. Now deallocating memory.\" << std::endl;",
      "",
      "    // Deallocate the raw memory",
      "    ::operator delete(raw_mem, sizeof(MyObject) * 3);",
      "",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "Calls the destructors for all objects in a specified range of memory. This does not deallocate the memory itself, only destroys the objects. Useful for managing objects in raw memory buffers. Time complexity: O(n) destructor calls. Link: https://en.cppreference.com/w/cpp/memory/destroy"
  },
  "cpp_raw_memory__destroy_at": {
    "prefix": "cpp_raw_memory__destroy_at",
    "body": [
      "// std::destroy_at - Destroys an object at a specific location (C++17)",
      "// Reference: https://en.cppreference.com/w/cpp/memory/destroy_at",
      "#include <memory>",
      "#include <iostream>",
      "#include <string>",
      "",
      "struct MyObject {",
      "    std::string name;",
      "    MyObject(const std::string& n) : name(n) {",
      "        std::cout << \"Constructing MyObject: \" << name << std::endl;",
      "    }",
      "    ~MyObject() {",
      "        std::cout << \"Destroying MyObject: \" << name << std::endl;",
      "    }",
      "};",
      "",
      "int main() {",
      "    // Allocate raw memory for one MyObject",
      "    MyObject* raw_mem = static_cast<MyObject*>(::operator new(sizeof(MyObject)));",
      "",
      "    // Construct object in raw memory using placement new",
      "    new (raw_mem) MyObject(\"SingleObject\");",
      "",
      "    std::cout << \"Object constructed. Now destroying at location.\" << std::endl;",
      "",
      "    // Destroy the object at the specific memory location",
      "    std::destroy_at(raw_mem);",
      "",
      "    std::cout << \"Object destroyed. Now deallocating memory.\" << std::endl;",
      "",
      "    // Deallocate the raw memory",
      "    ::operator delete(raw_mem, sizeof(MyObject));",
      "",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "Calls the destructor for the object pointed to by the given pointer. This does not deallocate the memory. Useful for precise destruction of objects in raw memory. Time complexity: O(1) destructor call. Link: https://en.cppreference.com/w/cpp/memory/destroy_at"
  },
  "cpp_raw_memory__destroy_n": {
    "prefix": "cpp_raw_memory__destroy_n",
    "body": [
      "// std::destroy_n - Destroys n objects starting from a location (C++17)",
      "// Reference: https://en.cppreference.com/w/cpp/memory/destroy_n",
      "#include <memory>",
      "#include <vector>",
      "#include <iostream>",
      "#include <string>",
      "",
      "struct MyObject {",
      "    std::string name;",
      "    MyObject(const std::string& n) : name(n) {",
      "        std::cout << \"Constructing MyObject: \" << name << std::endl;",
      "    }",
      "    ~MyObject() {",
      "        std::cout << \"Destroying MyObject: \" << name << std::endl;",
      "    }",
      "};",
      "",
      "int main() {",
      "    // Allocate raw memory for 5 MyObjects",
      "    MyObject* raw_mem = static_cast<MyObject*>(::operator new(sizeof(MyObject) * 5));",
      "",
      "    // Construct objects in raw memory",
      "    new (raw_mem + 0) MyObject(\"Alpha\");",
      "    new (raw_mem + 1) MyObject(\"Beta\");",
      "    new (raw_mem + 2) MyObject(\"Gamma\");",
      "    new (raw_mem + 3) MyObject(\"Delta\");",
      "    new (raw_mem + 4) MyObject(\"Epsilon\");",
      "",
      "    std::cout << \"Objects constructed. Now destroying first 3...\" << std::endl;",
      "",
      "    // Destroy the first 3 objects",
      "    std::destroy_n(raw_mem, 3);",
      "",
      "    std::cout << \"First 3 objects destroyed. Now destroying remaining 2.\" << std::endl;",
      "",
      "    // Destroy the remaining 2 objects",
      "    std::destroy_n(raw_mem + 3, 2);",
      "",
      "    std::cout << \"All objects destroyed. Now deallocating memory.\" << std::endl;",
      "",
      "    // Deallocate the raw memory",
      "    ::operator delete(raw_mem, sizeof(MyObject) * 5);",
      "",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "Calls the destructors for n objects starting from a given memory location. This does not deallocate the memory. Useful for destroying a specific number of objects in a raw memory buffer. Time complexity: O(n) destructor calls. Link: https://en.cppreference.com/w/cpp/memory/destroy_n"
  },
  "cpp_algorithm__shift_left": {
    "prefix": "cpp_algorithm__shift_left",
    "body": [
      "// std::shift_left - Shifts elements to the left (C++20)",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/shift_left",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "std::vector<int> v = {1, 2, 3, 4, 5};",
      "",
      "std::cout << \"Original: \";",
      "for (int x : v) std::cout << x << \" \";",
      "std::cout << std::endl;",
      "",
      "// Shift left by 2 positions",
      "// Elements {1, 2} are discarded, {3, 4, 5} move to front",
      "// Remaining elements are default-constructed or left in unspecified state",
      "std::shift_left(v.begin(), v.end(), 2);",
      "",
      "std::cout << \"Shifted left by 2: \";",
      "for (int x : v) std::cout << x << \" \";",
      "std::cout << std::endl; // Shifted left by 2: 3 4 5 0 0 (or garbage for non-POD types)",
      "",
      "// Example with strings",
      "std::vector<std::string> words = {\"apple\", \"banana\", \"cherry\", \"date\"};",
      "std::shift_left(words.begin(), words.end(), 1);",
      "std::cout << \"Shifted strings left by 1: \";",
      "for (const std::string& s : words) std::cout << \"'\" << s << \"' \";",
      "std::cout << std::endl; // Shifted strings left by 1: 'banana' 'cherry' 'date' ''",
      "",
      "// Shifting by count >= range size results in empty range",
      "std::vector<int> v2 = {1, 2, 3};",
      "std::shift_left(v2.begin(), v2.end(), 3);",
      "std::cout << \"Shifted left by 3: \";",
      "for (int x : v2) std::cout << x << \" \";",
      "std::cout << std::endl; // Shifted left by 3: 0 0 0",
      "$0"
    ],
    "description": "Shifts elements in a range to the left by n positions. The first n elements are discarded. The remaining elements are moved to the beginning of the range. The elements at the end of the range are left in a valid but unspecified state (for non-trivial types, they are typically default-constructed or zero-initialized for POD types). Time complexity: O(n) moves. Link: https://en.cppreference.com/w/cpp/algorithm/shift_left"
  },
  "cpp_algorithm__shift_right": {
    "prefix": "cpp_algorithm__shift_right",
    "body": [
      "// std::shift_right - Shifts elements to the right (C++20)",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/shift_right",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "std::vector<int> v = {1, 2, 3, 4, 5};",
      "",
      "std::cout << \"Original: \";",
      "for (int x : v) std::cout << x << \" \";",
      "std::cout << std::endl;",
      "",
      "// Shift right by 2 positions",
      "// Elements {1, 2, 3} move to {3, 4, 5} positions",
      "// First 2 elements are default-constructed or left in unspecified state",
      "std::shift_right(v.begin(), v.end(), 2);",
      "",
      "std::cout << \"Shifted right by 2: \";",
      "for (int x : v) std::cout << x << \" \";",
      "std::cout << std::endl; // Shifted right by 2: 0 0 1 2 3 (or garbage for non-POD types)",
      "",
      "// Example with strings",
      "std::vector<std::string> words = {\"apple\", \"banana\", \"cherry\", \"date\"};",
      "std::shift_right(words.begin(), words.end(), 1);",
      "std::cout << \"Shifted strings right by 1: \";",
      "for (const std::string& s : words) std::cout << \"'\" << s << \"' \";",
      "std::cout << std::endl; // Shifted strings right by 1: '' 'apple' 'banana' 'cherry'",
      "",
      "// Shifting by count >= range size results in empty range",
      "std::vector<int> v2 = {1, 2, 3};",
      "std::shift_right(v2.begin(), v2.end(), 3);",
      "std::cout << \"Shifted right by 3: \";",
      "for (int x : v2) std::cout << x << \" \";",
      "std::cout << std::endl; // Shifted right by 3: 0 0 0",
      "$0"
    ],
    "description": "Shifts elements in a range to the right by n positions. The last n elements are discarded. The remaining elements are moved towards the end of the range. The elements at the beginning of the range are left in a valid but unspecified state (for non-trivial types, they are typically default-constructed or zero-initialized for POD types). Time complexity: O(n) moves. Link: https://en.cppreference.com/w/cpp/algorithm/shift_right"
  },
  "cpp_string__starts_with": {
    "prefix": "cpp_string__starts_with",
    "body": [
      "// std::string::starts_with - Check if string starts with prefix (C++20)",
      "// Reference: https://en.cppreference.com/w/cpp/string/basic_string/starts_with",
      "#include <string>",
      "#include <iostream>",
      "",
      "std::string s = \"hello world\";",
      "",
      "// Check with char",
      "bool starts_h = s.starts_with('h');",
      "std::cout << \"'hello world' starts with 'h': \" << std::boolalpha << starts_h << std::endl; // true",
      "",
      "// Check with string literal",
      "bool starts_hello = s.starts_with(\"hello\");",
      "std::cout << \"'hello world' starts with \"hello\": \" << std::boolalpha << starts_hello << std::endl; // true",
      "",
      "// Check with std::string_view",
      "std::string_view prefix = \"world\";",
      "bool starts_world = s.starts_with(prefix);",
      "std::cout << \"'hello world' starts with \"world\": \" << std::boolalpha << starts_world << std::endl; // false",
      "",
      "// Case-sensitive",
      "bool starts_H = s.starts_with('H');",
      "std::cout << \"'hello world' starts with 'H': \" << std::boolalpha << starts_H << std::endl; // false",
      "",
      "// Empty string prefix",
      "bool starts_empty = s.starts_with(\"\");",
      "std::cout << \"'hello world' starts with empty string: \" << std::boolalpha << starts_empty << std::endl; // true",
      "$0"
    ],
    "description": "Checks if a string (or string_view) begins with a specified prefix. Overloaded for char, string literal, and string_view. Case-sensitive. Time complexity: O(length of prefix). Link: https://en.cppreference.com/w/cpp/string/basic_string/starts_with"
  },
  "cpp_string__ends_with": {
    "prefix": "cpp_string__ends_with",
    "body": [
      "// std::string::ends_with - Check if string ends with suffix (C++20)",
      "// Reference: https://en.cppreference.com/w/cpp/string/basic_string/ends_with",
      "#include <string>",
      "#include <iostream>",
      "",
      "std::string s = \"hello world\";",
      "",
      "// Check with char",
      "bool ends_d = s.ends_with('d');",
      "std::cout << \"'hello world' ends with 'd': \" << std::boolalpha << ends_d << std::endl; // true",
      "",
      "// Check with string literal",
      "bool ends_world = s.ends_with(\"world\");",
      "std::cout << \"'hello world' ends with \"world\": \" << std::boolalpha << ends_world << std::endl; // true",
      "",
      "// Check with std::string_view",
      "std::string_view suffix = \"hello\";",
      "bool ends_hello = s.ends_with(suffix);",
      "std::cout << \"'hello world' ends with \"hello\": \" << std::boolalpha << ends_hello << std::endl; // false",
      "",
      "// Case-sensitive",
      "bool ends_D = s.ends_with('D');",
      "std::cout << \"'hello world' ends with 'D': \" << std::boolalpha << ends_D << std::endl; // false",
      "",
      "// Empty string suffix",
      "bool ends_empty = s.ends_with(\"\");",
      "std::cout << \"'hello world' ends with empty string: \" << std::boolalpha << ends_empty << std::endl; // true",
      "$0"
    ],
    "description": "Checks if a string (or string_view) ends with a specified suffix. Overloaded for char, string literal, and string_view. Case-sensitive. Time complexity: O(length of suffix). Link: https://en.cppreference.com/w/cpp/string/basic_string/ends_with"
  },
  "cpp_algorithm__contains": {
    "prefix": "cpp_algorithm__contains",
    "body": [
      "// std::ranges::contains - Check if range contains element (C++23)",
      "// Reference: https://en.cppreference.com/w/cpp/algorithm/ranges/contains",
      "#include <algorithm>",
      "#include <vector>",
      "#include <iostream>",
      "",
      "std::vector<int> v = {1, 2, 3, 4, 5};",
      "",
      "// Check if value exists",
      "bool has_3 = std::ranges::contains(v, 3);",
      "std::cout << \"Vector contains 3: \" << std::boolalpha << has_3 << std::endl; // true",
      "",
      "bool has_9 = std::ranges::contains(v, 9);",
      "std::cout << \"Vector contains 9: \" << std::boolalpha << has_9 << std::endl; // false",
      "",
      "// Check if sub-range exists",
      "std::vector<int> sub1 = {2, 3};",
      "bool has_sub1 = std::ranges::contains(v, sub1);",
      "std::cout << \"Vector contains {2, 3}: \" << std::boolalpha << has_sub1 << std::endl; // true",
      "",
      "std::vector<int> sub2 = {3, 5};",
      "bool has_sub2 = std::ranges::contains(v, sub2);",
      "std::cout << \"Vector contains {3, 5}: \" << std::boolalpha << has_sub2 << std::endl; // false",
      "",
      "// With custom predicate",
      "auto is_even = [](int n) { return n % 2 == 0; };",
      "// Check if any even number exists (equivalent to std::any_of)",
      "bool has_even = std::ranges::contains(v, 0, std::equal_to<int>(), is_even);",
      "// Note: std::ranges::contains with a projection and value is for checking if a transformed value exists.",
      "// For checking if *any* element satisfies a predicate, std::ranges::any_of is more direct.",
      "// The above example is conceptually flawed for 'any_of' use case.",
      "// Correct use for contains with predicate: check if a specific transformed value exists.",
      "// E.g., check if any element's square is 9",
      "bool has_square_9 = std::ranges::contains(v, 9, {}, [](int n){ return n * n; });",
      "std::cout << \"Vector contains element whose square is 9: \" << std::boolalpha << has_square_9 << std::endl; // true (for 3)",
      "$0"
    ],
    "description": "Checks if a range contains a specific value or a sub-range. For a single value, it uses `std::find`. For a sub-range, it uses `std::search`. Supports custom predicates and projections. Time complexity: O(N) for single value, O(N*M) for sub-range (where M is sub-range size). Link: https://en.cppreference.com/w/cpp/algorithm/ranges/contains"
  },
  "cpp_container__ssize": {
    "prefix": "cpp_container__ssize",
    "body": [
      "// std::ssize - Signed size of a container or array (C++17)",
      "// Reference: https://en.cppreference.com/w/cpp/iterator/ssize",
      "#include <vector>",
      "#include <string>",
      "#include <iostream>",
      "#include <iterator>",
      "",
      "std::vector<int> v = {1, 2, 3, 4, 5};",
      "std::string s = \"hello\";",
      "int arr[] = {10, 20, 30};",
      "",
      "// Get signed size of vector",
      "auto vec_size = std::ssize(v);",
      "std::cout << \"Vector size (signed): \" << vec_size << std::endl; // 5",
      "std::cout << \"Type of vec_size: \" << typeid(vec_size).name() << std::endl; // long or long long",
      "",
      "// Get signed size of string",
      "auto str_size = std::ssize(s);",
      "std::cout << \"String size (signed): \" << str_size << std::endl; // 5",
      "",
      "// Get signed size of C-style array",
      "auto arr_size = std::ssize(arr);",
      "std::cout << \"Array size (signed): \" << arr_size << std::endl; // 3",
      "",
      "// Useful for avoiding signed/unsigned comparison warnings",
      "for (long long i = 0; i < std::ssize(v); ++i) {",
      "    // Safe loop without warnings",
      "}",
      "",
      "// Can be used with empty containers",
      "std::vector<double> empty_v;",
      "auto empty_size = std::ssize(empty_v);",
      "std::cout << \"Empty vector size (signed): \" << empty_size << std::endl; // 0",
      "$0"
    ],
    "description": "Returns the signed size of a container or C-style array. This is useful for avoiding signed/unsigned comparison warnings and errors when iterating or performing arithmetic with sizes. Returns a signed integer type (e.g., std::ptrdiff_t). Time complexity: O(1). Link: https://en.cppreference.com/w/cpp/iterator/ssize"
  },
  "cpp_numeric__midpoint": {
    "prefix": "cpp_numeric__midpoint",
    "body": [
      "// std::midpoint - Computes the midpoint of two values (C++20)",
      "// Reference: https://en.cppreference.com/w/cpp/numeric/midpoint",
      "#include <numeric>",
      "#include <iostream>",
      "#include <limits>",
      "",
      "// Integers",
      "int i1 = std::midpoint(10, 20);",
      "std::cout << \"Midpoint(10, 20): \" << i1 << std::endl; // 15",
      "",
      "int i2 = std::midpoint(10, 21);",
      "std::cout << \"Midpoint(10, 21): \" << i2 << std::endl; // 15 (truncates towards zero)",
      "",
      "int i3 = std::midpoint(-10, 20);",
      "std::cout << \"Midpoint(-10, 20): \" << i3 << std::endl; // 5",
      "",
      "int i4 = std::midpoint(-10, -20);",
      "std::cout << \"Midpoint(-10, -20): \" << i4 << std::endl; // -15",
      "",
      "// Floating-point numbers",
      "double d1 = std::midpoint(10.0, 20.0);",
      "std::cout << \"Midpoint(10.0, 20.0): \" << d1 << std::endl; // 15.0",
      "",
      "double d2 = std::midpoint(10.0, 21.0);",
      "std::cout << \"Midpoint(10.0, 21.0): \" << d2 << std::endl; // 15.5",
      "",
      "// Handles overflow for integers safely",
      "// long long max_val = std::numeric_limits<long long>::max();",
      "// long long min_val = std::numeric_limits<long long>::min();",
      "// long long mid_overflow = std::midpoint(max_val - 1, max_val); // No overflow",
      "",
      "// Pointers (midpoint of two pointers to elements in the same array)",
      "int arr[] = {10, 20, 30, 40, 50};",
      "int* p1 = arr;",
      "int* p2 = arr + 4;",
      "int* mid_p = std::midpoint(p1, p2);",
      "std::cout << \"Midpoint of pointers: \" << *mid_p << std::endl; // 30",
      "$0"
    ],
    "description": "Computes the midpoint of two values of the same type. For integers, it performs the calculation in a way that avoids overflow and truncates towards zero. For floating-point types, it computes the average. It also supports computing the midpoint of two pointers within the same array. Time complexity: O(1). Link: https://en.cppreference.com/w/cpp/numeric/midpoint"
  },
  "cpp_numeric__lerp": {
    "prefix": "cpp_numeric__lerp",
    "body": [
      "// std::lerp - Linear interpolation (C++20)",
      "// Reference: https://en.cppreference.com/w/cpp/numeric/lerp",
      "#include <numeric>",
      "#include <iostream>",
      "#include <cmath>",
      "",
      "// Basic linear interpolation",
      "double start = 0.0;",
      "double end = 100.0;",
      "",
      "// t = 0.0 -> returns start",
      "double val0 = std::lerp(start, end, 0.0);",
      "std::cout << \"lerp(0, 100, 0.0): \" << val0 << std::endl; // 0.0",
      "",
      "// t = 0.5 -> returns midpoint",
      "double val0_5 = std::lerp(start, end, 0.5);",
      "std::cout << \"lerp(0, 100, 0.5): \" << val0_5 << std::endl; // 50.0",
      "",
      "// t = 1.0 -> returns end",
      "double val1 = std::lerp(start, end, 1.0);",
      "std::cout << \"lerp(0, 100, 1.0): \" << val1 << std::endl; // 100.0",
      "",
      "// t outside [0, 1] range (extrapolation)",
      "double val_neg = std::lerp(start, end, -0.2);",
      "std::cout << \"lerp(0, 100, -0.2): \" << val_neg << std::endl; // -20.0",
      "",
      "double val_over = std::lerp(start, end, 1.2);",
      "std::cout << \"lerp(0, 100, 1.2): \" << val_over << std::endl; // 120.0",
      "",
      "// Interpolating colors (example with float components)",
      "struct Color { float r, g, b; };",
      "Color c1 = {1.0f, 0.0f, 0.0f}; // Red",
      "Color c2 = {0.0f, 0.0f, 1.0f}; // Blue",
      "",
      "float t = 0.25f;",
      "Color interpolated_color = {",
      "    std::lerp(c1.r, c2.r, t),",
      "    std::lerp(c1.g, c2.g, t),",
      "    std::lerp(c1.b, c2.b, t)",
      "};",
      "std::cout << \"Interpolated color (t=0.25): R=\" << interpolated_color.r",
      "          << \", G=\" << interpolated_color.g << \", B=\" << interpolated_color.b << std::endl;",
      "// Output: R=0.75, G=0, B=0.25",
      "$0"
    ],
    "description": "Performs linear interpolation between two values a and b, using a weight t. The formula is a + t * (b - a). If t is between 0 and 1, the result is between a and b. If t is outside this range, it performs extrapolation. Supports floating-point types. Time complexity: O(1). Link: https://en.cppreference.com/w/cpp/numeric/lerp"
  },
  "cpp_numeric__countl_zero": {
    "prefix": "cpp_numeric__countl_zero",
    "body": [
      "// std::countl_zero - Count leading zero bits (C++20)",
      "// Reference: https://en.cppreference.com/w/cpp/numeric/countl_zero",
      "#include <bit>",
      "#include <iostream>",
      "#include <limits>",
      "",
      "// For unsigned integers",
      "unsigned int u1 = 0b00001010u; // 10 in binary",
      "int zeros1 = std::countl_zero(u1);",
      "// Assuming 32-bit unsigned int, total bits - (log2(10) + 1) = 32 - 4 = 28",
      "std::cout << \"Leading zeros in 0b00001010u (10): \" << zeros1 << std::endl; // 28 (for 32-bit int)",
      "",
      "unsigned int u2 = 0b10000000u; // 128",
      "int zeros2 = std::countl_zero(u2);",
      "std::cout << \"Leading zeros in 0b10000000u (128): \" << zeros2 << std::endl; // 24 (for 32-bit int)",
      "",
      "unsigned int u3 = 0u; // All zeros",
      "int zeros3 = std::countl_zero(u3);",
      "std::cout << \"Leading zeros in 0u: \" << zeros3 << std::endl; // 32 (for 32-bit int)",
      "",
      "unsigned int u4 = std::numeric_limits<unsigned int>::max(); // All ones",
      "int zeros4 = std::countl_zero(u4);",
      "std::cout << \"Leading zeros in all ones: \" << zeros4 << std::endl; // 0",
      "",
      "// For unsigned long long",
      "unsigned long long ull = 0b0001000000000000000000000000000000000000000000000000000000000000ULL;",
      "int zeros_ull = std::countl_zero(ull);",
      "std::cout << \"Leading zeros in large ULL: \" << zeros_ull << std::endl; // 60 (for 64-bit ULL)",
      "$0"
    ],
    "description": "Counts the number of consecutive leading zero bits in the binary representation of an unsigned integer. If the value is zero, it returns the total number of bits in the type. Useful for bit manipulation and optimization. Time complexity: O(1) (typically implemented as a single CPU instruction). Link: https://en.cppreference.com/w/cpp/numeric/countl_zero"
  },
  "cpp_numeric__countl_one": {
    "prefix": "cpp_numeric__countl_one",
    "body": [
      "// std::countl_one - Count leading one bits (C++20)",
      "// Reference: https://en.cppreference.com/w/cpp/numeric/countl_one",
      "#include <bit>",
      "#include <iostream>",
      "#include <limits>",
      "",
      "// For unsigned integers",
      "unsigned int u1 = 0b11110101u; // Example value",
      "int ones1 = std::countl_one(u1);",
      "// Assuming 32-bit unsigned int, and u1 is 0b0000...11110101",
      "// This counts leading 1s, so if it's 0b0000... then it's 0.",
      "// To get actual leading ones, you'd typically invert the number first or use a mask.",
      "// Let's use an example where leading bits are actually 1s.",
      "unsigned int u2 = 0xFFFFFFFFu; // All ones (for 32-bit)",
      "int ones2 = std::countl_one(u2);",
      "std::cout << \"Leading ones in all ones: \" << ones2 << std::endl; // 32 (for 32-bit int)",
      "",
      "unsigned int u3 = 0xFFF00000u; // 12 leading ones (for 32-bit)",
      "int ones3 = std::countl_one(u3);",
      "std::cout << \"Leading ones in 0xFFF00000u: \" << ones3 << std::endl; // 12 (for 32-bit int)",
      "",
      "unsigned int u4 = 0u; // All zeros",
      "int ones4 = std::countl_one(u4);",
      "std::cout << \"Leading ones in 0u: \" << ones4 << std::endl; // 0",
      "",
      "unsigned int u5 = 0x7FFFFFFFu; // Max int with leading zero",
      "int ones5 = std::countl_one(u5);",
      "std::cout << \"Leading ones in 0x7FFFFFFFu: \" << ones5 << std::endl; // 0",
      "$0"
    ],
    "description": "Counts the number of consecutive leading one bits in the binary representation of an unsigned integer. If the value is all zeros, it returns zero. Useful for bit manipulation. Time complexity: O(1) (typically implemented as a single CPU instruction). Link: https://en.cppreference.com/w/cpp/numeric/countl_one"
  },
  "cpp_numeric__countr_zero": {
    "prefix": "cpp_numeric__countr_zero",
    "body": [
      "// std::countr_zero - Count trailing zero bits (C++20)",
      "// Reference: https://en.cppreference.com/w/cpp/numeric/countr_zero",
      "#include <bit>",
      "#include <iostream>",
      "#include <limits>",
      "",
      "// For unsigned integers",
      "unsigned int u1 = 0b10100000u; // Example value",
      "int zeros1 = std::countr_zero(u1);",
      "std::cout << \"Trailing zeros in 0b10100000u: \" << zeros1 << std::endl; // 5",
      "",
      "unsigned int u2 = 0b00000001u; // 1",
      "int zeros2 = std::countr_zero(u2);",
      "std::cout << \"Trailing zeros in 0b00000001u: \" << zeros2 << std::endl; // 0",
      "",
      "unsigned int u3 = 0u; // All zeros",
      "int zeros3 = std::countr_zero(u3);",
      "std::cout << \"Trailing zeros in 0u: \" << zeros3 << std::endl; // 32 (for 32-bit int)",
      "",
      "unsigned int u4 = std::numeric_limits<unsigned int>::max(); // All ones",
      "int zeros4 = std::countr_zero(u4);",
      "std::cout << \"Trailing zeros in all ones: \" << zeros4 << std::endl; // 0",
      "",
      "// For unsigned long long",
      "unsigned long long ull = 0b1010000000000000000000000000000000000000000000000000000000000000ULL;",
      "int zeros_ull = std::countr_zero(ull);",
      "std::cout << \"Trailing zeros in large ULL: \" << zeros_ull << std::endl; // 60 (for 64-bit ULL)",
      "$0"
    ],
    "description": "Counts the number of consecutive trailing zero bits in the binary representation of an unsigned integer. If the value is zero, it returns the total number of bits in the type. Useful for bit manipulation and optimization. Time complexity: O(1) (typically implemented as a single CPU instruction). Link: https://en.cppreference.com/w/cpp/numeric/countr_zero"
  },
  "cpp_numeric__countr_one": {
    "prefix": "cpp_numeric__countr_one",
    "body": [
      "// std::countr_one - Count trailing one bits (C++20)",
      "// Reference: https://en.cppreference.com/w/cpp/numeric/countr_one",
      "#include <bit>",
      "#include <iostream>",
      "#include <limits>",
      "",
      "// For unsigned integers",
      "unsigned int u1 = 0b01011111u; // Example value",
      "int ones1 = std::countr_one(u1);",
      "std::cout << \"Trailing ones in 0b01011111u: \" << ones1 << std::endl; // 5",
      "",
      "unsigned int u2 = 0b11111111u; // All ones",
      "int ones2 = std::countr_one(u2);",
      "std::cout << \"Trailing ones in all ones: \" << ones2 << std::endl; // 32 (for 32-bit int)",
      "",
      "unsigned int u3 = 0b10000000u; // Single leading one",
      "int ones3 = std::countr_one(u3);",
      "std::cout << \"Trailing ones in 0b10000000u: \" << ones3 << std::endl; // 0",
      "",
      "unsigned int u4 = 0u; // All zeros",
      "int ones4 = std::countr_one(u4);",
      "std::cout << \"Trailing ones in 0u: \" << ones4 << std::endl; // 0",
      "$0"
    ],
    "description": "Counts the number of consecutive trailing one bits in the binary representation of an unsigned integer. If the value is all zeros, it returns zero. Useful for bit manipulation. Time complexity: O(1) (typically implemented as a single CPU instruction). Link: https://en.cppreference.com/w/cpp/numeric/countr_one"
  },
  "cpp_numeric__popcount": {
    "prefix": "cpp_numeric__popcount",
    "body": [
      "// std::popcount - Count set bits (population count) (C++20)",
      "// Reference: https://en.cppreference.com/w/cpp/numeric/popcount",
      "#include <bit>",
      "#include <iostream>",
      "",
      "// For unsigned integers",
      "unsigned int u1 = 0b00001010u; // 10 (binary: 1010), popcount = 2",
      "int count1 = std::popcount(u1);",
      "std::cout << \"Popcount of 10 (0b1010): \" << count1 << std::endl; // 2",
      "",
      "unsigned int u2 = 0b11111111u; // 255 (binary: 11111111), popcount = 8",
      "int count2 = std::popcount(u2);",
      "std::cout << \"Popcount of 255 (0b11111111): \" << count2 << std::endl; // 8",
      "",
      "unsigned int u3 = 0u; // 0, popcount = 0",
      "int count3 = std::popcount(u3);",
      "std::cout << \"Popcount of 0: \" << count3 << std::endl; // 0",
      "",
      "unsigned int u4 = 1u << 31; // Highest bit set (for 32-bit unsigned int)",
      "int count4 = std::popcount(u4);",
      "std::cout << \"Popcount of (1 << 31): \" << count4 << std::endl; // 1",
      "",
      "// For unsigned long long",
      "unsigned long long ull = 0b1101010110101011ULL;",
      "int count_ull = std::popcount(ull);",
      "std::cout << \"Popcount of 0b1101010110101011ULL: \" << count_ull << std::endl; // 10",
      "$0"
    ],
    "description": "Counts the number of set (1) bits in the binary representation of an unsigned integer. Also known as Hamming weight. Useful for various bit manipulation tasks and algorithms. Time complexity: O(1) (typically implemented as a single CPU instruction). Link: https://en.cppreference.com/w/cpp/numeric/popcount"
  }
}
