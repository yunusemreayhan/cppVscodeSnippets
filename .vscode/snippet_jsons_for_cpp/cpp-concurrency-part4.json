{
  "cpp_concurrency__thread_pool": {
    "prefix": "cpp_concurrency__thread_pool",
    "body": [
      "// C++ Concurrency: Basic Thread Pool Implementation",
      "// A thread pool manages a collection of worker threads to execute a queue of tasks.",
      "// This pattern helps reduce the overhead of creating and destroying threads for each task,",
      "// and limits the number of concurrent threads.",
      "// Note: This is a simplified example. Production-grade thread pools are more complex.",
      "#include <iostream>",
      "#include <vector>",
      "#include <queue>",
      "#include <thread>",
      "#include <mutex>",
      "#include <condition_variable>",
      "#include <future>",
      "#include <functional>",
      "",
      "class ThreadPool {",
      "public:",
      "    ThreadPool(size_t num_threads) : stop(false) {",
      "        for (size_t i = 0; i < num_threads; ++i) {",
      "            workers.emplace_back([this] {",
      "                for (;;) {",
      "                    std::function<void()> task;",
      "                    {",
      "                        std::unique_lock<std::mutex> lock(this->queue_mutex);",
      "                        this->condition.wait(lock, [this] {",
      "                            return this->stop || !this->tasks.empty();",
      "                        });",
      "                        if (this->stop && this->tasks.empty()) {",
      "                            return;",
      "                        }",
      "                        task = std::move(this->tasks.front());",
      "                        this->tasks.pop();",
      "                    }",
      "                    task();",
      "                }",
      "            });",
      "        }",
      "    }",
      "",
      "    // Add new task to the pool",
      "    template<class F, class... Args>",
      "    auto enqueue(F&& f, Args&&... args) ",
      "        -> std::future<typename std::result_of<F(Args...)>::type>",
      "    {",
      "        using return_type = typename std::result_of<F(Args...)>::type;",
      "",
      "        auto task = std::make_shared<std::packaged_task<return_type()>>(",
      "            std::bind(std::forward<F>(f), std::forward<Args>(args)...)",
      "        );",
      "",
      "        std::future<return_type> res = task->get_future();",
      "        {",
      "            std::unique_lock<std::mutex> lock(queue_mutex);",
      "",
      "            // Don't allow enqueueing after stopping the pool",
      "            if (stop) {",
      "                throw std::runtime_error(\"enqueue on stopped ThreadPool\");",
      "            }",
      "            tasks.emplace([task]() { (*task)(); });",
      "        }",
      "        condition.notify_one();",
      "        return res;",
      "    }",
      "",
      "    ~ThreadPool() {",
      "        {",
      "            std::unique_lock<std::mutex> lock(queue_mutex);",
      "            stop = true;",
      "        }",
      "        condition.notify_all();",
      "        for (std::thread &worker : workers) {",
      "            worker.join();",
      "        }",
      "    }",
      "",
      "private:",
      "    // Need to keep track of threads so we can join them",
      "    std::vector<std::thread> workers;",
      "    // The task queue",
      "    std::queue<std::function<void()>> tasks;",
      "",
      "    // Synchronization",
      "    std::mutex queue_mutex;",
      "    std::condition_variable condition;",
      "    bool stop;",
      "};",
      "",
      "// Example usage:",
      "int main() {",
      "    ThreadPool pool(4); // Create a thread pool with 4 worker threads",
      "",
      "    std::vector<std::future<int>> results;",
      "",
      "    for (int i = 0; i < 8; ++i) {",
      "        results.emplace_back(",
      "            pool.enqueue([i] {",
      "                std::cout << \"hello from task \" << i << \" on thread \" << std::this_thread::get_id() << std::endl;",
      "                std::this_thread::sleep_for(std::chrono::seconds(1));",
      "                std::cout << \"task \" << i << \" finished\" << std::endl;",
      "                return i * i;",
      "            })",
      "        );",
      "    }",
      "",
      "    std::cout << \"Main thread doing other work...\\n\";",
      "    std::this_thread::sleep_for(std::chrono::milliseconds(500));",
      "",
      "    std::cout << \"\\nResults:\\n\";",
      "    for (auto &&result : results) {",
      "        std::cout << result.get() << ' ';",
      "    }",
      "    std::cout << std::endl;",
      "",
      "    std::cout << \"\\nMain thread finished.\\n\";",
      "    return 0;",
      "}",
      "$0"
    ],
    "description": "C++ Concurrency: Basic Thread Pool implementation for managing worker threads and task queues."
  }
}
