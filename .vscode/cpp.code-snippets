{
  // C++11 Features
  "cpp_11__auto_and_decltype": {
    "prefix": "cpp_11__auto_and_decltype",
    "body": [
      "// C++11: auto and decltype",
      "auto x = 42;                    // int",
      "auto y = 3.14;                  // double",
      "auto str = std::string(\"hello\"); // std::string",
      "",
      "// decltype for type deduction",
      "int a = 5;",
      "decltype(a) b = 10;            // int",
      "decltype((a)) c = a;           // int& (note double parentheses)",
      "",
      "// Trailing return type with decltype",
      "template<typename T, typename U>",
      "auto add(T t, U u) -> decltype(t + u) {",
      "    return t + u;",
      "}",
      "$0"
    ],
    "description": "C++11 auto and decltype for type deduction"
  },

  "cpp_11__range_for": {
    "prefix": "cpp_11__range_for",
    "body": [
      "// C++11: Range-based for loop",
      "std::vector<int> vec = {1, 2, 3, 4, 5};",
      "",
      "// By value",
      "for (int x : vec) {",
      "    std::cout << x << \" \";",
      "}",
      "",
      "// By reference",
      "for (int& x : vec) {",
      "    x *= 2;",
      "}",
      "",
      "// By const reference",
      "for (const auto& x : vec) {",
      "    std::cout << x << \" \";",
      "}",
      "$0"
    ],
    "description": "C++11 range-based for loop"
  },

  "cpp_11__lambda_expressions": {
    "prefix": "cpp_11__lambda_expressions",
    "body": [
      "// C++11: Lambda expressions",
      "",
      "// Basic lambda",
      "auto simple = []() { std::cout << \"Hello Lambda!\\n\"; };",
      "simple();",
      "",
      "// Lambda with parameters",
      "auto add = [](int a, int b) { return a + b; };",
      "std::cout << add(5, 3) << std::endl;",
      "",
      "// Lambda with capture",
      "int x = 10;",
      "auto capture_by_value = [x]() { return x * 2; };",
      "auto capture_by_ref = [&x]() { x *= 2; return x; };",
      "auto capture_all_by_value = [=]() { return x + 5; };",
      "auto capture_all_by_ref = [&]() { x += 5; return x; };",
      "",
      "// Lambda with std::function",
      "std::function<int(int, int)> func = [](int a, int b) { return a * b; };",
      "$0"
    ],
    "description": "C++11 lambda expressions"
  },

  "cpp_11__smart_pointers": {
    "prefix": "cpp_11__smart_pointers",
    "body": [
      "// C++11: Smart pointers",
      "#include <memory>",
      "",
      "// unique_ptr - exclusive ownership",
      "std::unique_ptr<int> uptr1(new int(42));",
      "std::unique_ptr<int> uptr2 = std::make_unique<int>(42); // C++14",
      "// uptr2 = uptr1; // Error! Cannot copy",
      "std::unique_ptr<int> uptr3 = std::move(uptr1); // OK, move ownership",
      "",
      "// shared_ptr - shared ownership",
      "std::shared_ptr<int> sptr1(new int(42));",
      "std::shared_ptr<int> sptr2 = std::make_shared<int>(42); // Preferred",
      "std::shared_ptr<int> sptr3 = sptr2; // OK, shared ownership",
      "std::cout << \"Use count: \" << sptr2.use_count() << std::endl;",
      "",
      "// weak_ptr - weak reference",
      "std::weak_ptr<int> wptr = sptr2;",
      "if (auto sptr = wptr.lock()) { // Convert to shared_ptr if still exists",
      "    std::cout << *sptr << std::endl;",
      "}",
      "$0"
    ],
    "description": "C++11 smart pointers (unique_ptr, shared_ptr, weak_ptr)"
  },

  "cpp_11__move_semantics": {
    "prefix": "cpp_11__move_semantics",
    "body": [
      "// C++11: Move semantics and rvalue references",
      "class MyClass {",
      "private:",
      "    int* data;",
      "    size_t size;",
      "",
      "public:",
      "    // Constructor",
      "    MyClass(size_t s) : size(s), data(new int[s]) {}",
      "    ",
      "    // Destructor",
      "    ~MyClass() { delete[] data; }",
      "    ",
      "    // Copy constructor",
      "    MyClass(const MyClass& other) : size(other.size), data(new int[size]) {",
      "        std::copy(other.data, other.data + size, data);",
      "    }",
      "    ",
      "    // Move constructor",
      "    MyClass(MyClass&& other) noexcept : data(other.data), size(other.size) {",
      "        other.data = nullptr;",
      "        other.size = 0;",
      "    }",
      "    ",
      "    // Copy assignment",
      "    MyClass& operator=(const MyClass& other) {",
      "        if (this != &other) {",
      "            delete[] data;",
      "            size = other.size;",
      "            data = new int[size];",
      "            std::copy(other.data, other.data + size, data);",
      "        }",
      "        return *this;",
      "    }",
      "    ",
      "    // Move assignment",
      "    MyClass& operator=(MyClass&& other) noexcept {",
      "        if (this != &other) {",
      "            delete[] data;",
      "            data = other.data;",
      "            size = other.size;",
      "            other.data = nullptr;",
      "            other.size = 0;",
      "        }",
      "        return *this;",
      "    }",
      "};",
      "",
      "// Usage",
      "MyClass obj1(100);",
      "MyClass obj2 = std::move(obj1); // Move constructor",
      "$0"
    ],
    "description": "C++11 move semantics with move constructor and assignment"
  },

  "cpp_11__constexpr": {
    "prefix": "cpp_11__constexpr",
    "body": [
      "// C++11: constexpr for compile-time computation",
      "",
      "// constexpr function (C++11 limited to single return)",
      "constexpr int factorial(int n) {",
      "    return n <= 1 ? 1 : n * factorial(n - 1);",
      "}",
      "",
      "// constexpr variable",
      "constexpr int fact5 = factorial(5); // Computed at compile time",
      "",
      "// constexpr constructor",
      "class Point {",
      "    int x, y;",
      "public:",
      "    constexpr Point(int x, int y) : x(x), y(y) {}",
      "    constexpr int getX() const { return x; }",
      "    constexpr int getY() const { return y; }",
      "};",
      "",
      "constexpr Point p(10, 20);",
      "constexpr int px = p.getX(); // Compile-time constant",
      "$0"
    ],
    "description": "C++11 constexpr for compile-time computation"
  },

  "cpp_11__nullptr": {
    "prefix": "cpp_11__nullptr",
    "body": [
      "// C++11: nullptr - type-safe null pointer",
      "",
      "// Old way (C++98/03)",
      "int* p1 = NULL;  // NULL is typically defined as 0",
      "int* p2 = 0;     // Can be ambiguous",
      "",
      "// New way (C++11)",
      "int* p3 = nullptr;  // Type-safe, unambiguous",
      "",
      "// Function overloading example",
      "void f(int) { std::cout << \"f(int)\\n\"; }",
      "void f(int*) { std::cout << \"f(int*)\\n\"; }",
      "",
      "f(0);       // Calls f(int) - ambiguous!",
      "f(nullptr); // Calls f(int*) - clear intent",
      "$0"
    ],
    "description": "C++11 nullptr for type-safe null pointers"
  },

  "cpp_11__enum_class": {
    "prefix": "cpp_11__enum_class",
    "body": [
      "// C++11: Scoped enums (enum class)",
      "",
      "// Old style enum",
      "enum Color { RED, GREEN, BLUE };",
      "// int x = RED; // RED is in global scope",
      "",
      "// Scoped enum (enum class)",
      "enum class Status { OK, ERROR, PENDING };",
      "enum class ErrorCode : uint8_t { NONE = 0, FILE_NOT_FOUND = 1, ACCESS_DENIED = 2 };",
      "",
      "// Usage",
      "Status s = Status::OK;",
      "// int x = Status::OK; // Error! No implicit conversion",
      "int x = static_cast<int>(Status::OK); // Explicit conversion needed",
      "",
      "if (s == Status::OK) {",
      "    std::cout << \"Status is OK\\n\";",
      "}",
      "$0"
    ],
    "description": "C++11 scoped enums (enum class)"
  },

  "cpp_11__initializer_list": {
    "prefix": "cpp_11__initializer_list",
    "body": [
      "// C++11: Initializer lists and uniform initialization",
      "#include <initializer_list>",
      "#include <vector>",
      "",
      "// Uniform initialization",
      "int arr[] = {1, 2, 3, 4, 5};",
      "std::vector<int> vec = {1, 2, 3, 4, 5};",
      "std::pair<int, std::string> p = {42, \"hello\"};",
      "",
      "// Class with initializer_list constructor",
      "class MyContainer {",
      "    std::vector<int> data;",
      "public:",
      "    MyContainer(std::initializer_list<int> init) : data(init) {}",
      "    ",
      "    void print() const {",
      "        for (int x : data) {",
      "            std::cout << x << \" \";",
      "        }",
      "        std::cout << std::endl;",
      "    }",
      "};",
      "",
      "MyContainer c = {1, 2, 3, 4, 5};",
      "c.print();",
      "$0"
    ],
    "description": "C++11 initializer lists and uniform initialization"
  },

  "cpp_11__variadic_templates": {
    "prefix": "cpp_11__variadic_templates",
    "body": [
      "// C++11: Variadic templates",
      "",
      "// Base case for recursion",
      "void print() {",
      "    std::cout << std::endl;",
      "}",
      "",
      "// Variadic template function",
      "template<typename T, typename... Args>",
      "void print(T first, Args... args) {",
      "    std::cout << first << \" \";",
      "    print(args...); // Recursive call with remaining arguments",
      "}",
      "",
      "// Variadic template class",
      "template<typename... Types>",
      "class Tuple {",
      "    // Implementation...",
      "};",
      "",
      "// sizeof... operator",
      "template<typename... Args>",
      "size_t countArgs(Args... args) {",
      "    return sizeof...(args);",
      "}",
      "",
      "// Usage",
      "print(1, 2.5, \"hello\", 'a'); // Can pass any number of arguments",
      "std::cout << \"Arg count: \" << countArgs(1, 2, 3, 4, 5) << std::endl;",
      "$0"
    ],
    "description": "C++11 variadic templates"
  },

  "cpp_11__static_assert": {
    "prefix": "cpp_11__static_assert",
    "body": [
      "// C++11: static_assert for compile-time assertions",
      "",
      "// Basic usage",
      "static_assert(sizeof(int) == 4, \"This code requires 32-bit integers\");",
      "",
      "// With templates",
      "template<typename T>",
      "class Container {",
      "    static_assert(std::is_default_constructible<T>::value,",
      "                  \"T must be default constructible\");",
      "    // ...",
      "};",
      "",
      "// Check template parameters",
      "template<int N>",
      "class FixedArray {",
      "    static_assert(N > 0, \"Array size must be positive\");",
      "    int data[N];",
      "};",
      "$0"
    ],
    "description": "C++11 static_assert for compile-time assertions"
  },

  "cpp_11__thread": {
    "prefix": "cpp_11__thread",
    "body": [
      "// C++11: std::thread for multithreading",
      "#include <thread>",
      "#include <mutex>",
      "#include <condition_variable>",
      "",
      "// Basic thread",
      "void worker(int id) {",
      "    std::cout << \"Worker \" << id << \" started\\n\";",
      "    std::this_thread::sleep_for(std::chrono::seconds(1));",
      "    std::cout << \"Worker \" << id << \" finished\\n\";",
      "}",
      "",
      "// Thread with lambda",
      "std::thread t1([]() {",
      "    std::cout << \"Lambda thread\\n\";",
      "});",
      "",
      "// Thread with arguments",
      "std::thread t2(worker, 1);",
      "",
      "// Join threads",
      "t1.join();",
      "t2.join();",
      "",
      "// Mutex for synchronization",
      "std::mutex mtx;",
      "std::lock_guard<std::mutex> lock(mtx);",
      "// Critical section",
      "$0"
    ],
    "description": "C++11 std::thread and synchronization"
  },

  "cpp_11__chrono": {
    "prefix":
